diff --git a/node_modules/ajv/.runkit_example.js.bak b/node_modules/ajv/.runkit_example.js.bak
new file mode 100644
index 0000000..0d578d5
--- /dev/null
+++ b/node_modules/ajv/.runkit_example.js.bak
@@ -0,0 +1,23 @@
+const Ajv = require("ajv")
+const ajv = new Ajv({allErrors: true})
+
+const schema = {
+  type: "object",
+  properties: {
+    foo: {type: "string"},
+    bar: {type: "number", maximum: 3},
+  },
+  required: ["foo", "bar"],
+  additionalProperties: false,
+}
+
+const validate = ajv.compile(schema)
+
+test({foo: "abc", bar: 2})
+test({foo: 2, bar: 4})
+
+function test(data) {
+  const valid = validate(data)
+  if (valid) console.log("Valid!")
+  else console.log("Invalid: " + ajv.errorsText(validate.errors))
+}
diff --git a/node_modules/ajv/dist/2019.js b/node_modules/ajv/dist/2019.js
index f30eb9e..2035604 100644
--- a/node_modules/ajv/dist/2019.js
+++ b/node_modules/ajv/dist/2019.js
@@ -56,4 +56,3 @@ var validation_error_1 = require("./runtime/validation_error");
 Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
 var ref_error_1 = require("./compile/ref_error");
 Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
-//# sourceMappingURL=2019.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/2019.js.bak b/node_modules/ajv/dist/2019.js.bak
new file mode 100644
index 0000000..2035604
--- /dev/null
+++ b/node_modules/ajv/dist/2019.js.bak
@@ -0,0 +1,58 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
+const core_1 = require("./core");
+const draft7_1 = require("./vocabularies/draft7");
+const dynamic_1 = require("./vocabularies/dynamic");
+const next_1 = require("./vocabularies/next");
+const unevaluated_1 = require("./vocabularies/unevaluated");
+const discriminator_1 = require("./vocabularies/discriminator");
+const json_schema_2019_09_1 = require("./refs/json-schema-2019-09");
+const META_SCHEMA_ID = "https://json-schema.org/draft/2019-09/schema";
+class Ajv2019 extends core_1.default {
+    constructor(opts = {}) {
+        super({
+            ...opts,
+            dynamicRef: true,
+            next: true,
+            unevaluated: true,
+        });
+    }
+    _addVocabularies() {
+        super._addVocabularies();
+        this.addVocabulary(dynamic_1.default);
+        draft7_1.default.forEach((v) => this.addVocabulary(v));
+        this.addVocabulary(next_1.default);
+        this.addVocabulary(unevaluated_1.default);
+        if (this.opts.discriminator)
+            this.addKeyword(discriminator_1.default);
+    }
+    _addDefaultMetaSchema() {
+        super._addDefaultMetaSchema();
+        const { $data, meta } = this.opts;
+        if (!meta)
+            return;
+        json_schema_2019_09_1.default.call(this, $data);
+        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
+    }
+    defaultMeta() {
+        return (this.opts.defaultMeta =
+            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
+    }
+}
+module.exports = exports = Ajv2019;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = Ajv2019;
+var validate_1 = require("./compile/validate");
+Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
+var codegen_1 = require("./compile/codegen");
+Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
+Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
+Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
+Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
+Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
+Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
+var validation_error_1 = require("./runtime/validation_error");
+Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
+var ref_error_1 = require("./compile/ref_error");
+Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
diff --git a/node_modules/ajv/dist/2020.js b/node_modules/ajv/dist/2020.js
index 50a532e..27fd2ee 100644
--- a/node_modules/ajv/dist/2020.js
+++ b/node_modules/ajv/dist/2020.js
@@ -50,4 +50,3 @@ var validation_error_1 = require("./runtime/validation_error");
 Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
 var ref_error_1 = require("./compile/ref_error");
 Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
-//# sourceMappingURL=2020.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/2020.js.bak b/node_modules/ajv/dist/2020.js.bak
new file mode 100644
index 0000000..27fd2ee
--- /dev/null
+++ b/node_modules/ajv/dist/2020.js.bak
@@ -0,0 +1,52 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
+const core_1 = require("./core");
+const draft2020_1 = require("./vocabularies/draft2020");
+const discriminator_1 = require("./vocabularies/discriminator");
+const json_schema_2020_12_1 = require("./refs/json-schema-2020-12");
+const META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
+class Ajv2020 extends core_1.default {
+    constructor(opts = {}) {
+        super({
+            ...opts,
+            dynamicRef: true,
+            next: true,
+            unevaluated: true,
+        });
+    }
+    _addVocabularies() {
+        super._addVocabularies();
+        draft2020_1.default.forEach((v) => this.addVocabulary(v));
+        if (this.opts.discriminator)
+            this.addKeyword(discriminator_1.default);
+    }
+    _addDefaultMetaSchema() {
+        super._addDefaultMetaSchema();
+        const { $data, meta } = this.opts;
+        if (!meta)
+            return;
+        json_schema_2020_12_1.default.call(this, $data);
+        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
+    }
+    defaultMeta() {
+        return (this.opts.defaultMeta =
+            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
+    }
+}
+module.exports = exports = Ajv2020;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = Ajv2020;
+var validate_1 = require("./compile/validate");
+Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
+var codegen_1 = require("./compile/codegen");
+Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
+Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
+Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
+Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
+Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
+Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
+var validation_error_1 = require("./runtime/validation_error");
+Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
+var ref_error_1 = require("./compile/ref_error");
+Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
diff --git a/node_modules/ajv/dist/ajv.js b/node_modules/ajv/dist/ajv.js
index 755256a..cba0769 100644
--- a/node_modules/ajv/dist/ajv.js
+++ b/node_modules/ajv/dist/ajv.js
@@ -45,4 +45,3 @@ var validation_error_1 = require("./runtime/validation_error");
 Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
 var ref_error_1 = require("./compile/ref_error");
 Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
-//# sourceMappingURL=ajv.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/ajv.js.bak b/node_modules/ajv/dist/ajv.js.bak
new file mode 100644
index 0000000..cba0769
--- /dev/null
+++ b/node_modules/ajv/dist/ajv.js.bak
@@ -0,0 +1,47 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
+const core_1 = require("./core");
+const draft7_1 = require("./vocabularies/draft7");
+const discriminator_1 = require("./vocabularies/discriminator");
+const draft7MetaSchema = require("./refs/json-schema-draft-07.json");
+const META_SUPPORT_DATA = ["/properties"];
+const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
+class Ajv extends core_1.default {
+    _addVocabularies() {
+        super._addVocabularies();
+        draft7_1.default.forEach((v) => this.addVocabulary(v));
+        if (this.opts.discriminator)
+            this.addKeyword(discriminator_1.default);
+    }
+    _addDefaultMetaSchema() {
+        super._addDefaultMetaSchema();
+        if (!this.opts.meta)
+            return;
+        const metaSchema = this.opts.$data
+            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
+            : draft7MetaSchema;
+        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
+        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
+    }
+    defaultMeta() {
+        return (this.opts.defaultMeta =
+            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
+    }
+}
+module.exports = exports = Ajv;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = Ajv;
+var validate_1 = require("./compile/validate");
+Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
+var codegen_1 = require("./compile/codegen");
+Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
+Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
+Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
+Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
+Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
+Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
+var validation_error_1 = require("./runtime/validation_error");
+Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
+var ref_error_1 = require("./compile/ref_error");
+Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
diff --git a/node_modules/ajv/dist/compile/codegen/code.js b/node_modules/ajv/dist/compile/codegen/code.js
index f826883..85fd909 100644
--- a/node_modules/ajv/dist/compile/codegen/code.js
+++ b/node_modules/ajv/dist/compile/codegen/code.js
@@ -152,4 +152,3 @@ function regexpCode(rx) {
     return new _Code(rx.toString());
 }
 exports.regexpCode = regexpCode;
-//# sourceMappingURL=code.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/codegen/code.js.bak b/node_modules/ajv/dist/compile/codegen/code.js.bak
new file mode 100644
index 0000000..f826883
--- /dev/null
+++ b/node_modules/ajv/dist/compile/codegen/code.js.bak
@@ -0,0 +1,155 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
+class _CodeOrName {
+}
+exports._CodeOrName = _CodeOrName;
+exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
+class Name extends _CodeOrName {
+    constructor(s) {
+        super();
+        if (!exports.IDENTIFIER.test(s))
+            throw new Error("CodeGen: name must be a valid identifier");
+        this.str = s;
+    }
+    toString() {
+        return this.str;
+    }
+    emptyStr() {
+        return false;
+    }
+    get names() {
+        return { [this.str]: 1 };
+    }
+}
+exports.Name = Name;
+class _Code extends _CodeOrName {
+    constructor(code) {
+        super();
+        this._items = typeof code === "string" ? [code] : code;
+    }
+    toString() {
+        return this.str;
+    }
+    emptyStr() {
+        if (this._items.length > 1)
+            return false;
+        const item = this._items[0];
+        return item === "" || item === '""';
+    }
+    get str() {
+        var _a;
+        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
+    }
+    get names() {
+        var _a;
+        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
+            if (c instanceof Name)
+                names[c.str] = (names[c.str] || 0) + 1;
+            return names;
+        }, {})));
+    }
+}
+exports._Code = _Code;
+exports.nil = new _Code("");
+function _(strs, ...args) {
+    const code = [strs[0]];
+    let i = 0;
+    while (i < args.length) {
+        addCodeArg(code, args[i]);
+        code.push(strs[++i]);
+    }
+    return new _Code(code);
+}
+exports._ = _;
+const plus = new _Code("+");
+function str(strs, ...args) {
+    const expr = [safeStringify(strs[0])];
+    let i = 0;
+    while (i < args.length) {
+        expr.push(plus);
+        addCodeArg(expr, args[i]);
+        expr.push(plus, safeStringify(strs[++i]));
+    }
+    optimize(expr);
+    return new _Code(expr);
+}
+exports.str = str;
+function addCodeArg(code, arg) {
+    if (arg instanceof _Code)
+        code.push(...arg._items);
+    else if (arg instanceof Name)
+        code.push(arg);
+    else
+        code.push(interpolate(arg));
+}
+exports.addCodeArg = addCodeArg;
+function optimize(expr) {
+    let i = 1;
+    while (i < expr.length - 1) {
+        if (expr[i] === plus) {
+            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
+            if (res !== undefined) {
+                expr.splice(i - 1, 3, res);
+                continue;
+            }
+            expr[i++] = "+";
+        }
+        i++;
+    }
+}
+function mergeExprItems(a, b) {
+    if (b === '""')
+        return a;
+    if (a === '""')
+        return b;
+    if (typeof a == "string") {
+        if (b instanceof Name || a[a.length - 1] !== '"')
+            return;
+        if (typeof b != "string")
+            return `${a.slice(0, -1)}${b}"`;
+        if (b[0] === '"')
+            return a.slice(0, -1) + b.slice(1);
+        return;
+    }
+    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
+        return `"${a}${b.slice(1)}`;
+    return;
+}
+function strConcat(c1, c2) {
+    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
+}
+exports.strConcat = strConcat;
+// TODO do not allow arrays here
+function interpolate(x) {
+    return typeof x == "number" || typeof x == "boolean" || x === null
+        ? x
+        : safeStringify(Array.isArray(x) ? x.join(",") : x);
+}
+function stringify(x) {
+    return new _Code(safeStringify(x));
+}
+exports.stringify = stringify;
+function safeStringify(x) {
+    return JSON.stringify(x)
+        .replace(/\u2028/g, "\\u2028")
+        .replace(/\u2029/g, "\\u2029");
+}
+exports.safeStringify = safeStringify;
+function getProperty(key) {
+    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
+}
+exports.getProperty = getProperty;
+//Does best effort to format the name properly
+function getEsmExportName(key) {
+    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
+        return new _Code(`${key}`);
+    }
+    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
+}
+exports.getEsmExportName = getEsmExportName;
+function regexpCode(rx) {
+    return new _Code(rx.toString());
+}
+exports.regexpCode = regexpCode;
+//# sourceMappingURL=code.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/codegen/index.js b/node_modules/ajv/dist/compile/codegen/index.js
index a6c805a..3c31219 100644
--- a/node_modules/ajv/dist/compile/codegen/index.js
+++ b/node_modules/ajv/dist/compile/codegen/index.js
@@ -694,4 +694,3 @@ function mappend(op) {
 function par(x) {
     return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
 }
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/codegen/index.js.bak b/node_modules/ajv/dist/compile/codegen/index.js.bak
new file mode 100644
index 0000000..a6c805a
--- /dev/null
+++ b/node_modules/ajv/dist/compile/codegen/index.js.bak
@@ -0,0 +1,697 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
+const code_1 = require("./code");
+const scope_1 = require("./scope");
+var code_2 = require("./code");
+Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
+Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
+Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
+Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
+Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
+Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
+Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
+Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
+var scope_2 = require("./scope");
+Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
+Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
+Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
+Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
+exports.operators = {
+    GT: new code_1._Code(">"),
+    GTE: new code_1._Code(">="),
+    LT: new code_1._Code("<"),
+    LTE: new code_1._Code("<="),
+    EQ: new code_1._Code("==="),
+    NEQ: new code_1._Code("!=="),
+    NOT: new code_1._Code("!"),
+    OR: new code_1._Code("||"),
+    AND: new code_1._Code("&&"),
+    ADD: new code_1._Code("+"),
+};
+class Node {
+    optimizeNodes() {
+        return this;
+    }
+    optimizeNames(_names, _constants) {
+        return this;
+    }
+}
+class Def extends Node {
+    constructor(varKind, name, rhs) {
+        super();
+        this.varKind = varKind;
+        this.name = name;
+        this.rhs = rhs;
+    }
+    render({ es5, _n }) {
+        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
+        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
+        return `${varKind} ${this.name}${rhs};` + _n;
+    }
+    optimizeNames(names, constants) {
+        if (!names[this.name.str])
+            return;
+        if (this.rhs)
+            this.rhs = optimizeExpr(this.rhs, names, constants);
+        return this;
+    }
+    get names() {
+        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
+    }
+}
+class Assign extends Node {
+    constructor(lhs, rhs, sideEffects) {
+        super();
+        this.lhs = lhs;
+        this.rhs = rhs;
+        this.sideEffects = sideEffects;
+    }
+    render({ _n }) {
+        return `${this.lhs} = ${this.rhs};` + _n;
+    }
+    optimizeNames(names, constants) {
+        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
+            return;
+        this.rhs = optimizeExpr(this.rhs, names, constants);
+        return this;
+    }
+    get names() {
+        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
+        return addExprNames(names, this.rhs);
+    }
+}
+class AssignOp extends Assign {
+    constructor(lhs, op, rhs, sideEffects) {
+        super(lhs, rhs, sideEffects);
+        this.op = op;
+    }
+    render({ _n }) {
+        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
+    }
+}
+class Label extends Node {
+    constructor(label) {
+        super();
+        this.label = label;
+        this.names = {};
+    }
+    render({ _n }) {
+        return `${this.label}:` + _n;
+    }
+}
+class Break extends Node {
+    constructor(label) {
+        super();
+        this.label = label;
+        this.names = {};
+    }
+    render({ _n }) {
+        const label = this.label ? ` ${this.label}` : "";
+        return `break${label};` + _n;
+    }
+}
+class Throw extends Node {
+    constructor(error) {
+        super();
+        this.error = error;
+    }
+    render({ _n }) {
+        return `throw ${this.error};` + _n;
+    }
+    get names() {
+        return this.error.names;
+    }
+}
+class AnyCode extends Node {
+    constructor(code) {
+        super();
+        this.code = code;
+    }
+    render({ _n }) {
+        return `${this.code};` + _n;
+    }
+    optimizeNodes() {
+        return `${this.code}` ? this : undefined;
+    }
+    optimizeNames(names, constants) {
+        this.code = optimizeExpr(this.code, names, constants);
+        return this;
+    }
+    get names() {
+        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
+    }
+}
+class ParentNode extends Node {
+    constructor(nodes = []) {
+        super();
+        this.nodes = nodes;
+    }
+    render(opts) {
+        return this.nodes.reduce((code, n) => code + n.render(opts), "");
+    }
+    optimizeNodes() {
+        const { nodes } = this;
+        let i = nodes.length;
+        while (i--) {
+            const n = nodes[i].optimizeNodes();
+            if (Array.isArray(n))
+                nodes.splice(i, 1, ...n);
+            else if (n)
+                nodes[i] = n;
+            else
+                nodes.splice(i, 1);
+        }
+        return nodes.length > 0 ? this : undefined;
+    }
+    optimizeNames(names, constants) {
+        const { nodes } = this;
+        let i = nodes.length;
+        while (i--) {
+            // iterating backwards improves 1-pass optimization
+            const n = nodes[i];
+            if (n.optimizeNames(names, constants))
+                continue;
+            subtractNames(names, n.names);
+            nodes.splice(i, 1);
+        }
+        return nodes.length > 0 ? this : undefined;
+    }
+    get names() {
+        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
+    }
+}
+class BlockNode extends ParentNode {
+    render(opts) {
+        return "{" + opts._n + super.render(opts) + "}" + opts._n;
+    }
+}
+class Root extends ParentNode {
+}
+class Else extends BlockNode {
+}
+Else.kind = "else";
+class If extends BlockNode {
+    constructor(condition, nodes) {
+        super(nodes);
+        this.condition = condition;
+    }
+    render(opts) {
+        let code = `if(${this.condition})` + super.render(opts);
+        if (this.else)
+            code += "else " + this.else.render(opts);
+        return code;
+    }
+    optimizeNodes() {
+        super.optimizeNodes();
+        const cond = this.condition;
+        if (cond === true)
+            return this.nodes; // else is ignored here
+        let e = this.else;
+        if (e) {
+            const ns = e.optimizeNodes();
+            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
+        }
+        if (e) {
+            if (cond === false)
+                return e instanceof If ? e : e.nodes;
+            if (this.nodes.length)
+                return this;
+            return new If(not(cond), e instanceof If ? [e] : e.nodes);
+        }
+        if (cond === false || !this.nodes.length)
+            return undefined;
+        return this;
+    }
+    optimizeNames(names, constants) {
+        var _a;
+        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
+        if (!(super.optimizeNames(names, constants) || this.else))
+            return;
+        this.condition = optimizeExpr(this.condition, names, constants);
+        return this;
+    }
+    get names() {
+        const names = super.names;
+        addExprNames(names, this.condition);
+        if (this.else)
+            addNames(names, this.else.names);
+        return names;
+    }
+}
+If.kind = "if";
+class For extends BlockNode {
+}
+For.kind = "for";
+class ForLoop extends For {
+    constructor(iteration) {
+        super();
+        this.iteration = iteration;
+    }
+    render(opts) {
+        return `for(${this.iteration})` + super.render(opts);
+    }
+    optimizeNames(names, constants) {
+        if (!super.optimizeNames(names, constants))
+            return;
+        this.iteration = optimizeExpr(this.iteration, names, constants);
+        return this;
+    }
+    get names() {
+        return addNames(super.names, this.iteration.names);
+    }
+}
+class ForRange extends For {
+    constructor(varKind, name, from, to) {
+        super();
+        this.varKind = varKind;
+        this.name = name;
+        this.from = from;
+        this.to = to;
+    }
+    render(opts) {
+        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
+        const { name, from, to } = this;
+        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
+    }
+    get names() {
+        const names = addExprNames(super.names, this.from);
+        return addExprNames(names, this.to);
+    }
+}
+class ForIter extends For {
+    constructor(loop, varKind, name, iterable) {
+        super();
+        this.loop = loop;
+        this.varKind = varKind;
+        this.name = name;
+        this.iterable = iterable;
+    }
+    render(opts) {
+        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
+    }
+    optimizeNames(names, constants) {
+        if (!super.optimizeNames(names, constants))
+            return;
+        this.iterable = optimizeExpr(this.iterable, names, constants);
+        return this;
+    }
+    get names() {
+        return addNames(super.names, this.iterable.names);
+    }
+}
+class Func extends BlockNode {
+    constructor(name, args, async) {
+        super();
+        this.name = name;
+        this.args = args;
+        this.async = async;
+    }
+    render(opts) {
+        const _async = this.async ? "async " : "";
+        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
+    }
+}
+Func.kind = "func";
+class Return extends ParentNode {
+    render(opts) {
+        return "return " + super.render(opts);
+    }
+}
+Return.kind = "return";
+class Try extends BlockNode {
+    render(opts) {
+        let code = "try" + super.render(opts);
+        if (this.catch)
+            code += this.catch.render(opts);
+        if (this.finally)
+            code += this.finally.render(opts);
+        return code;
+    }
+    optimizeNodes() {
+        var _a, _b;
+        super.optimizeNodes();
+        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
+        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
+        return this;
+    }
+    optimizeNames(names, constants) {
+        var _a, _b;
+        super.optimizeNames(names, constants);
+        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
+        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
+        return this;
+    }
+    get names() {
+        const names = super.names;
+        if (this.catch)
+            addNames(names, this.catch.names);
+        if (this.finally)
+            addNames(names, this.finally.names);
+        return names;
+    }
+}
+class Catch extends BlockNode {
+    constructor(error) {
+        super();
+        this.error = error;
+    }
+    render(opts) {
+        return `catch(${this.error})` + super.render(opts);
+    }
+}
+Catch.kind = "catch";
+class Finally extends BlockNode {
+    render(opts) {
+        return "finally" + super.render(opts);
+    }
+}
+Finally.kind = "finally";
+class CodeGen {
+    constructor(extScope, opts = {}) {
+        this._values = {};
+        this._blockStarts = [];
+        this._constants = {};
+        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
+        this._extScope = extScope;
+        this._scope = new scope_1.Scope({ parent: extScope });
+        this._nodes = [new Root()];
+    }
+    toString() {
+        return this._root.render(this.opts);
+    }
+    // returns unique name in the internal scope
+    name(prefix) {
+        return this._scope.name(prefix);
+    }
+    // reserves unique name in the external scope
+    scopeName(prefix) {
+        return this._extScope.name(prefix);
+    }
+    // reserves unique name in the external scope and assigns value to it
+    scopeValue(prefixOrName, value) {
+        const name = this._extScope.value(prefixOrName, value);
+        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
+        vs.add(name);
+        return name;
+    }
+    getScopeValue(prefix, keyOrRef) {
+        return this._extScope.getValue(prefix, keyOrRef);
+    }
+    // return code that assigns values in the external scope to the names that are used internally
+    // (same names that were returned by gen.scopeName or gen.scopeValue)
+    scopeRefs(scopeName) {
+        return this._extScope.scopeRefs(scopeName, this._values);
+    }
+    scopeCode() {
+        return this._extScope.scopeCode(this._values);
+    }
+    _def(varKind, nameOrPrefix, rhs, constant) {
+        const name = this._scope.toName(nameOrPrefix);
+        if (rhs !== undefined && constant)
+            this._constants[name.str] = rhs;
+        this._leafNode(new Def(varKind, name, rhs));
+        return name;
+    }
+    // `const` declaration (`var` in es5 mode)
+    const(nameOrPrefix, rhs, _constant) {
+        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
+    }
+    // `let` declaration with optional assignment (`var` in es5 mode)
+    let(nameOrPrefix, rhs, _constant) {
+        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
+    }
+    // `var` declaration with optional assignment
+    var(nameOrPrefix, rhs, _constant) {
+        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
+    }
+    // assignment code
+    assign(lhs, rhs, sideEffects) {
+        return this._leafNode(new Assign(lhs, rhs, sideEffects));
+    }
+    // `+=` code
+    add(lhs, rhs) {
+        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
+    }
+    // appends passed SafeExpr to code or executes Block
+    code(c) {
+        if (typeof c == "function")
+            c();
+        else if (c !== code_1.nil)
+            this._leafNode(new AnyCode(c));
+        return this;
+    }
+    // returns code for object literal for the passed argument list of key-value pairs
+    object(...keyValues) {
+        const code = ["{"];
+        for (const [key, value] of keyValues) {
+            if (code.length > 1)
+                code.push(",");
+            code.push(key);
+            if (key !== value || this.opts.es5) {
+                code.push(":");
+                (0, code_1.addCodeArg)(code, value);
+            }
+        }
+        code.push("}");
+        return new code_1._Code(code);
+    }
+    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
+    if(condition, thenBody, elseBody) {
+        this._blockNode(new If(condition));
+        if (thenBody && elseBody) {
+            this.code(thenBody).else().code(elseBody).endIf();
+        }
+        else if (thenBody) {
+            this.code(thenBody).endIf();
+        }
+        else if (elseBody) {
+            throw new Error('CodeGen: "else" body without "then" body');
+        }
+        return this;
+    }
+    // `else if` clause - invalid without `if` or after `else` clauses
+    elseIf(condition) {
+        return this._elseNode(new If(condition));
+    }
+    // `else` clause - only valid after `if` or `else if` clauses
+    else() {
+        return this._elseNode(new Else());
+    }
+    // end `if` statement (needed if gen.if was used only with condition)
+    endIf() {
+        return this._endBlockNode(If, Else);
+    }
+    _for(node, forBody) {
+        this._blockNode(node);
+        if (forBody)
+            this.code(forBody).endFor();
+        return this;
+    }
+    // a generic `for` clause (or statement if `forBody` is passed)
+    for(iteration, forBody) {
+        return this._for(new ForLoop(iteration), forBody);
+    }
+    // `for` statement for a range of values
+    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
+        const name = this._scope.toName(nameOrPrefix);
+        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
+    }
+    // `for-of` statement (in es5 mode replace with a normal for loop)
+    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
+        const name = this._scope.toName(nameOrPrefix);
+        if (this.opts.es5) {
+            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
+            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
+                this.var(name, (0, code_1._) `${arr}[${i}]`);
+                forBody(name);
+            });
+        }
+        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
+    }
+    // `for-in` statement.
+    // With option `ownProperties` replaced with a `for-of` loop for object keys
+    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
+        if (this.opts.ownProperties) {
+            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
+        }
+        const name = this._scope.toName(nameOrPrefix);
+        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
+    }
+    // end `for` loop
+    endFor() {
+        return this._endBlockNode(For);
+    }
+    // `label` statement
+    label(label) {
+        return this._leafNode(new Label(label));
+    }
+    // `break` statement
+    break(label) {
+        return this._leafNode(new Break(label));
+    }
+    // `return` statement
+    return(value) {
+        const node = new Return();
+        this._blockNode(node);
+        this.code(value);
+        if (node.nodes.length !== 1)
+            throw new Error('CodeGen: "return" should have one node');
+        return this._endBlockNode(Return);
+    }
+    // `try` statement
+    try(tryBody, catchCode, finallyCode) {
+        if (!catchCode && !finallyCode)
+            throw new Error('CodeGen: "try" without "catch" and "finally"');
+        const node = new Try();
+        this._blockNode(node);
+        this.code(tryBody);
+        if (catchCode) {
+            const error = this.name("e");
+            this._currNode = node.catch = new Catch(error);
+            catchCode(error);
+        }
+        if (finallyCode) {
+            this._currNode = node.finally = new Finally();
+            this.code(finallyCode);
+        }
+        return this._endBlockNode(Catch, Finally);
+    }
+    // `throw` statement
+    throw(error) {
+        return this._leafNode(new Throw(error));
+    }
+    // start self-balancing block
+    block(body, nodeCount) {
+        this._blockStarts.push(this._nodes.length);
+        if (body)
+            this.code(body).endBlock(nodeCount);
+        return this;
+    }
+    // end the current self-balancing block
+    endBlock(nodeCount) {
+        const len = this._blockStarts.pop();
+        if (len === undefined)
+            throw new Error("CodeGen: not in self-balancing block");
+        const toClose = this._nodes.length - len;
+        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
+            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
+        }
+        this._nodes.length = len;
+        return this;
+    }
+    // `function` heading (or definition if funcBody is passed)
+    func(name, args = code_1.nil, async, funcBody) {
+        this._blockNode(new Func(name, args, async));
+        if (funcBody)
+            this.code(funcBody).endFunc();
+        return this;
+    }
+    // end function definition
+    endFunc() {
+        return this._endBlockNode(Func);
+    }
+    optimize(n = 1) {
+        while (n-- > 0) {
+            this._root.optimizeNodes();
+            this._root.optimizeNames(this._root.names, this._constants);
+        }
+    }
+    _leafNode(node) {
+        this._currNode.nodes.push(node);
+        return this;
+    }
+    _blockNode(node) {
+        this._currNode.nodes.push(node);
+        this._nodes.push(node);
+    }
+    _endBlockNode(N1, N2) {
+        const n = this._currNode;
+        if (n instanceof N1 || (N2 && n instanceof N2)) {
+            this._nodes.pop();
+            return this;
+        }
+        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
+    }
+    _elseNode(node) {
+        const n = this._currNode;
+        if (!(n instanceof If)) {
+            throw new Error('CodeGen: "else" without "if"');
+        }
+        this._currNode = n.else = node;
+        return this;
+    }
+    get _root() {
+        return this._nodes[0];
+    }
+    get _currNode() {
+        const ns = this._nodes;
+        return ns[ns.length - 1];
+    }
+    set _currNode(node) {
+        const ns = this._nodes;
+        ns[ns.length - 1] = node;
+    }
+}
+exports.CodeGen = CodeGen;
+function addNames(names, from) {
+    for (const n in from)
+        names[n] = (names[n] || 0) + (from[n] || 0);
+    return names;
+}
+function addExprNames(names, from) {
+    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
+}
+function optimizeExpr(expr, names, constants) {
+    if (expr instanceof code_1.Name)
+        return replaceName(expr);
+    if (!canOptimize(expr))
+        return expr;
+    return new code_1._Code(expr._items.reduce((items, c) => {
+        if (c instanceof code_1.Name)
+            c = replaceName(c);
+        if (c instanceof code_1._Code)
+            items.push(...c._items);
+        else
+            items.push(c);
+        return items;
+    }, []));
+    function replaceName(n) {
+        const c = constants[n.str];
+        if (c === undefined || names[n.str] !== 1)
+            return n;
+        delete names[n.str];
+        return c;
+    }
+    function canOptimize(e) {
+        return (e instanceof code_1._Code &&
+            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
+    }
+}
+function subtractNames(names, from) {
+    for (const n in from)
+        names[n] = (names[n] || 0) - (from[n] || 0);
+}
+function not(x) {
+    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
+}
+exports.not = not;
+const andCode = mappend(exports.operators.AND);
+// boolean AND (&&) expression with the passed arguments
+function and(...args) {
+    return args.reduce(andCode);
+}
+exports.and = and;
+const orCode = mappend(exports.operators.OR);
+// boolean OR (||) expression with the passed arguments
+function or(...args) {
+    return args.reduce(orCode);
+}
+exports.or = or;
+function mappend(op) {
+    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
+}
+function par(x) {
+    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
+}
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/codegen/scope.js b/node_modules/ajv/dist/compile/codegen/scope.js
index acc5f76..58bb967 100644
--- a/node_modules/ajv/dist/compile/codegen/scope.js
+++ b/node_modules/ajv/dist/compile/codegen/scope.js
@@ -140,4 +140,3 @@ class ValueScope extends Scope {
     }
 }
 exports.ValueScope = ValueScope;
-//# sourceMappingURL=scope.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/codegen/scope.js.bak b/node_modules/ajv/dist/compile/codegen/scope.js.bak
new file mode 100644
index 0000000..acc5f76
--- /dev/null
+++ b/node_modules/ajv/dist/compile/codegen/scope.js.bak
@@ -0,0 +1,143 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
+const code_1 = require("./code");
+class ValueError extends Error {
+    constructor(name) {
+        super(`CodeGen: "code" for ${name} not defined`);
+        this.value = name.value;
+    }
+}
+var UsedValueState;
+(function (UsedValueState) {
+    UsedValueState[UsedValueState["Started"] = 0] = "Started";
+    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
+})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
+exports.varKinds = {
+    const: new code_1.Name("const"),
+    let: new code_1.Name("let"),
+    var: new code_1.Name("var"),
+};
+class Scope {
+    constructor({ prefixes, parent } = {}) {
+        this._names = {};
+        this._prefixes = prefixes;
+        this._parent = parent;
+    }
+    toName(nameOrPrefix) {
+        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
+    }
+    name(prefix) {
+        return new code_1.Name(this._newName(prefix));
+    }
+    _newName(prefix) {
+        const ng = this._names[prefix] || this._nameGroup(prefix);
+        return `${prefix}${ng.index++}`;
+    }
+    _nameGroup(prefix) {
+        var _a, _b;
+        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
+            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
+        }
+        return (this._names[prefix] = { prefix, index: 0 });
+    }
+}
+exports.Scope = Scope;
+class ValueScopeName extends code_1.Name {
+    constructor(prefix, nameStr) {
+        super(nameStr);
+        this.prefix = prefix;
+    }
+    setValue(value, { property, itemIndex }) {
+        this.value = value;
+        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
+    }
+}
+exports.ValueScopeName = ValueScopeName;
+const line = (0, code_1._) `\n`;
+class ValueScope extends Scope {
+    constructor(opts) {
+        super(opts);
+        this._values = {};
+        this._scope = opts.scope;
+        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
+    }
+    get() {
+        return this._scope;
+    }
+    name(prefix) {
+        return new ValueScopeName(prefix, this._newName(prefix));
+    }
+    value(nameOrPrefix, value) {
+        var _a;
+        if (value.ref === undefined)
+            throw new Error("CodeGen: ref must be passed in value");
+        const name = this.toName(nameOrPrefix);
+        const { prefix } = name;
+        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
+        let vs = this._values[prefix];
+        if (vs) {
+            const _name = vs.get(valueKey);
+            if (_name)
+                return _name;
+        }
+        else {
+            vs = this._values[prefix] = new Map();
+        }
+        vs.set(valueKey, name);
+        const s = this._scope[prefix] || (this._scope[prefix] = []);
+        const itemIndex = s.length;
+        s[itemIndex] = value.ref;
+        name.setValue(value, { property: prefix, itemIndex });
+        return name;
+    }
+    getValue(prefix, keyOrRef) {
+        const vs = this._values[prefix];
+        if (!vs)
+            return;
+        return vs.get(keyOrRef);
+    }
+    scopeRefs(scopeName, values = this._values) {
+        return this._reduceValues(values, (name) => {
+            if (name.scopePath === undefined)
+                throw new Error(`CodeGen: name "${name}" has no value`);
+            return (0, code_1._) `${scopeName}${name.scopePath}`;
+        });
+    }
+    scopeCode(values = this._values, usedValues, getCode) {
+        return this._reduceValues(values, (name) => {
+            if (name.value === undefined)
+                throw new Error(`CodeGen: name "${name}" has no value`);
+            return name.value.code;
+        }, usedValues, getCode);
+    }
+    _reduceValues(values, valueCode, usedValues = {}, getCode) {
+        let code = code_1.nil;
+        for (const prefix in values) {
+            const vs = values[prefix];
+            if (!vs)
+                continue;
+            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
+            vs.forEach((name) => {
+                if (nameSet.has(name))
+                    return;
+                nameSet.set(name, UsedValueState.Started);
+                let c = valueCode(name);
+                if (c) {
+                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
+                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
+                }
+                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
+                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
+                }
+                else {
+                    throw new ValueError(name);
+                }
+                nameSet.set(name, UsedValueState.Completed);
+            });
+        }
+        return code;
+    }
+}
+exports.ValueScope = ValueScope;
+//# sourceMappingURL=scope.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/errors.js b/node_modules/ajv/dist/compile/errors.js
index e2aca7b..e2f86ae 100644
--- a/node_modules/ajv/dist/compile/errors.js
+++ b/node_modules/ajv/dist/compile/errors.js
@@ -120,4 +120,3 @@ function extraErrorProps(cxt, { params, message }, keyValues) {
     if (propertyName)
         keyValues.push([E.propertyName, propertyName]);
 }
-//# sourceMappingURL=errors.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/errors.js.bak b/node_modules/ajv/dist/compile/errors.js.bak
new file mode 100644
index 0000000..e2aca7b
--- /dev/null
+++ b/node_modules/ajv/dist/compile/errors.js.bak
@@ -0,0 +1,123 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
+const codegen_1 = require("./codegen");
+const util_1 = require("./util");
+const names_1 = require("./names");
+exports.keywordError = {
+    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
+};
+exports.keyword$DataError = {
+    message: ({ keyword, schemaType }) => schemaType
+        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
+        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
+};
+function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
+    const { it } = cxt;
+    const { gen, compositeRule, allErrors } = it;
+    const errObj = errorObjectCode(cxt, error, errorPaths);
+    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
+        addError(gen, errObj);
+    }
+    else {
+        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
+    }
+}
+exports.reportError = reportError;
+function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
+    const { it } = cxt;
+    const { gen, compositeRule, allErrors } = it;
+    const errObj = errorObjectCode(cxt, error, errorPaths);
+    addError(gen, errObj);
+    if (!(compositeRule || allErrors)) {
+        returnErrors(it, names_1.default.vErrors);
+    }
+}
+exports.reportExtraError = reportExtraError;
+function resetErrorsCount(gen, errsCount) {
+    gen.assign(names_1.default.errors, errsCount);
+    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
+}
+exports.resetErrorsCount = resetErrorsCount;
+function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
+    /* istanbul ignore if */
+    if (errsCount === undefined)
+        throw new Error("ajv implementation error");
+    const err = gen.name("err");
+    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
+        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
+        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
+        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
+        if (it.opts.verbose) {
+            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
+            gen.assign((0, codegen_1._) `${err}.data`, data);
+        }
+    });
+}
+exports.extendErrors = extendErrors;
+function addError(gen, errObj) {
+    const err = gen.const("err", errObj);
+    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
+    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
+}
+function returnErrors(it, errs) {
+    const { gen, validateName, schemaEnv } = it;
+    if (schemaEnv.$async) {
+        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
+    }
+    else {
+        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
+        gen.return(false);
+    }
+}
+const E = {
+    keyword: new codegen_1.Name("keyword"),
+    schemaPath: new codegen_1.Name("schemaPath"),
+    params: new codegen_1.Name("params"),
+    propertyName: new codegen_1.Name("propertyName"),
+    message: new codegen_1.Name("message"),
+    schema: new codegen_1.Name("schema"),
+    parentSchema: new codegen_1.Name("parentSchema"),
+};
+function errorObjectCode(cxt, error, errorPaths) {
+    const { createErrors } = cxt.it;
+    if (createErrors === false)
+        return (0, codegen_1._) `{}`;
+    return errorObject(cxt, error, errorPaths);
+}
+function errorObject(cxt, error, errorPaths = {}) {
+    const { gen, it } = cxt;
+    const keyValues = [
+        errorInstancePath(it, errorPaths),
+        errorSchemaPath(cxt, errorPaths),
+    ];
+    extraErrorProps(cxt, error, keyValues);
+    return gen.object(...keyValues);
+}
+function errorInstancePath({ errorPath }, { instancePath }) {
+    const instPath = instancePath
+        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
+        : errorPath;
+    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
+}
+function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
+    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
+    if (schemaPath) {
+        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
+    }
+    return [E.schemaPath, schPath];
+}
+function extraErrorProps(cxt, { params, message }, keyValues) {
+    const { keyword, data, schemaValue, it } = cxt;
+    const { opts, propertyName, topSchemaRef, schemaPath } = it;
+    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
+    if (opts.messages) {
+        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
+    }
+    if (opts.verbose) {
+        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
+    }
+    if (propertyName)
+        keyValues.push([E.propertyName, propertyName]);
+}
+//# sourceMappingURL=errors.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/index.js b/node_modules/ajv/dist/compile/index.js
index b125ecd..b775768 100644
--- a/node_modules/ajv/dist/compile/index.js
+++ b/node_modules/ajv/dist/compile/index.js
@@ -239,4 +239,3 @@ function getJsonPointer(parsedRef, { baseId, schema, root }) {
         return env;
     return undefined;
 }
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/index.js.bak b/node_modules/ajv/dist/compile/index.js.bak
new file mode 100644
index 0000000..b125ecd
--- /dev/null
+++ b/node_modules/ajv/dist/compile/index.js.bak
@@ -0,0 +1,242 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
+const codegen_1 = require("./codegen");
+const validation_error_1 = require("../runtime/validation_error");
+const names_1 = require("./names");
+const resolve_1 = require("./resolve");
+const util_1 = require("./util");
+const validate_1 = require("./validate");
+class SchemaEnv {
+    constructor(env) {
+        var _a;
+        this.refs = {};
+        this.dynamicAnchors = {};
+        let schema;
+        if (typeof env.schema == "object")
+            schema = env.schema;
+        this.schema = env.schema;
+        this.schemaId = env.schemaId;
+        this.root = env.root || this;
+        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
+        this.schemaPath = env.schemaPath;
+        this.localRefs = env.localRefs;
+        this.meta = env.meta;
+        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
+        this.refs = {};
+    }
+}
+exports.SchemaEnv = SchemaEnv;
+// let codeSize = 0
+// let nodeCount = 0
+// Compiles schema in SchemaEnv
+function compileSchema(sch) {
+    // TODO refactor - remove compilations
+    const _sch = getCompilingSchema.call(this, sch);
+    if (_sch)
+        return _sch;
+    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
+    const { es5, lines } = this.opts.code;
+    const { ownProperties } = this.opts;
+    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
+    let _ValidationError;
+    if (sch.$async) {
+        _ValidationError = gen.scopeValue("Error", {
+            ref: validation_error_1.default,
+            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
+        });
+    }
+    const validateName = gen.scopeName("validate");
+    sch.validateName = validateName;
+    const schemaCxt = {
+        gen,
+        allErrors: this.opts.allErrors,
+        data: names_1.default.data,
+        parentData: names_1.default.parentData,
+        parentDataProperty: names_1.default.parentDataProperty,
+        dataNames: [names_1.default.data],
+        dataPathArr: [codegen_1.nil],
+        dataLevel: 0,
+        dataTypes: [],
+        definedProperties: new Set(),
+        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
+            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
+            : { ref: sch.schema }),
+        validateName,
+        ValidationError: _ValidationError,
+        schema: sch.schema,
+        schemaEnv: sch,
+        rootId,
+        baseId: sch.baseId || rootId,
+        schemaPath: codegen_1.nil,
+        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
+        errorPath: (0, codegen_1._) `""`,
+        opts: this.opts,
+        self: this,
+    };
+    let sourceCode;
+    try {
+        this._compilations.add(sch);
+        (0, validate_1.validateFunctionCode)(schemaCxt);
+        gen.optimize(this.opts.code.optimize);
+        // gen.optimize(1)
+        const validateCode = gen.toString();
+        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
+        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
+        if (this.opts.code.process)
+            sourceCode = this.opts.code.process(sourceCode, sch);
+        // console.log("\n\n\n *** \n", sourceCode)
+        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
+        const validate = makeValidate(this, this.scope.get());
+        this.scope.value(validateName, { ref: validate });
+        validate.errors = null;
+        validate.schema = sch.schema;
+        validate.schemaEnv = sch;
+        if (sch.$async)
+            validate.$async = true;
+        if (this.opts.code.source === true) {
+            validate.source = { validateName, validateCode, scopeValues: gen._values };
+        }
+        if (this.opts.unevaluated) {
+            const { props, items } = schemaCxt;
+            validate.evaluated = {
+                props: props instanceof codegen_1.Name ? undefined : props,
+                items: items instanceof codegen_1.Name ? undefined : items,
+                dynamicProps: props instanceof codegen_1.Name,
+                dynamicItems: items instanceof codegen_1.Name,
+            };
+            if (validate.source)
+                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
+        }
+        sch.validate = validate;
+        return sch;
+    }
+    catch (e) {
+        delete sch.validate;
+        delete sch.validateName;
+        if (sourceCode)
+            this.logger.error("Error compiling schema, function code:", sourceCode);
+        // console.log("\n\n\n *** \n", sourceCode, this.opts)
+        throw e;
+    }
+    finally {
+        this._compilations.delete(sch);
+    }
+}
+exports.compileSchema = compileSchema;
+function resolveRef(root, baseId, ref) {
+    var _a;
+    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
+    const schOrFunc = root.refs[ref];
+    if (schOrFunc)
+        return schOrFunc;
+    let _sch = resolve.call(this, root, ref);
+    if (_sch === undefined) {
+        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
+        const { schemaId } = this.opts;
+        if (schema)
+            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
+    }
+    if (_sch === undefined)
+        return;
+    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
+}
+exports.resolveRef = resolveRef;
+function inlineOrCompile(sch) {
+    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
+        return sch.schema;
+    return sch.validate ? sch : compileSchema.call(this, sch);
+}
+// Index of schema compilation in the currently compiled list
+function getCompilingSchema(schEnv) {
+    for (const sch of this._compilations) {
+        if (sameSchemaEnv(sch, schEnv))
+            return sch;
+    }
+}
+exports.getCompilingSchema = getCompilingSchema;
+function sameSchemaEnv(s1, s2) {
+    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
+}
+// resolve and compile the references ($ref)
+// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
+function resolve(root, // information about the root schema for the current schema
+ref // reference to resolve
+) {
+    let sch;
+    while (typeof (sch = this.refs[ref]) == "string")
+        ref = sch;
+    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
+}
+// Resolve schema, its root and baseId
+function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
+ref // reference to resolve
+) {
+    const p = this.opts.uriResolver.parse(ref);
+    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
+    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
+    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
+    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
+        return getJsonPointer.call(this, p, root);
+    }
+    const id = (0, resolve_1.normalizeId)(refPath);
+    const schOrRef = this.refs[id] || this.schemas[id];
+    if (typeof schOrRef == "string") {
+        const sch = resolveSchema.call(this, root, schOrRef);
+        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
+            return;
+        return getJsonPointer.call(this, p, sch);
+    }
+    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
+        return;
+    if (!schOrRef.validate)
+        compileSchema.call(this, schOrRef);
+    if (id === (0, resolve_1.normalizeId)(ref)) {
+        const { schema } = schOrRef;
+        const { schemaId } = this.opts;
+        const schId = schema[schemaId];
+        if (schId)
+            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
+        return new SchemaEnv({ schema, schemaId, root, baseId });
+    }
+    return getJsonPointer.call(this, p, schOrRef);
+}
+exports.resolveSchema = resolveSchema;
+const PREVENT_SCOPE_CHANGE = new Set([
+    "properties",
+    "patternProperties",
+    "enum",
+    "dependencies",
+    "definitions",
+]);
+function getJsonPointer(parsedRef, { baseId, schema, root }) {
+    var _a;
+    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
+        return;
+    for (const part of parsedRef.fragment.slice(1).split("/")) {
+        if (typeof schema === "boolean")
+            return;
+        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
+        if (partSchema === undefined)
+            return;
+        schema = partSchema;
+        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
+        const schId = typeof schema === "object" && schema[this.opts.schemaId];
+        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
+            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
+        }
+    }
+    let env;
+    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
+        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
+        env = resolveSchema.call(this, root, $ref);
+    }
+    // even though resolution failed we need to return SchemaEnv to throw exception
+    // so that compileAsync loads missing schema.
+    const { schemaId } = this.opts;
+    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
+    if (env.schema !== env.root.schema)
+        return env;
+    return undefined;
+}
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/jtd/parse.js b/node_modules/ajv/dist/compile/jtd/parse.js
index 8fc94fd..66da3dd 100644
--- a/node_modules/ajv/dist/compile/jtd/parse.js
+++ b/node_modules/ajv/dist/compile/jtd/parse.js
@@ -347,4 +347,3 @@ function parsingError({ gen, parseName }, msg) {
     gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
     gen.return(undef);
 }
-//# sourceMappingURL=parse.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/jtd/parse.js.bak b/node_modules/ajv/dist/compile/jtd/parse.js.bak
new file mode 100644
index 0000000..8fc94fd
--- /dev/null
+++ b/node_modules/ajv/dist/compile/jtd/parse.js.bak
@@ -0,0 +1,350 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const types_1 = require("./types");
+const __1 = require("..");
+const codegen_1 = require("../codegen");
+const ref_error_1 = require("../ref_error");
+const names_1 = require("../names");
+const code_1 = require("../../vocabularies/code");
+const ref_1 = require("../../vocabularies/jtd/ref");
+const type_1 = require("../../vocabularies/jtd/type");
+const parseJson_1 = require("../../runtime/parseJson");
+const util_1 = require("../util");
+const timestamp_1 = require("../../runtime/timestamp");
+const genParse = {
+    elements: parseElements,
+    values: parseValues,
+    discriminator: parseDiscriminator,
+    properties: parseProperties,
+    optionalProperties: parseProperties,
+    enum: parseEnum,
+    type: parseType,
+    ref: parseRef,
+};
+function compileParser(sch, definitions) {
+    const _sch = __1.getCompilingSchema.call(this, sch);
+    if (_sch)
+        return _sch;
+    const { es5, lines } = this.opts.code;
+    const { ownProperties } = this.opts;
+    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
+    const parseName = gen.scopeName("parse");
+    const cxt = {
+        self: this,
+        gen,
+        schema: sch.schema,
+        schemaEnv: sch,
+        definitions,
+        data: names_1.default.data,
+        parseName,
+        char: gen.name("c"),
+    };
+    let sourceCode;
+    try {
+        this._compilations.add(sch);
+        sch.parseName = parseName;
+        parserFunction(cxt);
+        gen.optimize(this.opts.code.optimize);
+        const parseFuncCode = gen.toString();
+        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
+        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
+        const parse = makeParse(this.scope.get());
+        this.scope.value(parseName, { ref: parse });
+        sch.parse = parse;
+    }
+    catch (e) {
+        if (sourceCode)
+            this.logger.error("Error compiling parser, function code:", sourceCode);
+        delete sch.parse;
+        delete sch.parseName;
+        throw e;
+    }
+    finally {
+        this._compilations.delete(sch);
+    }
+    return sch;
+}
+exports.default = compileParser;
+const undef = (0, codegen_1._) `undefined`;
+function parserFunction(cxt) {
+    const { gen, parseName, char } = cxt;
+    gen.func(parseName, (0, codegen_1._) `${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
+        gen.let(names_1.default.data);
+        gen.let(char);
+        gen.assign((0, codegen_1._) `${parseName}.message`, undef);
+        gen.assign((0, codegen_1._) `${parseName}.position`, undef);
+        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos} || 0`);
+        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json}.length`);
+        parseCode(cxt);
+        skipWhitespace(cxt);
+        gen.if(names_1.default.jsonPart, () => {
+            gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
+            gen.return(names_1.default.data);
+        });
+        gen.if((0, codegen_1._) `${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
+        jsonSyntaxError(cxt);
+    });
+}
+function parseCode(cxt) {
+    let form;
+    for (const key of types_1.jtdForms) {
+        if (key in cxt.schema) {
+            form = key;
+            break;
+        }
+    }
+    if (form)
+        parseNullable(cxt, genParse[form]);
+    else
+        parseEmpty(cxt);
+}
+const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
+function parseNullable(cxt, parseForm) {
+    const { gen, schema, data } = cxt;
+    if (!schema.nullable)
+        return parseForm(cxt);
+    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
+}
+function parseElements(cxt) {
+    const { gen, schema, data } = cxt;
+    parseToken(cxt, "[");
+    const ix = gen.let("i", 0);
+    gen.assign(data, (0, codegen_1._) `[]`);
+    parseItems(cxt, "]", () => {
+        const el = gen.let("el");
+        parseCode({ ...cxt, schema: schema.elements, data: el });
+        gen.assign((0, codegen_1._) `${data}[${ix}++]`, el);
+    });
+}
+function parseValues(cxt) {
+    const { gen, schema, data } = cxt;
+    parseToken(cxt, "{");
+    gen.assign(data, (0, codegen_1._) `{}`);
+    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
+}
+function parseItems(cxt, endToken, block) {
+    tryParseItems(cxt, endToken, block);
+    parseToken(cxt, endToken);
+}
+function tryParseItems(cxt, endToken, block) {
+    const { gen } = cxt;
+    gen.for((0, codegen_1._) `;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
+        block();
+        tryParseToken(cxt, ",", () => gen.break(), hasItem);
+    });
+    function hasItem() {
+        tryParseToken(cxt, endToken, () => { }, jsonSyntaxError);
+    }
+}
+function parseKeyValue(cxt, schema) {
+    const { gen } = cxt;
+    const key = gen.let("key");
+    parseString({ ...cxt, data: key });
+    parseToken(cxt, ":");
+    parsePropertyValue(cxt, key, schema);
+}
+function parseDiscriminator(cxt) {
+    const { gen, data, schema } = cxt;
+    const { discriminator, mapping } = schema;
+    parseToken(cxt, "{");
+    gen.assign(data, (0, codegen_1._) `{}`);
+    const startPos = gen.const("pos", names_1.default.jsonPos);
+    const value = gen.let("value");
+    const tag = gen.let("tag");
+    tryParseItems(cxt, "}", () => {
+        const key = gen.let("key");
+        parseString({ ...cxt, data: key });
+        parseToken(cxt, ":");
+        gen.if((0, codegen_1._) `${key} === ${discriminator}`, () => {
+            parseString({ ...cxt, data: tag });
+            gen.assign((0, codegen_1._) `${data}[${key}]`, tag);
+            gen.break();
+        }, () => parseEmpty({ ...cxt, data: value }) // can be discarded/skipped
+        );
+    });
+    gen.assign(names_1.default.jsonPos, startPos);
+    gen.if((0, codegen_1._) `${tag} === undefined`);
+    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);
+    for (const tagValue in mapping) {
+        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
+        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
+    }
+    gen.else();
+    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);
+    gen.endIf();
+}
+function parseProperties(cxt) {
+    const { gen, data } = cxt;
+    parseToken(cxt, "{");
+    gen.assign(data, (0, codegen_1._) `{}`);
+    parseSchemaProperties(cxt);
+}
+function parseSchemaProperties(cxt, discriminator) {
+    const { gen, schema, data } = cxt;
+    const { properties, optionalProperties, additionalProperties } = schema;
+    parseItems(cxt, "}", () => {
+        const key = gen.let("key");
+        parseString({ ...cxt, data: key });
+        parseToken(cxt, ":");
+        gen.if(false);
+        parseDefinedProperty(cxt, key, properties);
+        parseDefinedProperty(cxt, key, optionalProperties);
+        if (discriminator) {
+            gen.elseIf((0, codegen_1._) `${key} === ${discriminator}`);
+            const tag = gen.let("tag");
+            parseString({ ...cxt, data: tag }); // can be discarded, it is already assigned
+        }
+        gen.else();
+        if (additionalProperties) {
+            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data}[${key}]` });
+        }
+        else {
+            parsingError(cxt, (0, codegen_1.str) `property ${key} not allowed`);
+        }
+        gen.endIf();
+    });
+    if (properties) {
+        const hasProp = (0, code_1.hasPropFunc)(gen);
+        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp}.call(${data}, ${p})`));
+        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));
+    }
+}
+function parseDefinedProperty(cxt, key, schemas = {}) {
+    const { gen } = cxt;
+    for (const prop in schemas) {
+        gen.elseIf((0, codegen_1._) `${key} === ${prop}`);
+        parsePropertyValue(cxt, key, schemas[prop]);
+    }
+}
+function parsePropertyValue(cxt, key, schema) {
+    parseCode({ ...cxt, schema, data: (0, codegen_1._) `${cxt.data}[${key}]` });
+}
+function parseType(cxt) {
+    const { gen, schema, data, self } = cxt;
+    switch (schema.type) {
+        case "boolean":
+            parseBoolean(cxt);
+            break;
+        case "string":
+            parseString(cxt);
+            break;
+        case "timestamp": {
+            parseString(cxt);
+            const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
+            const { allowDate, parseDate } = self.opts;
+            const notValid = allowDate ? (0, codegen_1._) `!${vts}(${data}, true)` : (0, codegen_1._) `!${vts}(${data})`;
+            const fail = parseDate
+                ? (0, codegen_1.or)(notValid, (0, codegen_1._) `(${data} = new Date(${data}), false)`, (0, codegen_1._) `isNaN(${data}.valueOf())`)
+                : notValid;
+            gen.if(fail, () => parsingError(cxt, (0, codegen_1.str) `invalid timestamp`));
+            break;
+        }
+        case "float32":
+        case "float64":
+            parseNumber(cxt);
+            break;
+        default: {
+            const t = schema.type;
+            if (!self.opts.int32range && (t === "int32" || t === "uint32")) {
+                parseNumber(cxt, 16); // 2 ** 53 - max safe integer
+                if (t === "uint32") {
+                    gen.if((0, codegen_1._) `${data} < 0`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
+                }
+            }
+            else {
+                const [min, max, maxDigits] = type_1.intRange[t];
+                parseNumber(cxt, maxDigits);
+                gen.if((0, codegen_1._) `${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
+            }
+        }
+    }
+}
+function parseString(cxt) {
+    parseToken(cxt, '"');
+    parseWith(cxt, parseJson_1.parseJsonString);
+}
+function parseEnum(cxt) {
+    const { gen, data, schema } = cxt;
+    const enumSch = schema.enum;
+    parseToken(cxt, '"');
+    // TODO loopEnum
+    gen.if(false);
+    for (const value of enumSch) {
+        const valueStr = JSON.stringify(value).slice(1); // remove starting quote
+        gen.elseIf((0, codegen_1._) `${jsonSlice(valueStr.length)} === ${valueStr}`);
+        gen.assign(data, (0, codegen_1.str) `${value}`);
+        gen.add(names_1.default.jsonPos, valueStr.length);
+    }
+    gen.else();
+    jsonSyntaxError(cxt);
+    gen.endIf();
+}
+function parseNumber(cxt, maxDigits) {
+    const { gen } = cxt;
+    skipWhitespace(cxt);
+    gen.if((0, codegen_1._) `"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
+}
+function parseBooleanToken(bool, fail) {
+    return (cxt) => {
+        const { gen, data } = cxt;
+        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
+    };
+}
+function parseRef(cxt) {
+    const { gen, self, definitions, schema, schemaEnv } = cxt;
+    const { ref } = schema;
+    const refSchema = definitions[ref];
+    if (!refSchema)
+        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
+    if (!(0, ref_1.hasRef)(refSchema))
+        return parseCode({ ...cxt, schema: refSchema });
+    const { root } = schemaEnv;
+    const sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
+    partialParse(cxt, getParser(gen, sch), true);
+}
+function getParser(gen, sch) {
+    return sch.parse
+        ? gen.scopeValue("parse", { ref: sch.parse })
+        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.parse`;
+}
+function parseEmpty(cxt) {
+    parseWith(cxt, parseJson_1.parseJson);
+}
+function parseWith(cxt, parseFunc, args) {
+    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
+}
+function partialParse(cxt, parseFunc, args) {
+    const { gen, data } = cxt;
+    gen.assign(data, (0, codegen_1._) `${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._) `, ${args}` : codegen_1.nil})`);
+    gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${parseFunc}.position`);
+    gen.if((0, codegen_1._) `${data} === undefined`, () => parsingError(cxt, (0, codegen_1._) `${parseFunc}.message`));
+}
+function parseToken(cxt, tok) {
+    tryParseToken(cxt, tok, jsonSyntaxError);
+}
+function tryParseToken(cxt, tok, fail, success) {
+    const { gen } = cxt;
+    const n = tok.length;
+    skipWhitespace(cxt);
+    gen.if((0, codegen_1._) `${jsonSlice(n)} === ${tok}`, () => {
+        gen.add(names_1.default.jsonPos, n);
+        success === null || success === void 0 ? void 0 : success(cxt);
+    }, () => fail(cxt));
+}
+function skipWhitespace({ gen, char: c }) {
+    gen.code((0, codegen_1._) `while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
+}
+function jsonSlice(len) {
+    return len === 1
+        ? (0, codegen_1._) `${names_1.default.json}[${names_1.default.jsonPos}]`
+        : (0, codegen_1._) `${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
+}
+function jsonSyntaxError(cxt) {
+    parsingError(cxt, (0, codegen_1._) `"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
+}
+function parsingError({ gen, parseName }, msg) {
+    gen.assign((0, codegen_1._) `${parseName}.message`, msg);
+    gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
+    gen.return(undef);
+}
+//# sourceMappingURL=parse.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/jtd/serialize.js b/node_modules/ajv/dist/compile/jtd/serialize.js
index 341c500..0f49339 100644
--- a/node_modules/ajv/dist/compile/jtd/serialize.js
+++ b/node_modules/ajv/dist/compile/jtd/serialize.js
@@ -226,4 +226,3 @@ function addComma({ gen }, first) {
         gen.add(names_1.default.json, (0, codegen_1.str) `,`);
     }
 }
-//# sourceMappingURL=serialize.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/jtd/serialize.js.bak b/node_modules/ajv/dist/compile/jtd/serialize.js.bak
new file mode 100644
index 0000000..341c500
--- /dev/null
+++ b/node_modules/ajv/dist/compile/jtd/serialize.js.bak
@@ -0,0 +1,229 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const types_1 = require("./types");
+const __1 = require("..");
+const codegen_1 = require("../codegen");
+const ref_error_1 = require("../ref_error");
+const names_1 = require("../names");
+const code_1 = require("../../vocabularies/code");
+const ref_1 = require("../../vocabularies/jtd/ref");
+const util_1 = require("../util");
+const quote_1 = require("../../runtime/quote");
+const genSerialize = {
+    elements: serializeElements,
+    values: serializeValues,
+    discriminator: serializeDiscriminator,
+    properties: serializeProperties,
+    optionalProperties: serializeProperties,
+    enum: serializeString,
+    type: serializeType,
+    ref: serializeRef,
+};
+function compileSerializer(sch, definitions) {
+    const _sch = __1.getCompilingSchema.call(this, sch);
+    if (_sch)
+        return _sch;
+    const { es5, lines } = this.opts.code;
+    const { ownProperties } = this.opts;
+    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
+    const serializeName = gen.scopeName("serialize");
+    const cxt = {
+        self: this,
+        gen,
+        schema: sch.schema,
+        schemaEnv: sch,
+        definitions,
+        data: names_1.default.data,
+    };
+    let sourceCode;
+    try {
+        this._compilations.add(sch);
+        sch.serializeName = serializeName;
+        gen.func(serializeName, names_1.default.data, false, () => {
+            gen.let(names_1.default.json, (0, codegen_1.str) ``);
+            serializeCode(cxt);
+            gen.return(names_1.default.json);
+        });
+        gen.optimize(this.opts.code.optimize);
+        const serializeFuncCode = gen.toString();
+        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
+        const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
+        const serialize = makeSerialize(this.scope.get());
+        this.scope.value(serializeName, { ref: serialize });
+        sch.serialize = serialize;
+    }
+    catch (e) {
+        if (sourceCode)
+            this.logger.error("Error compiling serializer, function code:", sourceCode);
+        delete sch.serialize;
+        delete sch.serializeName;
+        throw e;
+    }
+    finally {
+        this._compilations.delete(sch);
+    }
+    return sch;
+}
+exports.default = compileSerializer;
+function serializeCode(cxt) {
+    let form;
+    for (const key of types_1.jtdForms) {
+        if (key in cxt.schema) {
+            form = key;
+            break;
+        }
+    }
+    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
+}
+function serializeNullable(cxt, serializeForm) {
+    const { gen, schema, data } = cxt;
+    if (!schema.nullable)
+        return serializeForm(cxt);
+    gen.if((0, codegen_1._) `${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._) `"null"`), () => serializeForm(cxt));
+}
+function serializeElements(cxt) {
+    const { gen, schema, data } = cxt;
+    gen.add(names_1.default.json, (0, codegen_1.str) `[`);
+    const first = gen.let("first", true);
+    gen.forOf("el", data, (el) => {
+        addComma(cxt, first);
+        serializeCode({ ...cxt, schema: schema.elements, data: el });
+    });
+    gen.add(names_1.default.json, (0, codegen_1.str) `]`);
+}
+function serializeValues(cxt) {
+    const { gen, schema, data } = cxt;
+    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
+    const first = gen.let("first", true);
+    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
+    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
+}
+function serializeKeyValue(cxt, key, schema, first) {
+    const { gen, data } = cxt;
+    addComma(cxt, first);
+    serializeString({ ...cxt, data: key });
+    gen.add(names_1.default.json, (0, codegen_1.str) `:`);
+    const value = gen.const("value", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(key)}`);
+    serializeCode({ ...cxt, schema, data: value });
+}
+function serializeDiscriminator(cxt) {
+    const { gen, schema, data } = cxt;
+    const { discriminator } = schema;
+    gen.add(names_1.default.json, (0, codegen_1.str) `{${JSON.stringify(discriminator)}:`);
+    const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(discriminator)}`);
+    serializeString({ ...cxt, data: tag });
+    gen.if(false);
+    for (const tagValue in schema.mapping) {
+        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
+        const sch = schema.mapping[tagValue];
+        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
+    }
+    gen.endIf();
+    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
+}
+function serializeProperties(cxt) {
+    const { gen } = cxt;
+    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
+    serializeSchemaProperties(cxt);
+    gen.add(names_1.default.json, (0, codegen_1.str) `}`);
+}
+function serializeSchemaProperties(cxt, discriminator) {
+    const { gen, schema, data } = cxt;
+    const { properties, optionalProperties } = schema;
+    const props = keys(properties);
+    const optProps = keys(optionalProperties);
+    const allProps = allProperties(props.concat(optProps));
+    let first = !discriminator;
+    let firstProp;
+    for (const key of props) {
+        if (first)
+            first = false;
+        else
+            gen.add(names_1.default.json, (0, codegen_1.str) `,`);
+        serializeProperty(key, properties[key], keyValue(key));
+    }
+    if (first)
+        firstProp = gen.let("first", true);
+    for (const key of optProps) {
+        const value = keyValue(key);
+        gen.if((0, codegen_1.and)((0, codegen_1._) `${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
+            addComma(cxt, firstProp);
+            serializeProperty(key, optionalProperties[key], value);
+        });
+    }
+    if (schema.additionalProperties) {
+        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
+    }
+    function keys(ps) {
+        return ps ? Object.keys(ps) : [];
+    }
+    function allProperties(ps) {
+        if (discriminator)
+            ps.push(discriminator);
+        if (new Set(ps).size !== ps.length) {
+            throw new Error("JTD: properties/optionalProperties/disciminator overlap");
+        }
+        return ps;
+    }
+    function keyValue(key) {
+        return gen.const("value", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(key)}`);
+    }
+    function serializeProperty(key, propSchema, value) {
+        gen.add(names_1.default.json, (0, codegen_1.str) `${JSON.stringify(key)}:`);
+        serializeCode({ ...cxt, schema: propSchema, data: value });
+    }
+    function isAdditional(key, ps) {
+        return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`)) : true;
+    }
+}
+function serializeType(cxt) {
+    const { gen, schema, data } = cxt;
+    switch (schema.type) {
+        case "boolean":
+            gen.add(names_1.default.json, (0, codegen_1._) `${data} ? "true" : "false"`);
+            break;
+        case "string":
+            serializeString(cxt);
+            break;
+        case "timestamp":
+            gen.if((0, codegen_1._) `${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._) `'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
+            break;
+        default:
+            serializeNumber(cxt);
+    }
+}
+function serializeString({ gen, data }) {
+    gen.add(names_1.default.json, (0, codegen_1._) `${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
+}
+function serializeNumber({ gen, data }) {
+    gen.add(names_1.default.json, (0, codegen_1._) `"" + ${data}`);
+}
+function serializeRef(cxt) {
+    const { gen, self, data, definitions, schema, schemaEnv } = cxt;
+    const { ref } = schema;
+    const refSchema = definitions[ref];
+    if (!refSchema)
+        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
+    if (!(0, ref_1.hasRef)(refSchema))
+        return serializeCode({ ...cxt, schema: refSchema });
+    const { root } = schemaEnv;
+    const sch = compileSerializer.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
+    gen.add(names_1.default.json, (0, codegen_1._) `${getSerialize(gen, sch)}(${data})`);
+}
+function getSerialize(gen, sch) {
+    return sch.serialize
+        ? gen.scopeValue("serialize", { ref: sch.serialize })
+        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
+}
+function serializeEmpty({ gen, data }) {
+    gen.add(names_1.default.json, (0, codegen_1._) `JSON.stringify(${data})`);
+}
+function addComma({ gen }, first) {
+    if (first) {
+        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str) `,`));
+    }
+    else {
+        gen.add(names_1.default.json, (0, codegen_1.str) `,`);
+    }
+}
+//# sourceMappingURL=serialize.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/jtd/types.js b/node_modules/ajv/dist/compile/jtd/types.js
index b9c60a9..a6b9110 100644
--- a/node_modules/ajv/dist/compile/jtd/types.js
+++ b/node_modules/ajv/dist/compile/jtd/types.js
@@ -11,4 +11,3 @@ exports.jtdForms = [
     "type",
     "ref",
 ];
-//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/jtd/types.js.bak b/node_modules/ajv/dist/compile/jtd/types.js.bak
new file mode 100644
index 0000000..b9c60a9
--- /dev/null
+++ b/node_modules/ajv/dist/compile/jtd/types.js.bak
@@ -0,0 +1,14 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.jtdForms = void 0;
+exports.jtdForms = [
+    "elements",
+    "values",
+    "discriminator",
+    "properties",
+    "optionalProperties",
+    "enum",
+    "type",
+    "ref",
+];
+//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/names.js b/node_modules/ajv/dist/compile/names.js
index 015334b..9397455 100644
--- a/node_modules/ajv/dist/compile/names.js
+++ b/node_modules/ajv/dist/compile/names.js
@@ -25,4 +25,3 @@ const names = {
     jsonPart: new codegen_1.Name("jsonPart"),
 };
 exports.default = names;
-//# sourceMappingURL=names.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/names.js.bak b/node_modules/ajv/dist/compile/names.js.bak
new file mode 100644
index 0000000..015334b
--- /dev/null
+++ b/node_modules/ajv/dist/compile/names.js.bak
@@ -0,0 +1,28 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("./codegen");
+const names = {
+    // validation function arguments
+    data: new codegen_1.Name("data"),
+    // args passed from referencing schema
+    valCxt: new codegen_1.Name("valCxt"),
+    instancePath: new codegen_1.Name("instancePath"),
+    parentData: new codegen_1.Name("parentData"),
+    parentDataProperty: new codegen_1.Name("parentDataProperty"),
+    rootData: new codegen_1.Name("rootData"),
+    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
+    // function scoped variables
+    vErrors: new codegen_1.Name("vErrors"),
+    errors: new codegen_1.Name("errors"),
+    this: new codegen_1.Name("this"),
+    // "globals"
+    self: new codegen_1.Name("self"),
+    scope: new codegen_1.Name("scope"),
+    // JTD serialize/parse name for JSON string and position
+    json: new codegen_1.Name("json"),
+    jsonPos: new codegen_1.Name("jsonPos"),
+    jsonLen: new codegen_1.Name("jsonLen"),
+    jsonPart: new codegen_1.Name("jsonPart"),
+};
+exports.default = names;
+//# sourceMappingURL=names.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/ref_error.js b/node_modules/ajv/dist/compile/ref_error.js
index 3916dec..78a7fcf 100644
--- a/node_modules/ajv/dist/compile/ref_error.js
+++ b/node_modules/ajv/dist/compile/ref_error.js
@@ -9,4 +9,3 @@ class MissingRefError extends Error {
     }
 }
 exports.default = MissingRefError;
-//# sourceMappingURL=ref_error.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/ref_error.js.bak b/node_modules/ajv/dist/compile/ref_error.js.bak
new file mode 100644
index 0000000..3916dec
--- /dev/null
+++ b/node_modules/ajv/dist/compile/ref_error.js.bak
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const resolve_1 = require("./resolve");
+class MissingRefError extends Error {
+    constructor(resolver, baseId, ref, msg) {
+        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
+        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
+        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
+    }
+}
+exports.default = MissingRefError;
+//# sourceMappingURL=ref_error.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/resolve.js b/node_modules/ajv/dist/compile/resolve.js
index 8b51a20..6252c6a 100644
--- a/node_modules/ajv/dist/compile/resolve.js
+++ b/node_modules/ajv/dist/compile/resolve.js
@@ -152,4 +152,3 @@ function getSchemaRefs(schema, baseId) {
     }
 }
 exports.getSchemaRefs = getSchemaRefs;
-//# sourceMappingURL=resolve.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/resolve.js.bak b/node_modules/ajv/dist/compile/resolve.js.bak
new file mode 100644
index 0000000..8b51a20
--- /dev/null
+++ b/node_modules/ajv/dist/compile/resolve.js.bak
@@ -0,0 +1,155 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
+const util_1 = require("./util");
+const equal = require("fast-deep-equal");
+const traverse = require("json-schema-traverse");
+// TODO refactor to use keyword definitions
+const SIMPLE_INLINED = new Set([
+    "type",
+    "format",
+    "pattern",
+    "maxLength",
+    "minLength",
+    "maxProperties",
+    "minProperties",
+    "maxItems",
+    "minItems",
+    "maximum",
+    "minimum",
+    "uniqueItems",
+    "multipleOf",
+    "required",
+    "enum",
+    "const",
+]);
+function inlineRef(schema, limit = true) {
+    if (typeof schema == "boolean")
+        return true;
+    if (limit === true)
+        return !hasRef(schema);
+    if (!limit)
+        return false;
+    return countKeys(schema) <= limit;
+}
+exports.inlineRef = inlineRef;
+const REF_KEYWORDS = new Set([
+    "$ref",
+    "$recursiveRef",
+    "$recursiveAnchor",
+    "$dynamicRef",
+    "$dynamicAnchor",
+]);
+function hasRef(schema) {
+    for (const key in schema) {
+        if (REF_KEYWORDS.has(key))
+            return true;
+        const sch = schema[key];
+        if (Array.isArray(sch) && sch.some(hasRef))
+            return true;
+        if (typeof sch == "object" && hasRef(sch))
+            return true;
+    }
+    return false;
+}
+function countKeys(schema) {
+    let count = 0;
+    for (const key in schema) {
+        if (key === "$ref")
+            return Infinity;
+        count++;
+        if (SIMPLE_INLINED.has(key))
+            continue;
+        if (typeof schema[key] == "object") {
+            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
+        }
+        if (count === Infinity)
+            return Infinity;
+    }
+    return count;
+}
+function getFullPath(resolver, id = "", normalize) {
+    if (normalize !== false)
+        id = normalizeId(id);
+    const p = resolver.parse(id);
+    return _getFullPath(resolver, p);
+}
+exports.getFullPath = getFullPath;
+function _getFullPath(resolver, p) {
+    const serialized = resolver.serialize(p);
+    return serialized.split("#")[0] + "#";
+}
+exports._getFullPath = _getFullPath;
+const TRAILING_SLASH_HASH = /#\/?$/;
+function normalizeId(id) {
+    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
+}
+exports.normalizeId = normalizeId;
+function resolveUrl(resolver, baseId, id) {
+    id = normalizeId(id);
+    return resolver.resolve(baseId, id);
+}
+exports.resolveUrl = resolveUrl;
+const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
+function getSchemaRefs(schema, baseId) {
+    if (typeof schema == "boolean")
+        return {};
+    const { schemaId, uriResolver } = this.opts;
+    const schId = normalizeId(schema[schemaId] || baseId);
+    const baseIds = { "": schId };
+    const pathPrefix = getFullPath(uriResolver, schId, false);
+    const localRefs = {};
+    const schemaRefs = new Set();
+    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
+        if (parentJsonPtr === undefined)
+            return;
+        const fullPath = pathPrefix + jsonPtr;
+        let baseId = baseIds[parentJsonPtr];
+        if (typeof sch[schemaId] == "string")
+            baseId = addRef.call(this, sch[schemaId]);
+        addAnchor.call(this, sch.$anchor);
+        addAnchor.call(this, sch.$dynamicAnchor);
+        baseIds[jsonPtr] = baseId;
+        function addRef(ref) {
+            // eslint-disable-next-line @typescript-eslint/unbound-method
+            const _resolve = this.opts.uriResolver.resolve;
+            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);
+            if (schemaRefs.has(ref))
+                throw ambiguos(ref);
+            schemaRefs.add(ref);
+            let schOrRef = this.refs[ref];
+            if (typeof schOrRef == "string")
+                schOrRef = this.refs[schOrRef];
+            if (typeof schOrRef == "object") {
+                checkAmbiguosRef(sch, schOrRef.schema, ref);
+            }
+            else if (ref !== normalizeId(fullPath)) {
+                if (ref[0] === "#") {
+                    checkAmbiguosRef(sch, localRefs[ref], ref);
+                    localRefs[ref] = sch;
+                }
+                else {
+                    this.refs[ref] = fullPath;
+                }
+            }
+            return ref;
+        }
+        function addAnchor(anchor) {
+            if (typeof anchor == "string") {
+                if (!ANCHOR.test(anchor))
+                    throw new Error(`invalid anchor "${anchor}"`);
+                addRef.call(this, `#${anchor}`);
+            }
+        }
+    });
+    return localRefs;
+    function checkAmbiguosRef(sch1, sch2, ref) {
+        if (sch2 !== undefined && !equal(sch1, sch2))
+            throw ambiguos(ref);
+    }
+    function ambiguos(ref) {
+        return new Error(`reference "${ref}" resolves to more than one schema`);
+    }
+}
+exports.getSchemaRefs = getSchemaRefs;
+//# sourceMappingURL=resolve.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/rules.js b/node_modules/ajv/dist/compile/rules.js
index 82a591f..dc606c7 100644
--- a/node_modules/ajv/dist/compile/rules.js
+++ b/node_modules/ajv/dist/compile/rules.js
@@ -23,4 +23,3 @@ function getRules() {
     };
 }
 exports.getRules = getRules;
-//# sourceMappingURL=rules.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/rules.js.bak b/node_modules/ajv/dist/compile/rules.js.bak
new file mode 100644
index 0000000..82a591f
--- /dev/null
+++ b/node_modules/ajv/dist/compile/rules.js.bak
@@ -0,0 +1,26 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getRules = exports.isJSONType = void 0;
+const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
+const jsonTypes = new Set(_jsonTypes);
+function isJSONType(x) {
+    return typeof x == "string" && jsonTypes.has(x);
+}
+exports.isJSONType = isJSONType;
+function getRules() {
+    const groups = {
+        number: { type: "number", rules: [] },
+        string: { type: "string", rules: [] },
+        array: { type: "array", rules: [] },
+        object: { type: "object", rules: [] },
+    };
+    return {
+        types: { ...groups, integer: true, boolean: true, null: true },
+        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
+        post: { rules: [] },
+        all: {},
+        keywords: {},
+    };
+}
+exports.getRules = getRules;
+//# sourceMappingURL=rules.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/util.js b/node_modules/ajv/dist/compile/util.js
index 091ad4c..aaf7473 100644
--- a/node_modules/ajv/dist/compile/util.js
+++ b/node_modules/ajv/dist/compile/util.js
@@ -175,4 +175,3 @@ function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
     it.self.logger.warn(msg);
 }
 exports.checkStrictMode = checkStrictMode;
-//# sourceMappingURL=util.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/util.js.bak b/node_modules/ajv/dist/compile/util.js.bak
new file mode 100644
index 0000000..091ad4c
--- /dev/null
+++ b/node_modules/ajv/dist/compile/util.js.bak
@@ -0,0 +1,178 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
+const codegen_1 = require("./codegen");
+const code_1 = require("./codegen/code");
+// TODO refactor to use Set
+function toHash(arr) {
+    const hash = {};
+    for (const item of arr)
+        hash[item] = true;
+    return hash;
+}
+exports.toHash = toHash;
+function alwaysValidSchema(it, schema) {
+    if (typeof schema == "boolean")
+        return schema;
+    if (Object.keys(schema).length === 0)
+        return true;
+    checkUnknownRules(it, schema);
+    return !schemaHasRules(schema, it.self.RULES.all);
+}
+exports.alwaysValidSchema = alwaysValidSchema;
+function checkUnknownRules(it, schema = it.schema) {
+    const { opts, self } = it;
+    if (!opts.strictSchema)
+        return;
+    if (typeof schema === "boolean")
+        return;
+    const rules = self.RULES.keywords;
+    for (const key in schema) {
+        if (!rules[key])
+            checkStrictMode(it, `unknown keyword: "${key}"`);
+    }
+}
+exports.checkUnknownRules = checkUnknownRules;
+function schemaHasRules(schema, rules) {
+    if (typeof schema == "boolean")
+        return !schema;
+    for (const key in schema)
+        if (rules[key])
+            return true;
+    return false;
+}
+exports.schemaHasRules = schemaHasRules;
+function schemaHasRulesButRef(schema, RULES) {
+    if (typeof schema == "boolean")
+        return !schema;
+    for (const key in schema)
+        if (key !== "$ref" && RULES.all[key])
+            return true;
+    return false;
+}
+exports.schemaHasRulesButRef = schemaHasRulesButRef;
+function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
+    if (!$data) {
+        if (typeof schema == "number" || typeof schema == "boolean")
+            return schema;
+        if (typeof schema == "string")
+            return (0, codegen_1._) `${schema}`;
+    }
+    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
+}
+exports.schemaRefOrVal = schemaRefOrVal;
+function unescapeFragment(str) {
+    return unescapeJsonPointer(decodeURIComponent(str));
+}
+exports.unescapeFragment = unescapeFragment;
+function escapeFragment(str) {
+    return encodeURIComponent(escapeJsonPointer(str));
+}
+exports.escapeFragment = escapeFragment;
+function escapeJsonPointer(str) {
+    if (typeof str == "number")
+        return `${str}`;
+    return str.replace(/~/g, "~0").replace(/\//g, "~1");
+}
+exports.escapeJsonPointer = escapeJsonPointer;
+function unescapeJsonPointer(str) {
+    return str.replace(/~1/g, "/").replace(/~0/g, "~");
+}
+exports.unescapeJsonPointer = unescapeJsonPointer;
+function eachItem(xs, f) {
+    if (Array.isArray(xs)) {
+        for (const x of xs)
+            f(x);
+    }
+    else {
+        f(xs);
+    }
+}
+exports.eachItem = eachItem;
+function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
+    return (gen, from, to, toName) => {
+        const res = to === undefined
+            ? from
+            : to instanceof codegen_1.Name
+                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
+                : from instanceof codegen_1.Name
+                    ? (mergeToName(gen, to, from), from)
+                    : mergeValues(from, to);
+        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
+    };
+}
+exports.mergeEvaluated = {
+    props: makeMergeEvaluated({
+        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
+            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
+        }),
+        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
+            if (from === true) {
+                gen.assign(to, true);
+            }
+            else {
+                gen.assign(to, (0, codegen_1._) `${to} || {}`);
+                setEvaluated(gen, to, from);
+            }
+        }),
+        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
+        resultToName: evaluatedPropsToName,
+    }),
+    items: makeMergeEvaluated({
+        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
+        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
+        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
+        resultToName: (gen, items) => gen.var("items", items),
+    }),
+};
+function evaluatedPropsToName(gen, ps) {
+    if (ps === true)
+        return gen.var("props", true);
+    const props = gen.var("props", (0, codegen_1._) `{}`);
+    if (ps !== undefined)
+        setEvaluated(gen, props, ps);
+    return props;
+}
+exports.evaluatedPropsToName = evaluatedPropsToName;
+function setEvaluated(gen, props, ps) {
+    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
+}
+exports.setEvaluated = setEvaluated;
+const snippets = {};
+function useFunc(gen, f) {
+    return gen.scopeValue("func", {
+        ref: f,
+        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
+    });
+}
+exports.useFunc = useFunc;
+var Type;
+(function (Type) {
+    Type[Type["Num"] = 0] = "Num";
+    Type[Type["Str"] = 1] = "Str";
+})(Type = exports.Type || (exports.Type = {}));
+function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
+    // let path
+    if (dataProp instanceof codegen_1.Name) {
+        const isNumber = dataPropType === Type.Num;
+        return jsPropertySyntax
+            ? isNumber
+                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
+                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
+            : isNumber
+                ? (0, codegen_1._) `"/" + ${dataProp}`
+                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
+    }
+    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
+}
+exports.getErrorPath = getErrorPath;
+function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
+    if (!mode)
+        return;
+    msg = `strict mode: ${msg}`;
+    if (mode === true)
+        throw new Error(msg);
+    it.self.logger.warn(msg);
+}
+exports.checkStrictMode = checkStrictMode;
+//# sourceMappingURL=util.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/applicability.js b/node_modules/ajv/dist/compile/validate/applicability.js
index 6187dbb..3743a57 100644
--- a/node_modules/ajv/dist/compile/validate/applicability.js
+++ b/node_modules/ajv/dist/compile/validate/applicability.js
@@ -16,4 +16,3 @@ function shouldUseRule(schema, rule) {
         ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
 }
 exports.shouldUseRule = shouldUseRule;
-//# sourceMappingURL=applicability.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/applicability.js.bak b/node_modules/ajv/dist/compile/validate/applicability.js.bak
new file mode 100644
index 0000000..6187dbb
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/applicability.js.bak
@@ -0,0 +1,19 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
+function schemaHasRulesForType({ schema, self }, type) {
+    const group = self.RULES.types[type];
+    return group && group !== true && shouldUseGroup(schema, group);
+}
+exports.schemaHasRulesForType = schemaHasRulesForType;
+function shouldUseGroup(schema, group) {
+    return group.rules.some((rule) => shouldUseRule(schema, rule));
+}
+exports.shouldUseGroup = shouldUseGroup;
+function shouldUseRule(schema, rule) {
+    var _a;
+    return (schema[rule.keyword] !== undefined ||
+        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
+}
+exports.shouldUseRule = shouldUseRule;
+//# sourceMappingURL=applicability.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/boolSchema.js b/node_modules/ajv/dist/compile/validate/boolSchema.js
index 8eeb7b5..ae67669 100644
--- a/node_modules/ajv/dist/compile/validate/boolSchema.js
+++ b/node_modules/ajv/dist/compile/validate/boolSchema.js
@@ -47,4 +47,3 @@ function falseSchemaError(it, overrideAllErrors) {
     };
     (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
 }
-//# sourceMappingURL=boolSchema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/boolSchema.js.bak b/node_modules/ajv/dist/compile/validate/boolSchema.js.bak
new file mode 100644
index 0000000..8eeb7b5
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/boolSchema.js.bak
@@ -0,0 +1,50 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
+const errors_1 = require("../errors");
+const codegen_1 = require("../codegen");
+const names_1 = require("../names");
+const boolError = {
+    message: "boolean schema is false",
+};
+function topBoolOrEmptySchema(it) {
+    const { gen, schema, validateName } = it;
+    if (schema === false) {
+        falseSchemaError(it, false);
+    }
+    else if (typeof schema == "object" && schema.$async === true) {
+        gen.return(names_1.default.data);
+    }
+    else {
+        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
+        gen.return(true);
+    }
+}
+exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
+function boolOrEmptySchema(it, valid) {
+    const { gen, schema } = it;
+    if (schema === false) {
+        gen.var(valid, false); // TODO var
+        falseSchemaError(it);
+    }
+    else {
+        gen.var(valid, true); // TODO var
+    }
+}
+exports.boolOrEmptySchema = boolOrEmptySchema;
+function falseSchemaError(it, overrideAllErrors) {
+    const { gen, data } = it;
+    // TODO maybe some other interface should be used for non-keyword validation errors...
+    const cxt = {
+        gen,
+        keyword: "false schema",
+        data,
+        schema: false,
+        schemaCode: false,
+        schemaValue: false,
+        params: {},
+        it,
+    };
+    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
+}
+//# sourceMappingURL=boolSchema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/dataType.js b/node_modules/ajv/dist/compile/validate/dataType.js
index 1732d46..675918c 100644
--- a/node_modules/ajv/dist/compile/validate/dataType.js
+++ b/node_modules/ajv/dist/compile/validate/dataType.js
@@ -199,4 +199,3 @@ function getTypeErrorContext(it) {
         it,
     };
 }
-//# sourceMappingURL=dataType.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/dataType.js.bak b/node_modules/ajv/dist/compile/validate/dataType.js.bak
new file mode 100644
index 0000000..1732d46
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/dataType.js.bak
@@ -0,0 +1,202 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
+const rules_1 = require("../rules");
+const applicability_1 = require("./applicability");
+const errors_1 = require("../errors");
+const codegen_1 = require("../codegen");
+const util_1 = require("../util");
+var DataType;
+(function (DataType) {
+    DataType[DataType["Correct"] = 0] = "Correct";
+    DataType[DataType["Wrong"] = 1] = "Wrong";
+})(DataType = exports.DataType || (exports.DataType = {}));
+function getSchemaTypes(schema) {
+    const types = getJSONTypes(schema.type);
+    const hasNull = types.includes("null");
+    if (hasNull) {
+        if (schema.nullable === false)
+            throw new Error("type: null contradicts nullable: false");
+    }
+    else {
+        if (!types.length && schema.nullable !== undefined) {
+            throw new Error('"nullable" cannot be used without "type"');
+        }
+        if (schema.nullable === true)
+            types.push("null");
+    }
+    return types;
+}
+exports.getSchemaTypes = getSchemaTypes;
+function getJSONTypes(ts) {
+    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
+    if (types.every(rules_1.isJSONType))
+        return types;
+    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
+}
+exports.getJSONTypes = getJSONTypes;
+function coerceAndCheckDataType(it, types) {
+    const { gen, data, opts } = it;
+    const coerceTo = coerceToTypes(types, opts.coerceTypes);
+    const checkTypes = types.length > 0 &&
+        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
+    if (checkTypes) {
+        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
+        gen.if(wrongType, () => {
+            if (coerceTo.length)
+                coerceData(it, types, coerceTo);
+            else
+                reportTypeError(it);
+        });
+    }
+    return checkTypes;
+}
+exports.coerceAndCheckDataType = coerceAndCheckDataType;
+const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
+function coerceToTypes(types, coerceTypes) {
+    return coerceTypes
+        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
+        : [];
+}
+function coerceData(it, types, coerceTo) {
+    const { gen, data, opts } = it;
+    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
+    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
+    if (opts.coerceTypes === "array") {
+        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
+            .assign(data, (0, codegen_1._) `${data}[0]`)
+            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
+            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
+    }
+    gen.if((0, codegen_1._) `${coerced} !== undefined`);
+    for (const t of coerceTo) {
+        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
+            coerceSpecificType(t);
+        }
+    }
+    gen.else();
+    reportTypeError(it);
+    gen.endIf();
+    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
+        gen.assign(data, coerced);
+        assignParentData(it, coerced);
+    });
+    function coerceSpecificType(t) {
+        switch (t) {
+            case "string":
+                gen
+                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
+                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
+                    .elseIf((0, codegen_1._) `${data} === null`)
+                    .assign(coerced, (0, codegen_1._) `""`);
+                return;
+            case "number":
+                gen
+                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
+              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
+                    .assign(coerced, (0, codegen_1._) `+${data}`);
+                return;
+            case "integer":
+                gen
+                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
+              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
+                    .assign(coerced, (0, codegen_1._) `+${data}`);
+                return;
+            case "boolean":
+                gen
+                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
+                    .assign(coerced, false)
+                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
+                    .assign(coerced, true);
+                return;
+            case "null":
+                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
+                gen.assign(coerced, null);
+                return;
+            case "array":
+                gen
+                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
+              || ${dataType} === "boolean" || ${data} === null`)
+                    .assign(coerced, (0, codegen_1._) `[${data}]`);
+        }
+    }
+}
+function assignParentData({ gen, parentData, parentDataProperty }, expr) {
+    // TODO use gen.property
+    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
+}
+function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
+    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
+    let cond;
+    switch (dataType) {
+        case "null":
+            return (0, codegen_1._) `${data} ${EQ} null`;
+        case "array":
+            cond = (0, codegen_1._) `Array.isArray(${data})`;
+            break;
+        case "object":
+            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
+            break;
+        case "integer":
+            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
+            break;
+        case "number":
+            cond = numCond();
+            break;
+        default:
+            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
+    }
+    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
+    function numCond(_cond = codegen_1.nil) {
+        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
+    }
+}
+exports.checkDataType = checkDataType;
+function checkDataTypes(dataTypes, data, strictNums, correct) {
+    if (dataTypes.length === 1) {
+        return checkDataType(dataTypes[0], data, strictNums, correct);
+    }
+    let cond;
+    const types = (0, util_1.toHash)(dataTypes);
+    if (types.array && types.object) {
+        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
+        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
+        delete types.null;
+        delete types.array;
+        delete types.object;
+    }
+    else {
+        cond = codegen_1.nil;
+    }
+    if (types.number)
+        delete types.integer;
+    for (const t in types)
+        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
+    return cond;
+}
+exports.checkDataTypes = checkDataTypes;
+const typeError = {
+    message: ({ schema }) => `must be ${schema}`,
+    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
+};
+function reportTypeError(it) {
+    const cxt = getTypeErrorContext(it);
+    (0, errors_1.reportError)(cxt, typeError);
+}
+exports.reportTypeError = reportTypeError;
+function getTypeErrorContext(it) {
+    const { gen, data, schema } = it;
+    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
+    return {
+        gen,
+        keyword: "type",
+        data,
+        schema: schema.type,
+        schemaCode,
+        schemaValue: schemaCode,
+        parentSchema: schema,
+        params: {},
+        it,
+    };
+}
+//# sourceMappingURL=dataType.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/defaults.js b/node_modules/ajv/dist/compile/validate/defaults.js
index cd9c42d..5fd70d6 100644
--- a/node_modules/ajv/dist/compile/validate/defaults.js
+++ b/node_modules/ajv/dist/compile/validate/defaults.js
@@ -32,4 +32,3 @@ function assignDefault(it, prop, defaultValue) {
     // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
     gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
 }
-//# sourceMappingURL=defaults.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/defaults.js.bak b/node_modules/ajv/dist/compile/validate/defaults.js.bak
new file mode 100644
index 0000000..cd9c42d
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/defaults.js.bak
@@ -0,0 +1,35 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.assignDefaults = void 0;
+const codegen_1 = require("../codegen");
+const util_1 = require("../util");
+function assignDefaults(it, ty) {
+    const { properties, items } = it.schema;
+    if (ty === "object" && properties) {
+        for (const key in properties) {
+            assignDefault(it, key, properties[key].default);
+        }
+    }
+    else if (ty === "array" && Array.isArray(items)) {
+        items.forEach((sch, i) => assignDefault(it, i, sch.default));
+    }
+}
+exports.assignDefaults = assignDefaults;
+function assignDefault(it, prop, defaultValue) {
+    const { gen, compositeRule, data, opts } = it;
+    if (defaultValue === undefined)
+        return;
+    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
+    if (compositeRule) {
+        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
+        return;
+    }
+    let condition = (0, codegen_1._) `${childData} === undefined`;
+    if (opts.useDefaults === "empty") {
+        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
+    }
+    // `${childData} === undefined` +
+    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
+    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
+}
+//# sourceMappingURL=defaults.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/index.js b/node_modules/ajv/dist/compile/validate/index.js
index 0d68332..b62397c 100644
--- a/node_modules/ajv/dist/compile/validate/index.js
+++ b/node_modules/ajv/dist/compile/validate/index.js
@@ -517,4 +517,3 @@ function getData($data, { dataLevel, dataNames, dataPathArr }) {
     }
 }
 exports.getData = getData;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/index.js.bak b/node_modules/ajv/dist/compile/validate/index.js.bak
new file mode 100644
index 0000000..0d68332
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/index.js.bak
@@ -0,0 +1,520 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
+const boolSchema_1 = require("./boolSchema");
+const dataType_1 = require("./dataType");
+const applicability_1 = require("./applicability");
+const dataType_2 = require("./dataType");
+const defaults_1 = require("./defaults");
+const keyword_1 = require("./keyword");
+const subschema_1 = require("./subschema");
+const codegen_1 = require("../codegen");
+const names_1 = require("../names");
+const resolve_1 = require("../resolve");
+const util_1 = require("../util");
+const errors_1 = require("../errors");
+// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
+function validateFunctionCode(it) {
+    if (isSchemaObj(it)) {
+        checkKeywords(it);
+        if (schemaCxtHasRules(it)) {
+            topSchemaObjCode(it);
+            return;
+        }
+    }
+    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
+}
+exports.validateFunctionCode = validateFunctionCode;
+function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
+    if (opts.code.es5) {
+        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
+            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
+            destructureValCxtES5(gen, opts);
+            gen.code(body);
+        });
+    }
+    else {
+        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
+    }
+}
+function destructureValCxt(opts) {
+    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
+}
+function destructureValCxtES5(gen, opts) {
+    gen.if(names_1.default.valCxt, () => {
+        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
+        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
+        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
+        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
+        if (opts.dynamicRef)
+            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
+    }, () => {
+        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
+        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
+        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
+        gen.var(names_1.default.rootData, names_1.default.data);
+        if (opts.dynamicRef)
+            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
+    });
+}
+function topSchemaObjCode(it) {
+    const { schema, opts, gen } = it;
+    validateFunction(it, () => {
+        if (opts.$comment && schema.$comment)
+            commentKeyword(it);
+        checkNoDefault(it);
+        gen.let(names_1.default.vErrors, null);
+        gen.let(names_1.default.errors, 0);
+        if (opts.unevaluated)
+            resetEvaluated(it);
+        typeAndKeywords(it);
+        returnResults(it);
+    });
+    return;
+}
+function resetEvaluated(it) {
+    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
+    const { gen, validateName } = it;
+    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
+    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
+    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
+}
+function funcSourceUrl(schema, opts) {
+    const schId = typeof schema == "object" && schema[opts.schemaId];
+    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
+}
+// schema compilation - this function is used recursively to generate code for sub-schemas
+function subschemaCode(it, valid) {
+    if (isSchemaObj(it)) {
+        checkKeywords(it);
+        if (schemaCxtHasRules(it)) {
+            subSchemaObjCode(it, valid);
+            return;
+        }
+    }
+    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
+}
+function schemaCxtHasRules({ schema, self }) {
+    if (typeof schema == "boolean")
+        return !schema;
+    for (const key in schema)
+        if (self.RULES.all[key])
+            return true;
+    return false;
+}
+function isSchemaObj(it) {
+    return typeof it.schema != "boolean";
+}
+function subSchemaObjCode(it, valid) {
+    const { schema, gen, opts } = it;
+    if (opts.$comment && schema.$comment)
+        commentKeyword(it);
+    updateContext(it);
+    checkAsyncSchema(it);
+    const errsCount = gen.const("_errs", names_1.default.errors);
+    typeAndKeywords(it, errsCount);
+    // TODO var
+    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
+}
+function checkKeywords(it) {
+    (0, util_1.checkUnknownRules)(it);
+    checkRefsAndKeywords(it);
+}
+function typeAndKeywords(it, errsCount) {
+    if (it.opts.jtd)
+        return schemaKeywords(it, [], false, errsCount);
+    const types = (0, dataType_1.getSchemaTypes)(it.schema);
+    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
+    schemaKeywords(it, types, !checkedTypes, errsCount);
+}
+function checkRefsAndKeywords(it) {
+    const { schema, errSchemaPath, opts, self } = it;
+    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
+        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
+    }
+}
+function checkNoDefault(it) {
+    const { schema, opts } = it;
+    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
+        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
+    }
+}
+function updateContext(it) {
+    const schId = it.schema[it.opts.schemaId];
+    if (schId)
+        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
+}
+function checkAsyncSchema(it) {
+    if (it.schema.$async && !it.schemaEnv.$async)
+        throw new Error("async schema in sync schema");
+}
+function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
+    const msg = schema.$comment;
+    if (opts.$comment === true) {
+        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
+    }
+    else if (typeof opts.$comment == "function") {
+        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
+        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
+        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
+    }
+}
+function returnResults(it) {
+    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
+    if (schemaEnv.$async) {
+        // TODO assign unevaluated
+        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
+    }
+    else {
+        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
+        if (opts.unevaluated)
+            assignEvaluated(it);
+        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
+    }
+}
+function assignEvaluated({ gen, evaluated, props, items }) {
+    if (props instanceof codegen_1.Name)
+        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
+    if (items instanceof codegen_1.Name)
+        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
+}
+function schemaKeywords(it, types, typeErrors, errsCount) {
+    const { gen, schema, data, allErrors, opts, self } = it;
+    const { RULES } = self;
+    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
+        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
+        return;
+    }
+    if (!opts.jtd)
+        checkStrictTypes(it, types);
+    gen.block(() => {
+        for (const group of RULES.rules)
+            groupKeywords(group);
+        groupKeywords(RULES.post);
+    });
+    function groupKeywords(group) {
+        if (!(0, applicability_1.shouldUseGroup)(schema, group))
+            return;
+        if (group.type) {
+            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
+            iterateKeywords(it, group);
+            if (types.length === 1 && types[0] === group.type && typeErrors) {
+                gen.else();
+                (0, dataType_2.reportTypeError)(it);
+            }
+            gen.endIf();
+        }
+        else {
+            iterateKeywords(it, group);
+        }
+        // TODO make it "ok" call?
+        if (!allErrors)
+            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
+    }
+}
+function iterateKeywords(it, group) {
+    const { gen, schema, opts: { useDefaults }, } = it;
+    if (useDefaults)
+        (0, defaults_1.assignDefaults)(it, group.type);
+    gen.block(() => {
+        for (const rule of group.rules) {
+            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
+                keywordCode(it, rule.keyword, rule.definition, group.type);
+            }
+        }
+    });
+}
+function checkStrictTypes(it, types) {
+    if (it.schemaEnv.meta || !it.opts.strictTypes)
+        return;
+    checkContextTypes(it, types);
+    if (!it.opts.allowUnionTypes)
+        checkMultipleTypes(it, types);
+    checkKeywordTypes(it, it.dataTypes);
+}
+function checkContextTypes(it, types) {
+    if (!types.length)
+        return;
+    if (!it.dataTypes.length) {
+        it.dataTypes = types;
+        return;
+    }
+    types.forEach((t) => {
+        if (!includesType(it.dataTypes, t)) {
+            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
+        }
+    });
+    narrowSchemaTypes(it, types);
+}
+function checkMultipleTypes(it, ts) {
+    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
+        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
+    }
+}
+function checkKeywordTypes(it, ts) {
+    const rules = it.self.RULES.all;
+    for (const keyword in rules) {
+        const rule = rules[keyword];
+        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
+            const { type } = rule.definition;
+            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
+                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
+            }
+        }
+    }
+}
+function hasApplicableType(schTs, kwdT) {
+    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
+}
+function includesType(ts, t) {
+    return ts.includes(t) || (t === "integer" && ts.includes("number"));
+}
+function narrowSchemaTypes(it, withTypes) {
+    const ts = [];
+    for (const t of it.dataTypes) {
+        if (includesType(withTypes, t))
+            ts.push(t);
+        else if (withTypes.includes("integer") && t === "number")
+            ts.push("integer");
+    }
+    it.dataTypes = ts;
+}
+function strictTypesError(it, msg) {
+    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
+    msg += ` at "${schemaPath}" (strictTypes)`;
+    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
+}
+class KeywordCxt {
+    constructor(it, def, keyword) {
+        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
+        this.gen = it.gen;
+        this.allErrors = it.allErrors;
+        this.keyword = keyword;
+        this.data = it.data;
+        this.schema = it.schema[keyword];
+        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
+        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
+        this.schemaType = def.schemaType;
+        this.parentSchema = it.schema;
+        this.params = {};
+        this.it = it;
+        this.def = def;
+        if (this.$data) {
+            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
+        }
+        else {
+            this.schemaCode = this.schemaValue;
+            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
+                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
+            }
+        }
+        if ("code" in def ? def.trackErrors : def.errors !== false) {
+            this.errsCount = it.gen.const("_errs", names_1.default.errors);
+        }
+    }
+    result(condition, successAction, failAction) {
+        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
+    }
+    failResult(condition, successAction, failAction) {
+        this.gen.if(condition);
+        if (failAction)
+            failAction();
+        else
+            this.error();
+        if (successAction) {
+            this.gen.else();
+            successAction();
+            if (this.allErrors)
+                this.gen.endIf();
+        }
+        else {
+            if (this.allErrors)
+                this.gen.endIf();
+            else
+                this.gen.else();
+        }
+    }
+    pass(condition, failAction) {
+        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
+    }
+    fail(condition) {
+        if (condition === undefined) {
+            this.error();
+            if (!this.allErrors)
+                this.gen.if(false); // this branch will be removed by gen.optimize
+            return;
+        }
+        this.gen.if(condition);
+        this.error();
+        if (this.allErrors)
+            this.gen.endIf();
+        else
+            this.gen.else();
+    }
+    fail$data(condition) {
+        if (!this.$data)
+            return this.fail(condition);
+        const { schemaCode } = this;
+        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
+    }
+    error(append, errorParams, errorPaths) {
+        if (errorParams) {
+            this.setParams(errorParams);
+            this._error(append, errorPaths);
+            this.setParams({});
+            return;
+        }
+        this._error(append, errorPaths);
+    }
+    _error(append, errorPaths) {
+        ;
+        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
+    }
+    $dataError() {
+        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
+    }
+    reset() {
+        if (this.errsCount === undefined)
+            throw new Error('add "trackErrors" to keyword definition');
+        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
+    }
+    ok(cond) {
+        if (!this.allErrors)
+            this.gen.if(cond);
+    }
+    setParams(obj, assign) {
+        if (assign)
+            Object.assign(this.params, obj);
+        else
+            this.params = obj;
+    }
+    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
+        this.gen.block(() => {
+            this.check$data(valid, $dataValid);
+            codeBlock();
+        });
+    }
+    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
+        if (!this.$data)
+            return;
+        const { gen, schemaCode, schemaType, def } = this;
+        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
+        if (valid !== codegen_1.nil)
+            gen.assign(valid, true);
+        if (schemaType.length || def.validateSchema) {
+            gen.elseIf(this.invalid$data());
+            this.$dataError();
+            if (valid !== codegen_1.nil)
+                gen.assign(valid, false);
+        }
+        gen.else();
+    }
+    invalid$data() {
+        const { gen, schemaCode, schemaType, def, it } = this;
+        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
+        function wrong$DataType() {
+            if (schemaType.length) {
+                /* istanbul ignore if */
+                if (!(schemaCode instanceof codegen_1.Name))
+                    throw new Error("ajv implementation error");
+                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
+                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
+            }
+            return codegen_1.nil;
+        }
+        function invalid$DataSchema() {
+            if (def.validateSchema) {
+                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
+                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
+            }
+            return codegen_1.nil;
+        }
+    }
+    subschema(appl, valid) {
+        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
+        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
+        (0, subschema_1.extendSubschemaMode)(subschema, appl);
+        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
+        subschemaCode(nextContext, valid);
+        return nextContext;
+    }
+    mergeEvaluated(schemaCxt, toName) {
+        const { it, gen } = this;
+        if (!it.opts.unevaluated)
+            return;
+        if (it.props !== true && schemaCxt.props !== undefined) {
+            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
+        }
+        if (it.items !== true && schemaCxt.items !== undefined) {
+            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
+        }
+    }
+    mergeValidEvaluated(schemaCxt, valid) {
+        const { it, gen } = this;
+        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
+            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
+            return true;
+        }
+    }
+}
+exports.KeywordCxt = KeywordCxt;
+function keywordCode(it, keyword, def, ruleType) {
+    const cxt = new KeywordCxt(it, def, keyword);
+    if ("code" in def) {
+        def.code(cxt, ruleType);
+    }
+    else if (cxt.$data && def.validate) {
+        (0, keyword_1.funcKeywordCode)(cxt, def);
+    }
+    else if ("macro" in def) {
+        (0, keyword_1.macroKeywordCode)(cxt, def);
+    }
+    else if (def.compile || def.validate) {
+        (0, keyword_1.funcKeywordCode)(cxt, def);
+    }
+}
+const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
+const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
+function getData($data, { dataLevel, dataNames, dataPathArr }) {
+    let jsonPointer;
+    let data;
+    if ($data === "")
+        return names_1.default.rootData;
+    if ($data[0] === "/") {
+        if (!JSON_POINTER.test($data))
+            throw new Error(`Invalid JSON-pointer: ${$data}`);
+        jsonPointer = $data;
+        data = names_1.default.rootData;
+    }
+    else {
+        const matches = RELATIVE_JSON_POINTER.exec($data);
+        if (!matches)
+            throw new Error(`Invalid JSON-pointer: ${$data}`);
+        const up = +matches[1];
+        jsonPointer = matches[2];
+        if (jsonPointer === "#") {
+            if (up >= dataLevel)
+                throw new Error(errorMsg("property/index", up));
+            return dataPathArr[dataLevel - up];
+        }
+        if (up > dataLevel)
+            throw new Error(errorMsg("data", up));
+        data = dataNames[dataLevel - up];
+        if (!jsonPointer)
+            return data;
+    }
+    let expr = data;
+    const segments = jsonPointer.split("/");
+    for (const segment of segments) {
+        if (segment) {
+            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
+            expr = (0, codegen_1._) `${expr} && ${data}`;
+        }
+    }
+    return expr;
+    function errorMsg(pointerType, up) {
+        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
+    }
+}
+exports.getData = getData;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/keyword.js b/node_modules/ajv/dist/compile/validate/keyword.js
index 1109d3a..a524f28 100644
--- a/node_modules/ajv/dist/compile/validate/keyword.js
+++ b/node_modules/ajv/dist/compile/validate/keyword.js
@@ -121,4 +121,3 @@ function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keywor
     }
 }
 exports.validateKeywordUsage = validateKeywordUsage;
-//# sourceMappingURL=keyword.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/keyword.js.bak b/node_modules/ajv/dist/compile/validate/keyword.js.bak
new file mode 100644
index 0000000..1109d3a
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/keyword.js.bak
@@ -0,0 +1,124 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
+const codegen_1 = require("../codegen");
+const names_1 = require("../names");
+const code_1 = require("../../vocabularies/code");
+const errors_1 = require("../errors");
+function macroKeywordCode(cxt, def) {
+    const { gen, keyword, schema, parentSchema, it } = cxt;
+    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
+    const schemaRef = useKeyword(gen, keyword, macroSchema);
+    if (it.opts.validateSchema !== false)
+        it.self.validateSchema(macroSchema, true);
+    const valid = gen.name("valid");
+    cxt.subschema({
+        schema: macroSchema,
+        schemaPath: codegen_1.nil,
+        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
+        topSchemaRef: schemaRef,
+        compositeRule: true,
+    }, valid);
+    cxt.pass(valid, () => cxt.error(true));
+}
+exports.macroKeywordCode = macroKeywordCode;
+function funcKeywordCode(cxt, def) {
+    var _a;
+    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
+    checkAsyncKeyword(it, def);
+    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
+    const validateRef = useKeyword(gen, keyword, validate);
+    const valid = gen.let("valid");
+    cxt.block$data(valid, validateKeyword);
+    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
+    function validateKeyword() {
+        if (def.errors === false) {
+            assignValid();
+            if (def.modifying)
+                modifyData(cxt);
+            reportErrs(() => cxt.error());
+        }
+        else {
+            const ruleErrs = def.async ? validateAsync() : validateSync();
+            if (def.modifying)
+                modifyData(cxt);
+            reportErrs(() => addErrs(cxt, ruleErrs));
+        }
+    }
+    function validateAsync() {
+        const ruleErrs = gen.let("ruleErrs", null);
+        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
+        return ruleErrs;
+    }
+    function validateSync() {
+        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
+        gen.assign(validateErrs, null);
+        assignValid(codegen_1.nil);
+        return validateErrs;
+    }
+    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
+        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
+        const passSchema = !(("compile" in def && !$data) || def.schema === false);
+        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
+    }
+    function reportErrs(errors) {
+        var _a;
+        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
+    }
+}
+exports.funcKeywordCode = funcKeywordCode;
+function modifyData(cxt) {
+    const { gen, data, it } = cxt;
+    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
+}
+function addErrs(cxt, errs) {
+    const { gen } = cxt;
+    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
+        gen
+            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
+            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
+        (0, errors_1.extendErrors)(cxt);
+    }, () => cxt.error());
+}
+function checkAsyncKeyword({ schemaEnv }, def) {
+    if (def.async && !schemaEnv.$async)
+        throw new Error("async keyword in sync schema");
+}
+function useKeyword(gen, keyword, result) {
+    if (result === undefined)
+        throw new Error(`keyword "${keyword}" failed to compile`);
+    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
+}
+function validSchemaType(schema, schemaType, allowUndefined = false) {
+    // TODO add tests
+    return (!schemaType.length ||
+        schemaType.some((st) => st === "array"
+            ? Array.isArray(schema)
+            : st === "object"
+                ? schema && typeof schema == "object" && !Array.isArray(schema)
+                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
+}
+exports.validSchemaType = validSchemaType;
+function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
+    /* istanbul ignore if */
+    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
+        throw new Error("ajv implementation error");
+    }
+    const deps = def.dependencies;
+    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
+        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
+    }
+    if (def.validateSchema) {
+        const valid = def.validateSchema(schema[keyword]);
+        if (!valid) {
+            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
+                self.errorsText(def.validateSchema.errors);
+            if (opts.validateSchema === "log")
+                self.logger.error(msg);
+            else
+                throw new Error(msg);
+        }
+    }
+}
+exports.validateKeywordUsage = validateKeywordUsage;
+//# sourceMappingURL=keyword.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/subschema.js b/node_modules/ajv/dist/compile/validate/subschema.js
index 9de2828..99d3cab 100644
--- a/node_modules/ajv/dist/compile/validate/subschema.js
+++ b/node_modules/ajv/dist/compile/validate/subschema.js
@@ -78,4 +78,3 @@ function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, composi
     subschema.jtdMetadata = jtdMetadata; // not inherited
 }
 exports.extendSubschemaMode = extendSubschemaMode;
-//# sourceMappingURL=subschema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/compile/validate/subschema.js.bak b/node_modules/ajv/dist/compile/validate/subschema.js.bak
new file mode 100644
index 0000000..9de2828
--- /dev/null
+++ b/node_modules/ajv/dist/compile/validate/subschema.js.bak
@@ -0,0 +1,81 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
+const codegen_1 = require("../codegen");
+const util_1 = require("../util");
+function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
+    if (keyword !== undefined && schema !== undefined) {
+        throw new Error('both "keyword" and "schema" passed, only one allowed');
+    }
+    if (keyword !== undefined) {
+        const sch = it.schema[keyword];
+        return schemaProp === undefined
+            ? {
+                schema: sch,
+                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
+                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
+            }
+            : {
+                schema: sch[schemaProp],
+                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
+                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
+            };
+    }
+    if (schema !== undefined) {
+        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
+            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
+        }
+        return {
+            schema,
+            schemaPath,
+            topSchemaRef,
+            errSchemaPath,
+        };
+    }
+    throw new Error('either "keyword" or "schema" must be passed');
+}
+exports.getSubschema = getSubschema;
+function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
+    if (data !== undefined && dataProp !== undefined) {
+        throw new Error('both "data" and "dataProp" passed, only one allowed');
+    }
+    const { gen } = it;
+    if (dataProp !== undefined) {
+        const { errorPath, dataPathArr, opts } = it;
+        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
+        dataContextProps(nextData);
+        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
+        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
+        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
+    }
+    if (data !== undefined) {
+        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
+        dataContextProps(nextData);
+        if (propertyName !== undefined)
+            subschema.propertyName = propertyName;
+        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
+    }
+    if (dataTypes)
+        subschema.dataTypes = dataTypes;
+    function dataContextProps(_nextData) {
+        subschema.data = _nextData;
+        subschema.dataLevel = it.dataLevel + 1;
+        subschema.dataTypes = [];
+        it.definedProperties = new Set();
+        subschema.parentData = it.data;
+        subschema.dataNames = [...it.dataNames, _nextData];
+    }
+}
+exports.extendSubschemaData = extendSubschemaData;
+function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
+    if (compositeRule !== undefined)
+        subschema.compositeRule = compositeRule;
+    if (createErrors !== undefined)
+        subschema.createErrors = createErrors;
+    if (allErrors !== undefined)
+        subschema.allErrors = allErrors;
+    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
+    subschema.jtdMetadata = jtdMetadata; // not inherited
+}
+exports.extendSubschemaMode = extendSubschemaMode;
+//# sourceMappingURL=subschema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/core.js b/node_modules/ajv/dist/core.js
index 8491116..f1413ed 100644
--- a/node_modules/ajv/dist/core.js
+++ b/node_modules/ajv/dist/core.js
@@ -614,4 +614,3 @@ const $dataRef = {
 function schemaOrData(schema) {
     return { anyOf: [schema, $dataRef] };
 }
-//# sourceMappingURL=core.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/core.js.bak b/node_modules/ajv/dist/core.js.bak
new file mode 100644
index 0000000..f1413ed
--- /dev/null
+++ b/node_modules/ajv/dist/core.js.bak
@@ -0,0 +1,616 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
+var validate_1 = require("./compile/validate");
+Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
+var codegen_1 = require("./compile/codegen");
+Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
+Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
+Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
+Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
+Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
+Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
+const validation_error_1 = require("./runtime/validation_error");
+const ref_error_1 = require("./compile/ref_error");
+const rules_1 = require("./compile/rules");
+const compile_1 = require("./compile");
+const codegen_2 = require("./compile/codegen");
+const resolve_1 = require("./compile/resolve");
+const dataType_1 = require("./compile/validate/dataType");
+const util_1 = require("./compile/util");
+const $dataRefSchema = require("./refs/data.json");
+const uri_1 = require("./runtime/uri");
+const defaultRegExp = (str, flags) => new RegExp(str, flags);
+defaultRegExp.code = "new RegExp";
+const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
+const EXT_SCOPE_NAMES = new Set([
+    "validate",
+    "serialize",
+    "parse",
+    "wrapper",
+    "root",
+    "schema",
+    "keyword",
+    "pattern",
+    "formats",
+    "validate$data",
+    "func",
+    "obj",
+    "Error",
+]);
+const removedOptions = {
+    errorDataPath: "",
+    format: "`validateFormats: false` can be used instead.",
+    nullable: '"nullable" keyword is supported by default.',
+    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
+    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
+    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
+    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
+    sourceCode: "Use option `code: {source: true}`",
+    strictDefaults: "It is default now, see option `strict`.",
+    strictKeywords: "It is default now, see option `strict`.",
+    uniqueItems: '"uniqueItems" keyword is always validated.',
+    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
+    cache: "Map is used as cache, schema object as key.",
+    serialize: "Map is used as cache, schema object as key.",
+    ajvErrors: "It is default now.",
+};
+const deprecatedOptions = {
+    ignoreKeywordsWithRef: "",
+    jsPropertySyntax: "",
+    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
+};
+const MAX_EXPRESSION = 200;
+// eslint-disable-next-line complexity
+function requiredOptions(o) {
+    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
+    const s = o.strict;
+    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
+    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
+    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
+    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
+    return {
+        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
+        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
+        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
+        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
+        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
+        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
+        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
+        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
+        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
+        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
+        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
+        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
+        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
+        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
+        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
+        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
+        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
+        uriResolver: uriResolver,
+    };
+}
+class Ajv {
+    constructor(opts = {}) {
+        this.schemas = {};
+        this.refs = {};
+        this.formats = {};
+        this._compilations = new Set();
+        this._loading = {};
+        this._cache = new Map();
+        opts = this.opts = { ...opts, ...requiredOptions(opts) };
+        const { es5, lines } = this.opts.code;
+        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
+        this.logger = getLogger(opts.logger);
+        const formatOpt = opts.validateFormats;
+        opts.validateFormats = false;
+        this.RULES = (0, rules_1.getRules)();
+        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
+        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
+        this._metaOpts = getMetaSchemaOptions.call(this);
+        if (opts.formats)
+            addInitialFormats.call(this);
+        this._addVocabularies();
+        this._addDefaultMetaSchema();
+        if (opts.keywords)
+            addInitialKeywords.call(this, opts.keywords);
+        if (typeof opts.meta == "object")
+            this.addMetaSchema(opts.meta);
+        addInitialSchemas.call(this);
+        opts.validateFormats = formatOpt;
+    }
+    _addVocabularies() {
+        this.addKeyword("$async");
+    }
+    _addDefaultMetaSchema() {
+        const { $data, meta, schemaId } = this.opts;
+        let _dataRefSchema = $dataRefSchema;
+        if (schemaId === "id") {
+            _dataRefSchema = { ...$dataRefSchema };
+            _dataRefSchema.id = _dataRefSchema.$id;
+            delete _dataRefSchema.$id;
+        }
+        if (meta && $data)
+            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
+    }
+    defaultMeta() {
+        const { meta, schemaId } = this.opts;
+        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
+    }
+    validate(schemaKeyRef, // key, ref or schema object
+    data // to be validated
+    ) {
+        let v;
+        if (typeof schemaKeyRef == "string") {
+            v = this.getSchema(schemaKeyRef);
+            if (!v)
+                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
+        }
+        else {
+            v = this.compile(schemaKeyRef);
+        }
+        const valid = v(data);
+        if (!("$async" in v))
+            this.errors = v.errors;
+        return valid;
+    }
+    compile(schema, _meta) {
+        const sch = this._addSchema(schema, _meta);
+        return (sch.validate || this._compileSchemaEnv(sch));
+    }
+    compileAsync(schema, meta) {
+        if (typeof this.opts.loadSchema != "function") {
+            throw new Error("options.loadSchema should be a function");
+        }
+        const { loadSchema } = this.opts;
+        return runCompileAsync.call(this, schema, meta);
+        async function runCompileAsync(_schema, _meta) {
+            await loadMetaSchema.call(this, _schema.$schema);
+            const sch = this._addSchema(_schema, _meta);
+            return sch.validate || _compileAsync.call(this, sch);
+        }
+        async function loadMetaSchema($ref) {
+            if ($ref && !this.getSchema($ref)) {
+                await runCompileAsync.call(this, { $ref }, true);
+            }
+        }
+        async function _compileAsync(sch) {
+            try {
+                return this._compileSchemaEnv(sch);
+            }
+            catch (e) {
+                if (!(e instanceof ref_error_1.default))
+                    throw e;
+                checkLoaded.call(this, e);
+                await loadMissingSchema.call(this, e.missingSchema);
+                return _compileAsync.call(this, sch);
+            }
+        }
+        function checkLoaded({ missingSchema: ref, missingRef }) {
+            if (this.refs[ref]) {
+                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
+            }
+        }
+        async function loadMissingSchema(ref) {
+            const _schema = await _loadSchema.call(this, ref);
+            if (!this.refs[ref])
+                await loadMetaSchema.call(this, _schema.$schema);
+            if (!this.refs[ref])
+                this.addSchema(_schema, ref, meta);
+        }
+        async function _loadSchema(ref) {
+            const p = this._loading[ref];
+            if (p)
+                return p;
+            try {
+                return await (this._loading[ref] = loadSchema(ref));
+            }
+            finally {
+                delete this._loading[ref];
+            }
+        }
+    }
+    // Adds schema to the instance
+    addSchema(schema, // If array is passed, `key` will be ignored
+    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
+    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
+    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
+    ) {
+        if (Array.isArray(schema)) {
+            for (const sch of schema)
+                this.addSchema(sch, undefined, _meta, _validateSchema);
+            return this;
+        }
+        let id;
+        if (typeof schema === "object") {
+            const { schemaId } = this.opts;
+            id = schema[schemaId];
+            if (id !== undefined && typeof id != "string") {
+                throw new Error(`schema ${schemaId} must be string`);
+            }
+        }
+        key = (0, resolve_1.normalizeId)(key || id);
+        this._checkUnique(key);
+        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
+        return this;
+    }
+    // Add schema that will be used to validate other schemas
+    // options in META_IGNORE_OPTIONS are alway set to false
+    addMetaSchema(schema, key, // schema key
+    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
+    ) {
+        this.addSchema(schema, key, true, _validateSchema);
+        return this;
+    }
+    //  Validate schema against its meta-schema
+    validateSchema(schema, throwOrLogError) {
+        if (typeof schema == "boolean")
+            return true;
+        let $schema;
+        $schema = schema.$schema;
+        if ($schema !== undefined && typeof $schema != "string") {
+            throw new Error("$schema must be a string");
+        }
+        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
+        if (!$schema) {
+            this.logger.warn("meta-schema not available");
+            this.errors = null;
+            return true;
+        }
+        const valid = this.validate($schema, schema);
+        if (!valid && throwOrLogError) {
+            const message = "schema is invalid: " + this.errorsText();
+            if (this.opts.validateSchema === "log")
+                this.logger.error(message);
+            else
+                throw new Error(message);
+        }
+        return valid;
+    }
+    // Get compiled schema by `key` or `ref`.
+    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
+    getSchema(keyRef) {
+        let sch;
+        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
+            keyRef = sch;
+        if (sch === undefined) {
+            const { schemaId } = this.opts;
+            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
+            sch = compile_1.resolveSchema.call(this, root, keyRef);
+            if (!sch)
+                return;
+            this.refs[keyRef] = sch;
+        }
+        return (sch.validate || this._compileSchemaEnv(sch));
+    }
+    // Remove cached schema(s).
+    // If no parameter is passed all schemas but meta-schemas are removed.
+    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
+    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
+    removeSchema(schemaKeyRef) {
+        if (schemaKeyRef instanceof RegExp) {
+            this._removeAllSchemas(this.schemas, schemaKeyRef);
+            this._removeAllSchemas(this.refs, schemaKeyRef);
+            return this;
+        }
+        switch (typeof schemaKeyRef) {
+            case "undefined":
+                this._removeAllSchemas(this.schemas);
+                this._removeAllSchemas(this.refs);
+                this._cache.clear();
+                return this;
+            case "string": {
+                const sch = getSchEnv.call(this, schemaKeyRef);
+                if (typeof sch == "object")
+                    this._cache.delete(sch.schema);
+                delete this.schemas[schemaKeyRef];
+                delete this.refs[schemaKeyRef];
+                return this;
+            }
+            case "object": {
+                const cacheKey = schemaKeyRef;
+                this._cache.delete(cacheKey);
+                let id = schemaKeyRef[this.opts.schemaId];
+                if (id) {
+                    id = (0, resolve_1.normalizeId)(id);
+                    delete this.schemas[id];
+                    delete this.refs[id];
+                }
+                return this;
+            }
+            default:
+                throw new Error("ajv.removeSchema: invalid parameter");
+        }
+    }
+    // add "vocabulary" - a collection of keywords
+    addVocabulary(definitions) {
+        for (const def of definitions)
+            this.addKeyword(def);
+        return this;
+    }
+    addKeyword(kwdOrDef, def // deprecated
+    ) {
+        let keyword;
+        if (typeof kwdOrDef == "string") {
+            keyword = kwdOrDef;
+            if (typeof def == "object") {
+                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
+                def.keyword = keyword;
+            }
+        }
+        else if (typeof kwdOrDef == "object" && def === undefined) {
+            def = kwdOrDef;
+            keyword = def.keyword;
+            if (Array.isArray(keyword) && !keyword.length) {
+                throw new Error("addKeywords: keyword must be string or non-empty array");
+            }
+        }
+        else {
+            throw new Error("invalid addKeywords parameters");
+        }
+        checkKeyword.call(this, keyword, def);
+        if (!def) {
+            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
+            return this;
+        }
+        keywordMetaschema.call(this, def);
+        const definition = {
+            ...def,
+            type: (0, dataType_1.getJSONTypes)(def.type),
+            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
+        };
+        (0, util_1.eachItem)(keyword, definition.type.length === 0
+            ? (k) => addRule.call(this, k, definition)
+            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
+        return this;
+    }
+    getKeyword(keyword) {
+        const rule = this.RULES.all[keyword];
+        return typeof rule == "object" ? rule.definition : !!rule;
+    }
+    // Remove keyword
+    removeKeyword(keyword) {
+        // TODO return type should be Ajv
+        const { RULES } = this;
+        delete RULES.keywords[keyword];
+        delete RULES.all[keyword];
+        for (const group of RULES.rules) {
+            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
+            if (i >= 0)
+                group.rules.splice(i, 1);
+        }
+        return this;
+    }
+    // Add format
+    addFormat(name, format) {
+        if (typeof format == "string")
+            format = new RegExp(format);
+        this.formats[name] = format;
+        return this;
+    }
+    errorsText(errors = this.errors, // optional array of validation errors
+    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
+    ) {
+        if (!errors || errors.length === 0)
+            return "No errors";
+        return errors
+            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
+            .reduce((text, msg) => text + separator + msg);
+    }
+    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
+        const rules = this.RULES.all;
+        metaSchema = JSON.parse(JSON.stringify(metaSchema));
+        for (const jsonPointer of keywordsJsonPointers) {
+            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
+            let keywords = metaSchema;
+            for (const seg of segments)
+                keywords = keywords[seg];
+            for (const key in rules) {
+                const rule = rules[key];
+                if (typeof rule != "object")
+                    continue;
+                const { $data } = rule.definition;
+                const schema = keywords[key];
+                if ($data && schema)
+                    keywords[key] = schemaOrData(schema);
+            }
+        }
+        return metaSchema;
+    }
+    _removeAllSchemas(schemas, regex) {
+        for (const keyRef in schemas) {
+            const sch = schemas[keyRef];
+            if (!regex || regex.test(keyRef)) {
+                if (typeof sch == "string") {
+                    delete schemas[keyRef];
+                }
+                else if (sch && !sch.meta) {
+                    this._cache.delete(sch.schema);
+                    delete schemas[keyRef];
+                }
+            }
+        }
+    }
+    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
+        let id;
+        const { schemaId } = this.opts;
+        if (typeof schema == "object") {
+            id = schema[schemaId];
+        }
+        else {
+            if (this.opts.jtd)
+                throw new Error("schema must be object");
+            else if (typeof schema != "boolean")
+                throw new Error("schema must be object or boolean");
+        }
+        let sch = this._cache.get(schema);
+        if (sch !== undefined)
+            return sch;
+        baseId = (0, resolve_1.normalizeId)(id || baseId);
+        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
+        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
+        this._cache.set(sch.schema, sch);
+        if (addSchema && !baseId.startsWith("#")) {
+            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
+            if (baseId)
+                this._checkUnique(baseId);
+            this.refs[baseId] = sch;
+        }
+        if (validateSchema)
+            this.validateSchema(schema, true);
+        return sch;
+    }
+    _checkUnique(id) {
+        if (this.schemas[id] || this.refs[id]) {
+            throw new Error(`schema with key or id "${id}" already exists`);
+        }
+    }
+    _compileSchemaEnv(sch) {
+        if (sch.meta)
+            this._compileMetaSchema(sch);
+        else
+            compile_1.compileSchema.call(this, sch);
+        /* istanbul ignore if */
+        if (!sch.validate)
+            throw new Error("ajv implementation error");
+        return sch.validate;
+    }
+    _compileMetaSchema(sch) {
+        const currentOpts = this.opts;
+        this.opts = this._metaOpts;
+        try {
+            compile_1.compileSchema.call(this, sch);
+        }
+        finally {
+            this.opts = currentOpts;
+        }
+    }
+}
+exports.default = Ajv;
+Ajv.ValidationError = validation_error_1.default;
+Ajv.MissingRefError = ref_error_1.default;
+function checkOptions(checkOpts, options, msg, log = "error") {
+    for (const key in checkOpts) {
+        const opt = key;
+        if (opt in options)
+            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
+    }
+}
+function getSchEnv(keyRef) {
+    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
+    return this.schemas[keyRef] || this.refs[keyRef];
+}
+function addInitialSchemas() {
+    const optsSchemas = this.opts.schemas;
+    if (!optsSchemas)
+        return;
+    if (Array.isArray(optsSchemas))
+        this.addSchema(optsSchemas);
+    else
+        for (const key in optsSchemas)
+            this.addSchema(optsSchemas[key], key);
+}
+function addInitialFormats() {
+    for (const name in this.opts.formats) {
+        const format = this.opts.formats[name];
+        if (format)
+            this.addFormat(name, format);
+    }
+}
+function addInitialKeywords(defs) {
+    if (Array.isArray(defs)) {
+        this.addVocabulary(defs);
+        return;
+    }
+    this.logger.warn("keywords option as map is deprecated, pass array");
+    for (const keyword in defs) {
+        const def = defs[keyword];
+        if (!def.keyword)
+            def.keyword = keyword;
+        this.addKeyword(def);
+    }
+}
+function getMetaSchemaOptions() {
+    const metaOpts = { ...this.opts };
+    for (const opt of META_IGNORE_OPTIONS)
+        delete metaOpts[opt];
+    return metaOpts;
+}
+const noLogs = { log() { }, warn() { }, error() { } };
+function getLogger(logger) {
+    if (logger === false)
+        return noLogs;
+    if (logger === undefined)
+        return console;
+    if (logger.log && logger.warn && logger.error)
+        return logger;
+    throw new Error("logger must implement log, warn and error methods");
+}
+const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
+function checkKeyword(keyword, def) {
+    const { RULES } = this;
+    (0, util_1.eachItem)(keyword, (kwd) => {
+        if (RULES.keywords[kwd])
+            throw new Error(`Keyword ${kwd} is already defined`);
+        if (!KEYWORD_NAME.test(kwd))
+            throw new Error(`Keyword ${kwd} has invalid name`);
+    });
+    if (!def)
+        return;
+    if (def.$data && !("code" in def || "validate" in def)) {
+        throw new Error('$data keyword must have "code" or "validate" function');
+    }
+}
+function addRule(keyword, definition, dataType) {
+    var _a;
+    const post = definition === null || definition === void 0 ? void 0 : definition.post;
+    if (dataType && post)
+        throw new Error('keyword with "post" flag cannot have "type"');
+    const { RULES } = this;
+    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
+    if (!ruleGroup) {
+        ruleGroup = { type: dataType, rules: [] };
+        RULES.rules.push(ruleGroup);
+    }
+    RULES.keywords[keyword] = true;
+    if (!definition)
+        return;
+    const rule = {
+        keyword,
+        definition: {
+            ...definition,
+            type: (0, dataType_1.getJSONTypes)(definition.type),
+            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
+        },
+    };
+    if (definition.before)
+        addBeforeRule.call(this, ruleGroup, rule, definition.before);
+    else
+        ruleGroup.rules.push(rule);
+    RULES.all[keyword] = rule;
+    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
+}
+function addBeforeRule(ruleGroup, rule, before) {
+    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
+    if (i >= 0) {
+        ruleGroup.rules.splice(i, 0, rule);
+    }
+    else {
+        ruleGroup.rules.push(rule);
+        this.logger.warn(`rule ${before} is not defined`);
+    }
+}
+function keywordMetaschema(def) {
+    let { metaSchema } = def;
+    if (metaSchema === undefined)
+        return;
+    if (def.$data && this.opts.$data)
+        metaSchema = schemaOrData(metaSchema);
+    def.validateSchema = this.compile(metaSchema, true);
+}
+const $dataRef = {
+    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
+};
+function schemaOrData(schema) {
+    return { anyOf: [schema, $dataRef] };
+}
diff --git a/node_modules/ajv/dist/jtd.js b/node_modules/ajv/dist/jtd.js
index b893879..8615b9c 100644
--- a/node_modules/ajv/dist/jtd.js
+++ b/node_modules/ajv/dist/jtd.js
@@ -67,4 +67,3 @@ var validation_error_1 = require("./runtime/validation_error");
 Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
 var ref_error_1 = require("./compile/ref_error");
 Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
-//# sourceMappingURL=jtd.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/jtd.js.bak b/node_modules/ajv/dist/jtd.js.bak
new file mode 100644
index 0000000..8615b9c
--- /dev/null
+++ b/node_modules/ajv/dist/jtd.js.bak
@@ -0,0 +1,69 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
+const core_1 = require("./core");
+const jtd_1 = require("./vocabularies/jtd");
+const jtd_schema_1 = require("./refs/jtd-schema");
+const serialize_1 = require("./compile/jtd/serialize");
+const parse_1 = require("./compile/jtd/parse");
+const META_SCHEMA_ID = "JTD-meta-schema";
+class Ajv extends core_1.default {
+    constructor(opts = {}) {
+        super({
+            ...opts,
+            jtd: true,
+        });
+    }
+    _addVocabularies() {
+        super._addVocabularies();
+        this.addVocabulary(jtd_1.default);
+    }
+    _addDefaultMetaSchema() {
+        super._addDefaultMetaSchema();
+        if (!this.opts.meta)
+            return;
+        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
+    }
+    defaultMeta() {
+        return (this.opts.defaultMeta =
+            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
+    }
+    compileSerializer(schema) {
+        const sch = this._addSchema(schema);
+        return sch.serialize || this._compileSerializer(sch);
+    }
+    compileParser(schema) {
+        const sch = this._addSchema(schema);
+        return (sch.parse || this._compileParser(sch));
+    }
+    _compileSerializer(sch) {
+        serialize_1.default.call(this, sch, sch.schema.definitions || {});
+        /* istanbul ignore if */
+        if (!sch.serialize)
+            throw new Error("ajv implementation error");
+        return sch.serialize;
+    }
+    _compileParser(sch) {
+        parse_1.default.call(this, sch, sch.schema.definitions || {});
+        /* istanbul ignore if */
+        if (!sch.parse)
+            throw new Error("ajv implementation error");
+        return sch.parse;
+    }
+}
+module.exports = exports = Ajv;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = Ajv;
+var validate_1 = require("./compile/validate");
+Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
+var codegen_1 = require("./compile/codegen");
+Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
+Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
+Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
+Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
+Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
+Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
+var validation_error_1 = require("./runtime/validation_error");
+Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
+var ref_error_1 = require("./compile/ref_error");
+Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
diff --git a/node_modules/ajv/dist/refs/json-schema-2019-09/index.js b/node_modules/ajv/dist/refs/json-schema-2019-09/index.js
index e864962..62a190d 100644
--- a/node_modules/ajv/dist/refs/json-schema-2019-09/index.js
+++ b/node_modules/ajv/dist/refs/json-schema-2019-09/index.js
@@ -25,4 +25,3 @@ function addMetaSchema2019($data) {
     }
 }
 exports.default = addMetaSchema2019;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/refs/json-schema-2019-09/index.js.bak b/node_modules/ajv/dist/refs/json-schema-2019-09/index.js.bak
new file mode 100644
index 0000000..e864962
--- /dev/null
+++ b/node_modules/ajv/dist/refs/json-schema-2019-09/index.js.bak
@@ -0,0 +1,28 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const metaSchema = require("./schema.json");
+const applicator = require("./meta/applicator.json");
+const content = require("./meta/content.json");
+const core = require("./meta/core.json");
+const format = require("./meta/format.json");
+const metadata = require("./meta/meta-data.json");
+const validation = require("./meta/validation.json");
+const META_SUPPORT_DATA = ["/properties"];
+function addMetaSchema2019($data) {
+    ;
+    [
+        metaSchema,
+        applicator,
+        content,
+        core,
+        with$data(this, format),
+        metadata,
+        with$data(this, validation),
+    ].forEach((sch) => this.addMetaSchema(sch, undefined, false));
+    return this;
+    function with$data(ajv, sch) {
+        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
+    }
+}
+exports.default = addMetaSchema2019;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/refs/json-schema-2020-12/index.js b/node_modules/ajv/dist/refs/json-schema-2020-12/index.js
index d925675..fd31514 100644
--- a/node_modules/ajv/dist/refs/json-schema-2020-12/index.js
+++ b/node_modules/ajv/dist/refs/json-schema-2020-12/index.js
@@ -27,4 +27,3 @@ function addMetaSchema2020($data) {
     }
 }
 exports.default = addMetaSchema2020;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/refs/json-schema-2020-12/index.js.bak b/node_modules/ajv/dist/refs/json-schema-2020-12/index.js.bak
new file mode 100644
index 0000000..d925675
--- /dev/null
+++ b/node_modules/ajv/dist/refs/json-schema-2020-12/index.js.bak
@@ -0,0 +1,30 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const metaSchema = require("./schema.json");
+const applicator = require("./meta/applicator.json");
+const unevaluated = require("./meta/unevaluated.json");
+const content = require("./meta/content.json");
+const core = require("./meta/core.json");
+const format = require("./meta/format-annotation.json");
+const metadata = require("./meta/meta-data.json");
+const validation = require("./meta/validation.json");
+const META_SUPPORT_DATA = ["/properties"];
+function addMetaSchema2020($data) {
+    ;
+    [
+        metaSchema,
+        applicator,
+        unevaluated,
+        content,
+        core,
+        with$data(this, format),
+        metadata,
+        with$data(this, validation),
+    ].forEach((sch) => this.addMetaSchema(sch, undefined, false));
+    return this;
+    function with$data(ajv, sch) {
+        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
+    }
+}
+exports.default = addMetaSchema2020;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/refs/jtd-schema.js b/node_modules/ajv/dist/refs/jtd-schema.js
index 1ee940a..4aa3765 100644
--- a/node_modules/ajv/dist/refs/jtd-schema.js
+++ b/node_modules/ajv/dist/refs/jtd-schema.js
@@ -115,4 +115,3 @@ const jtdMetaSchema = {
     ...schema(true),
 };
 exports.default = jtdMetaSchema;
-//# sourceMappingURL=jtd-schema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/refs/jtd-schema.js.bak b/node_modules/ajv/dist/refs/jtd-schema.js.bak
new file mode 100644
index 0000000..1ee940a
--- /dev/null
+++ b/node_modules/ajv/dist/refs/jtd-schema.js.bak
@@ -0,0 +1,118 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const shared = (root) => {
+    const sch = {
+        nullable: { type: "boolean" },
+        metadata: {
+            optionalProperties: {
+                union: { elements: { ref: "schema" } },
+            },
+            additionalProperties: true,
+        },
+    };
+    if (root)
+        sch.definitions = { values: { ref: "schema" } };
+    return sch;
+};
+const emptyForm = (root) => ({
+    optionalProperties: shared(root),
+});
+const refForm = (root) => ({
+    properties: {
+        ref: { type: "string" },
+    },
+    optionalProperties: shared(root),
+});
+const typeForm = (root) => ({
+    properties: {
+        type: {
+            enum: [
+                "boolean",
+                "timestamp",
+                "string",
+                "float32",
+                "float64",
+                "int8",
+                "uint8",
+                "int16",
+                "uint16",
+                "int32",
+                "uint32",
+            ],
+        },
+    },
+    optionalProperties: shared(root),
+});
+const enumForm = (root) => ({
+    properties: {
+        enum: { elements: { type: "string" } },
+    },
+    optionalProperties: shared(root),
+});
+const elementsForm = (root) => ({
+    properties: {
+        elements: { ref: "schema" },
+    },
+    optionalProperties: shared(root),
+});
+const propertiesForm = (root) => ({
+    properties: {
+        properties: { values: { ref: "schema" } },
+    },
+    optionalProperties: {
+        optionalProperties: { values: { ref: "schema" } },
+        additionalProperties: { type: "boolean" },
+        ...shared(root),
+    },
+});
+const optionalPropertiesForm = (root) => ({
+    properties: {
+        optionalProperties: { values: { ref: "schema" } },
+    },
+    optionalProperties: {
+        additionalProperties: { type: "boolean" },
+        ...shared(root),
+    },
+});
+const discriminatorForm = (root) => ({
+    properties: {
+        discriminator: { type: "string" },
+        mapping: {
+            values: {
+                metadata: {
+                    union: [propertiesForm(false), optionalPropertiesForm(false)],
+                },
+            },
+        },
+    },
+    optionalProperties: shared(root),
+});
+const valuesForm = (root) => ({
+    properties: {
+        values: { ref: "schema" },
+    },
+    optionalProperties: shared(root),
+});
+const schema = (root) => ({
+    metadata: {
+        union: [
+            emptyForm,
+            refForm,
+            typeForm,
+            enumForm,
+            elementsForm,
+            propertiesForm,
+            optionalPropertiesForm,
+            discriminatorForm,
+            valuesForm,
+        ].map((s) => s(root)),
+    },
+});
+const jtdMetaSchema = {
+    definitions: {
+        schema: schema(false),
+    },
+    ...schema(true),
+};
+exports.default = jtdMetaSchema;
+//# sourceMappingURL=jtd-schema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/equal.js b/node_modules/ajv/dist/runtime/equal.js
index 774bba0..03bb497 100644
--- a/node_modules/ajv/dist/runtime/equal.js
+++ b/node_modules/ajv/dist/runtime/equal.js
@@ -4,4 +4,3 @@ Object.defineProperty(exports, "__esModule", { value: true });
 const equal = require("fast-deep-equal");
 equal.code = 'require("ajv/dist/runtime/equal").default';
 exports.default = equal;
-//# sourceMappingURL=equal.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/equal.js.bak b/node_modules/ajv/dist/runtime/equal.js.bak
new file mode 100644
index 0000000..774bba0
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/equal.js.bak
@@ -0,0 +1,7 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+// https://github.com/ajv-validator/ajv/issues/889
+const equal = require("fast-deep-equal");
+equal.code = 'require("ajv/dist/runtime/equal").default';
+exports.default = equal;
+//# sourceMappingURL=equal.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/parseJson.js b/node_modules/ajv/dist/runtime/parseJson.js
index 7ebbc1b..fc533ab 100644
--- a/node_modules/ajv/dist/runtime/parseJson.js
+++ b/node_modules/ajv/dist/runtime/parseJson.js
@@ -181,4 +181,3 @@ exports.parseJsonString = parseJsonString;
 parseJsonString.message = undefined;
 parseJsonString.position = 0;
 parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
-//# sourceMappingURL=parseJson.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/parseJson.js.bak b/node_modules/ajv/dist/runtime/parseJson.js.bak
new file mode 100644
index 0000000..7ebbc1b
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/parseJson.js.bak
@@ -0,0 +1,184 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.parseJsonString = exports.parseJsonNumber = exports.parseJson = void 0;
+const rxParseJson = /position\s(\d+)$/;
+function parseJson(s, pos) {
+    let endPos;
+    parseJson.message = undefined;
+    let matches;
+    if (pos)
+        s = s.slice(pos);
+    try {
+        parseJson.position = pos + s.length;
+        return JSON.parse(s);
+    }
+    catch (e) {
+        matches = rxParseJson.exec(e.message);
+        if (!matches) {
+            parseJson.message = "unexpected end";
+            return undefined;
+        }
+        endPos = +matches[1];
+        const c = s[endPos];
+        s = s.slice(0, endPos);
+        parseJson.position = pos + endPos;
+        try {
+            return JSON.parse(s);
+        }
+        catch (e1) {
+            parseJson.message = `unexpected token ${c}`;
+            return undefined;
+        }
+    }
+}
+exports.parseJson = parseJson;
+parseJson.message = undefined;
+parseJson.position = 0;
+parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
+function parseJsonNumber(s, pos, maxDigits) {
+    let numStr = "";
+    let c;
+    parseJsonNumber.message = undefined;
+    if (s[pos] === "-") {
+        numStr += "-";
+        pos++;
+    }
+    if (s[pos] === "0") {
+        numStr += "0";
+        pos++;
+    }
+    else {
+        if (!parseDigits(maxDigits)) {
+            errorMessage();
+            return undefined;
+        }
+    }
+    if (maxDigits) {
+        parseJsonNumber.position = pos;
+        return +numStr;
+    }
+    if (s[pos] === ".") {
+        numStr += ".";
+        pos++;
+        if (!parseDigits()) {
+            errorMessage();
+            return undefined;
+        }
+    }
+    if (((c = s[pos]), c === "e" || c === "E")) {
+        numStr += "e";
+        pos++;
+        if (((c = s[pos]), c === "+" || c === "-")) {
+            numStr += c;
+            pos++;
+        }
+        if (!parseDigits()) {
+            errorMessage();
+            return undefined;
+        }
+    }
+    parseJsonNumber.position = pos;
+    return +numStr;
+    function parseDigits(maxLen) {
+        let digit = false;
+        while (((c = s[pos]), c >= "0" && c <= "9" && (maxLen === undefined || maxLen-- > 0))) {
+            digit = true;
+            numStr += c;
+            pos++;
+        }
+        return digit;
+    }
+    function errorMessage() {
+        parseJsonNumber.position = pos;
+        parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
+    }
+}
+exports.parseJsonNumber = parseJsonNumber;
+parseJsonNumber.message = undefined;
+parseJsonNumber.position = 0;
+parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
+const escapedChars = {
+    b: "\b",
+    f: "\f",
+    n: "\n",
+    r: "\r",
+    t: "\t",
+    '"': '"',
+    "/": "/",
+    "\\": "\\",
+};
+const CODE_A = "a".charCodeAt(0);
+const CODE_0 = "0".charCodeAt(0);
+function parseJsonString(s, pos) {
+    let str = "";
+    let c;
+    parseJsonString.message = undefined;
+    // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition
+    while (true) {
+        c = s[pos++];
+        if (c === '"')
+            break;
+        if (c === "\\") {
+            c = s[pos];
+            if (c in escapedChars) {
+                str += escapedChars[c];
+                pos++;
+            }
+            else if (c === "u") {
+                pos++;
+                let count = 4;
+                let code = 0;
+                while (count--) {
+                    code <<= 4;
+                    c = s[pos];
+                    if (c === undefined) {
+                        errorMessage("unexpected end");
+                        return undefined;
+                    }
+                    c = c.toLowerCase();
+                    if (c >= "a" && c <= "f") {
+                        code += c.charCodeAt(0) - CODE_A + 10;
+                    }
+                    else if (c >= "0" && c <= "9") {
+                        code += c.charCodeAt(0) - CODE_0;
+                    }
+                    else {
+                        errorMessage(`unexpected token ${c}`);
+                        return undefined;
+                    }
+                    pos++;
+                }
+                str += String.fromCharCode(code);
+            }
+            else {
+                errorMessage(`unexpected token ${c}`);
+                return undefined;
+            }
+            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+        }
+        else if (c === undefined) {
+            errorMessage("unexpected end");
+            return undefined;
+        }
+        else {
+            if (c.charCodeAt(0) >= 0x20) {
+                str += c;
+            }
+            else {
+                errorMessage(`unexpected token ${c}`);
+                return undefined;
+            }
+        }
+    }
+    parseJsonString.position = pos;
+    return str;
+    function errorMessage(msg) {
+        parseJsonString.position = pos;
+        parseJsonString.message = msg;
+    }
+}
+exports.parseJsonString = parseJsonString;
+parseJsonString.message = undefined;
+parseJsonString.position = 0;
+parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
+//# sourceMappingURL=parseJson.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/quote.js b/node_modules/ajv/dist/runtime/quote.js
index ebf78f7..a888a1d 100644
--- a/node_modules/ajv/dist/runtime/quote.js
+++ b/node_modules/ajv/dist/runtime/quote.js
@@ -27,4 +27,3 @@ function quote(s) {
 }
 exports.default = quote;
 quote.code = 'require("ajv/dist/runtime/quote").default';
-//# sourceMappingURL=quote.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/quote.js.bak b/node_modules/ajv/dist/runtime/quote.js.bak
new file mode 100644
index 0000000..ebf78f7
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/quote.js.bak
@@ -0,0 +1,30 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const rxEscapable = 
+// eslint-disable-next-line no-control-regex, no-misleading-character-class
+/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
+const escaped = {
+    "\b": "\\b",
+    "\t": "\\t",
+    "\n": "\\n",
+    "\f": "\\f",
+    "\r": "\\r",
+    '"': '\\"',
+    "\\": "\\\\",
+};
+function quote(s) {
+    rxEscapable.lastIndex = 0;
+    return ('"' +
+        (rxEscapable.test(s)
+            ? s.replace(rxEscapable, (a) => {
+                const c = escaped[a];
+                return typeof c === "string"
+                    ? c
+                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
+            })
+            : s) +
+        '"');
+}
+exports.default = quote;
+quote.code = 'require("ajv/dist/runtime/quote").default';
+//# sourceMappingURL=quote.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/re2.js b/node_modules/ajv/dist/runtime/re2.js
index 4b1ee25..7b91cca 100644
--- a/node_modules/ajv/dist/runtime/re2.js
+++ b/node_modules/ajv/dist/runtime/re2.js
@@ -3,4 +3,3 @@ Object.defineProperty(exports, "__esModule", { value: true });
 const re2 = require("re2");
 re2.code = 'require("ajv/dist/runtime/re2").default';
 exports.default = re2;
-//# sourceMappingURL=re2.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/re2.js.bak b/node_modules/ajv/dist/runtime/re2.js.bak
new file mode 100644
index 0000000..4b1ee25
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/re2.js.bak
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const re2 = require("re2");
+re2.code = 'require("ajv/dist/runtime/re2").default';
+exports.default = re2;
+//# sourceMappingURL=re2.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/timestamp.js b/node_modules/ajv/dist/runtime/timestamp.js
index 5e0f065..9843c86 100644
--- a/node_modules/ajv/dist/runtime/timestamp.js
+++ b/node_modules/ajv/dist/runtime/timestamp.js
@@ -39,4 +39,3 @@ function validTime(str) {
         (hr - tzH === 23 && min - tzM === 59 && sec === 60));
 }
 validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
-//# sourceMappingURL=timestamp.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/timestamp.js.bak b/node_modules/ajv/dist/runtime/timestamp.js.bak
new file mode 100644
index 0000000..5e0f065
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/timestamp.js.bak
@@ -0,0 +1,42 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const DT_SEPARATOR = /t|\s/i;
+const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
+const TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
+const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+function validTimestamp(str, allowDate) {
+    // http://tools.ietf.org/html/rfc3339#section-5.6
+    const dt = str.split(DT_SEPARATOR);
+    return ((dt.length === 2 && validDate(dt[0]) && validTime(dt[1])) ||
+        (allowDate && dt.length === 1 && validDate(dt[0])));
+}
+exports.default = validTimestamp;
+function validDate(str) {
+    const matches = DATE.exec(str);
+    if (!matches)
+        return false;
+    const y = +matches[1];
+    const m = +matches[2];
+    const d = +matches[3];
+    return (m >= 1 &&
+        m <= 12 &&
+        d >= 1 &&
+        (d <= DAYS[m] ||
+            // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
+            (m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0))));
+}
+function validTime(str) {
+    const matches = TIME.exec(str);
+    if (!matches)
+        return false;
+    const hr = +matches[1];
+    const min = +matches[2];
+    const sec = +matches[3];
+    const tzH = +(matches[4] || 0);
+    const tzM = +(matches[5] || 0);
+    return ((hr <= 23 && min <= 59 && sec <= 59) ||
+        // leap second
+        (hr - tzH === 23 && min - tzM === 59 && sec === 60));
+}
+validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
+//# sourceMappingURL=timestamp.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/ucs2length.js b/node_modules/ajv/dist/runtime/ucs2length.js
index 92ea0c0..3ac39fc 100644
--- a/node_modules/ajv/dist/runtime/ucs2length.js
+++ b/node_modules/ajv/dist/runtime/ucs2length.js
@@ -21,4 +21,3 @@ function ucs2length(str) {
 }
 exports.default = ucs2length;
 ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
-//# sourceMappingURL=ucs2length.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/ucs2length.js.bak b/node_modules/ajv/dist/runtime/ucs2length.js.bak
new file mode 100644
index 0000000..92ea0c0
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/ucs2length.js.bak
@@ -0,0 +1,24 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+// https://mathiasbynens.be/notes/javascript-encoding
+// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
+function ucs2length(str) {
+    const len = str.length;
+    let length = 0;
+    let pos = 0;
+    let value;
+    while (pos < len) {
+        length++;
+        value = str.charCodeAt(pos++);
+        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
+            // high surrogate, and there is a next character
+            value = str.charCodeAt(pos);
+            if ((value & 0xfc00) === 0xdc00)
+                pos++; // low surrogate
+        }
+    }
+    return length;
+}
+exports.default = ucs2length;
+ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
+//# sourceMappingURL=ucs2length.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/uri.js b/node_modules/ajv/dist/runtime/uri.js
index fbd3815..9b40798 100644
--- a/node_modules/ajv/dist/runtime/uri.js
+++ b/node_modules/ajv/dist/runtime/uri.js
@@ -3,4 +3,3 @@ Object.defineProperty(exports, "__esModule", { value: true });
 const uri = require("uri-js");
 uri.code = 'require("ajv/dist/runtime/uri").default';
 exports.default = uri;
-//# sourceMappingURL=uri.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/uri.js.bak b/node_modules/ajv/dist/runtime/uri.js.bak
new file mode 100644
index 0000000..fbd3815
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/uri.js.bak
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const uri = require("uri-js");
+uri.code = 'require("ajv/dist/runtime/uri").default';
+exports.default = uri;
+//# sourceMappingURL=uri.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/validation_error.js b/node_modules/ajv/dist/runtime/validation_error.js
index 353502c..92b1219 100644
--- a/node_modules/ajv/dist/runtime/validation_error.js
+++ b/node_modules/ajv/dist/runtime/validation_error.js
@@ -8,4 +8,3 @@ class ValidationError extends Error {
     }
 }
 exports.default = ValidationError;
-//# sourceMappingURL=validation_error.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/runtime/validation_error.js.bak b/node_modules/ajv/dist/runtime/validation_error.js.bak
new file mode 100644
index 0000000..353502c
--- /dev/null
+++ b/node_modules/ajv/dist/runtime/validation_error.js.bak
@@ -0,0 +1,11 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+class ValidationError extends Error {
+    constructor(errors) {
+        super("validation failed");
+        this.errors = errors;
+        this.ajv = this.validation = true;
+    }
+}
+exports.default = ValidationError;
+//# sourceMappingURL=validation_error.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/standalone/index.js b/node_modules/ajv/dist/standalone/index.js
index b44bb5d..0f11601 100644
--- a/node_modules/ajv/dist/standalone/index.js
+++ b/node_modules/ajv/dist/standalone/index.js
@@ -87,4 +87,3 @@ function standaloneCode(ajv, refsOrFunc) {
 module.exports = exports = standaloneCode;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.default = standaloneCode;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/standalone/index.js.bak b/node_modules/ajv/dist/standalone/index.js.bak
new file mode 100644
index 0000000..b44bb5d
--- /dev/null
+++ b/node_modules/ajv/dist/standalone/index.js.bak
@@ -0,0 +1,90 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const scope_1 = require("../compile/codegen/scope");
+const code_1 = require("../compile/codegen/code");
+function standaloneCode(ajv, refsOrFunc) {
+    if (!ajv.opts.code.source) {
+        throw new Error("moduleCode: ajv instance must have code.source option");
+    }
+    const { _n } = ajv.scope.opts;
+    return typeof refsOrFunc == "function"
+        ? funcExportCode(refsOrFunc.source)
+        : refsOrFunc !== undefined
+            ? multiExportsCode(refsOrFunc, getValidate)
+            : multiExportsCode(ajv.schemas, (sch) => sch.meta ? undefined : ajv.compile(sch.schema));
+    function getValidate(id) {
+        const v = ajv.getSchema(id);
+        if (!v)
+            throw new Error(`moduleCode: no schema with id ${id}`);
+        return v;
+    }
+    function funcExportCode(source) {
+        const usedValues = {};
+        const n = source === null || source === void 0 ? void 0 : source.validateName;
+        const vCode = validateCode(usedValues, source);
+        if (ajv.opts.code.esm) {
+            // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value
+            return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
+        }
+        return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
+    }
+    function multiExportsCode(schemas, getValidateFunc) {
+        var _a;
+        const usedValues = {};
+        let code = (0, code_1._) `"use strict";`;
+        for (const name in schemas) {
+            const v = getValidateFunc(schemas[name]);
+            if (v) {
+                const vCode = validateCode(usedValues, v.source);
+                const exportSyntax = ajv.opts.code.esm
+                    ? (0, code_1._) `export const ${(0, code_1.getEsmExportName)(name)}`
+                    : (0, code_1._) `exports${(0, code_1.getProperty)(name)}`;
+                code = (0, code_1._) `${code}${_n}${exportSyntax} = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;
+            }
+        }
+        return `${code}`;
+    }
+    function validateCode(usedValues, s) {
+        if (!s)
+            throw new Error('moduleCode: function does not have "source" property');
+        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
+            return code_1.nil;
+        setUsedState(s.validateName, scope_1.UsedValueState.Started);
+        const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
+        const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
+        return s.evaluated ? (0, code_1._) `${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;
+        function refValidateCode(n) {
+            var _a;
+            const vRef = (_a = n.value) === null || _a === void 0 ? void 0 : _a.ref;
+            if (n.prefix === "validate" && typeof vRef == "function") {
+                const v = vRef;
+                return validateCode(usedValues, v.source);
+            }
+            else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
+                const { validate, validateName } = vRef;
+                if (!validateName)
+                    throw new Error("ajv internal error");
+                const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
+                const wrapper = (0, code_1._) `${def} ${n} = {validate: ${validateName}};`;
+                if (usedState(validateName) === scope_1.UsedValueState.Started)
+                    return wrapper;
+                const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
+                return (0, code_1._) `${wrapper}${_n}${vCode}`;
+            }
+            return undefined;
+        }
+        function usedState(name) {
+            var _a;
+            return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
+        }
+        function setUsedState(name, state) {
+            const { prefix } = name;
+            const names = (usedValues[prefix] = usedValues[prefix] || new Map());
+            names.set(name, state);
+        }
+    }
+}
+module.exports = exports = standaloneCode;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = standaloneCode;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/standalone/instance.js b/node_modules/ajv/dist/standalone/instance.js
index 35e5c99..25d1e51 100644
--- a/node_modules/ajv/dist/standalone/instance.js
+++ b/node_modules/ajv/dist/standalone/instance.js
@@ -32,4 +32,3 @@ class AjvPack {
     }
 }
 exports.default = AjvPack;
-//# sourceMappingURL=instance.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/standalone/instance.js.bak b/node_modules/ajv/dist/standalone/instance.js.bak
new file mode 100644
index 0000000..35e5c99
--- /dev/null
+++ b/node_modules/ajv/dist/standalone/instance.js.bak
@@ -0,0 +1,35 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const core_1 = require("../core");
+const _1 = require(".");
+const requireFromString = require("require-from-string");
+class AjvPack {
+    constructor(ajv) {
+        this.ajv = ajv;
+    }
+    validate(schemaKeyRef, data) {
+        return core_1.default.prototype.validate.call(this, schemaKeyRef, data);
+    }
+    compile(schema, meta) {
+        return this.getStandalone(this.ajv.compile(schema, meta));
+    }
+    getSchema(keyRef) {
+        const v = this.ajv.getSchema(keyRef);
+        if (!v)
+            return undefined;
+        return this.getStandalone(v);
+    }
+    getStandalone(v) {
+        return requireFromString((0, _1.default)(this.ajv, v));
+    }
+    addSchema(...args) {
+        this.ajv.addSchema.call(this.ajv, ...args);
+        return this;
+    }
+    addKeyword(...args) {
+        this.ajv.addKeyword.call(this.ajv, ...args);
+        return this;
+    }
+}
+exports.default = AjvPack;
+//# sourceMappingURL=instance.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/types/index.js b/node_modules/ajv/dist/types/index.js
index aa219d8..c8ad2e5 100644
--- a/node_modules/ajv/dist/types/index.js
+++ b/node_modules/ajv/dist/types/index.js
@@ -1,3 +1,2 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/types/index.js.bak b/node_modules/ajv/dist/types/index.js.bak
new file mode 100644
index 0000000..aa219d8
--- /dev/null
+++ b/node_modules/ajv/dist/types/index.js.bak
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/types/json-schema.js b/node_modules/ajv/dist/types/json-schema.js
index 2d8f98d..c8ad2e5 100644
--- a/node_modules/ajv/dist/types/json-schema.js
+++ b/node_modules/ajv/dist/types/json-schema.js
@@ -1,3 +1,2 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-//# sourceMappingURL=json-schema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/types/json-schema.js.bak b/node_modules/ajv/dist/types/json-schema.js.bak
new file mode 100644
index 0000000..2d8f98d
--- /dev/null
+++ b/node_modules/ajv/dist/types/json-schema.js.bak
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=json-schema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/types/jtd-schema.js b/node_modules/ajv/dist/types/jtd-schema.js
index 11338aa..c8ad2e5 100644
--- a/node_modules/ajv/dist/types/jtd-schema.js
+++ b/node_modules/ajv/dist/types/jtd-schema.js
@@ -1,3 +1,2 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-//# sourceMappingURL=jtd-schema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/types/jtd-schema.js.bak b/node_modules/ajv/dist/types/jtd-schema.js.bak
new file mode 100644
index 0000000..11338aa
--- /dev/null
+++ b/node_modules/ajv/dist/types/jtd-schema.js.bak
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=jtd-schema.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js b/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
index 608d51e..fddbc3e 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
@@ -46,4 +46,3 @@ function validateAdditionalItems(cxt, items) {
 }
 exports.validateAdditionalItems = validateAdditionalItems;
 exports.default = def;
-//# sourceMappingURL=additionalItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js.bak b/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js.bak
new file mode 100644
index 0000000..608d51e
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js.bak
@@ -0,0 +1,49 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateAdditionalItems = void 0;
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
+    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
+};
+const def = {
+    keyword: "additionalItems",
+    type: "array",
+    schemaType: ["boolean", "object"],
+    before: "uniqueItems",
+    error,
+    code(cxt) {
+        const { parentSchema, it } = cxt;
+        const { items } = parentSchema;
+        if (!Array.isArray(items)) {
+            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
+            return;
+        }
+        validateAdditionalItems(cxt, items);
+    },
+};
+function validateAdditionalItems(cxt, items) {
+    const { gen, schema, data, keyword, it } = cxt;
+    it.items = true;
+    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
+    if (schema === false) {
+        cxt.setParams({ len: items.length });
+        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
+    }
+    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
+        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
+        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
+        cxt.ok(valid);
+    }
+    function validateItems(valid) {
+        gen.forRange("i", items.length, len, (i) => {
+            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
+            if (!it.allErrors)
+                gen.if((0, codegen_1.not)(valid), () => gen.break());
+        });
+    }
+}
+exports.validateAdditionalItems = validateAdditionalItems;
+exports.default = def;
+//# sourceMappingURL=additionalItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js b/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
index 1d3374b..394c4a6 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
@@ -103,4 +103,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=additionalProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js.bak b/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js.bak
new file mode 100644
index 0000000..1d3374b
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js.bak
@@ -0,0 +1,106 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const code_1 = require("../code");
+const codegen_1 = require("../../compile/codegen");
+const names_1 = require("../../compile/names");
+const util_1 = require("../../compile/util");
+const error = {
+    message: "must NOT have additional properties",
+    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
+};
+const def = {
+    keyword: "additionalProperties",
+    type: ["object"],
+    schemaType: ["boolean", "object"],
+    allowUndefined: true,
+    trackErrors: true,
+    error,
+    code(cxt) {
+        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
+        /* istanbul ignore if */
+        if (!errsCount)
+            throw new Error("ajv implementation error");
+        const { allErrors, opts } = it;
+        it.props = true;
+        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
+            return;
+        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
+        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
+        checkAdditionalProperties();
+        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
+        function checkAdditionalProperties() {
+            gen.forIn("key", data, (key) => {
+                if (!props.length && !patProps.length)
+                    additionalPropertyCode(key);
+                else
+                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
+            });
+        }
+        function isAdditional(key) {
+            let definedProp;
+            if (props.length > 8) {
+                // TODO maybe an option instead of hard-coded 8?
+                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
+                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
+            }
+            else if (props.length) {
+                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
+            }
+            else {
+                definedProp = codegen_1.nil;
+            }
+            if (patProps.length) {
+                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
+            }
+            return (0, codegen_1.not)(definedProp);
+        }
+        function deleteAdditional(key) {
+            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
+        }
+        function additionalPropertyCode(key) {
+            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
+                deleteAdditional(key);
+                return;
+            }
+            if (schema === false) {
+                cxt.setParams({ additionalProperty: key });
+                cxt.error();
+                if (!allErrors)
+                    gen.break();
+                return;
+            }
+            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
+                const valid = gen.name("valid");
+                if (opts.removeAdditional === "failing") {
+                    applyAdditionalSchema(key, valid, false);
+                    gen.if((0, codegen_1.not)(valid), () => {
+                        cxt.reset();
+                        deleteAdditional(key);
+                    });
+                }
+                else {
+                    applyAdditionalSchema(key, valid);
+                    if (!allErrors)
+                        gen.if((0, codegen_1.not)(valid), () => gen.break());
+                }
+            }
+        }
+        function applyAdditionalSchema(key, valid, errors) {
+            const subschema = {
+                keyword: "additionalProperties",
+                dataProp: key,
+                dataPropType: util_1.Type.Str,
+            };
+            if (errors === false) {
+                Object.assign(subschema, {
+                    compositeRule: true,
+                    createErrors: false,
+                    allErrors: false,
+                });
+            }
+            cxt.subschema(subschema, valid);
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=additionalProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/allOf.js b/node_modules/ajv/dist/vocabularies/applicator/allOf.js
index 1b1ae73..8064587 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/allOf.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/allOf.js
@@ -20,4 +20,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=allOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/allOf.js.bak b/node_modules/ajv/dist/vocabularies/applicator/allOf.js.bak
new file mode 100644
index 0000000..1b1ae73
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/allOf.js.bak
@@ -0,0 +1,23 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: "allOf",
+    schemaType: "array",
+    code(cxt) {
+        const { gen, schema, it } = cxt;
+        /* istanbul ignore if */
+        if (!Array.isArray(schema))
+            throw new Error("ajv implementation error");
+        const valid = gen.name("valid");
+        schema.forEach((sch, i) => {
+            if ((0, util_1.alwaysValidSchema)(it, sch))
+                return;
+            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
+            cxt.ok(valid);
+            cxt.mergeEvaluated(schCxt);
+        });
+    },
+};
+exports.default = def;
+//# sourceMappingURL=allOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/anyOf.js b/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
index 66cfce2..8d17263 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
@@ -9,4 +9,3 @@ const def = {
     error: { message: "must match a schema in anyOf" },
 };
 exports.default = def;
-//# sourceMappingURL=anyOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/anyOf.js.bak b/node_modules/ajv/dist/vocabularies/applicator/anyOf.js.bak
new file mode 100644
index 0000000..66cfce2
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/anyOf.js.bak
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const code_1 = require("../code");
+const def = {
+    keyword: "anyOf",
+    schemaType: "array",
+    trackErrors: true,
+    code: code_1.validateUnion,
+    error: { message: "must match a schema in anyOf" },
+};
+exports.default = def;
+//# sourceMappingURL=anyOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/contains.js b/node_modules/ajv/dist/vocabularies/applicator/contains.js
index 6c5473f..271f260 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/contains.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/contains.js
@@ -92,4 +92,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=contains.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/contains.js.bak b/node_modules/ajv/dist/vocabularies/applicator/contains.js.bak
new file mode 100644
index 0000000..6c5473f
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/contains.js.bak
@@ -0,0 +1,95 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: ({ params: { min, max } }) => max === undefined
+        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
+        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
+    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
+};
+const def = {
+    keyword: "contains",
+    type: "array",
+    schemaType: ["object", "boolean"],
+    before: "uniqueItems",
+    trackErrors: true,
+    error,
+    code(cxt) {
+        const { gen, schema, parentSchema, data, it } = cxt;
+        let min;
+        let max;
+        const { minContains, maxContains } = parentSchema;
+        if (it.opts.next) {
+            min = minContains === undefined ? 1 : minContains;
+            max = maxContains;
+        }
+        else {
+            min = 1;
+        }
+        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
+        cxt.setParams({ min, max });
+        if (max === undefined && min === 0) {
+            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
+            return;
+        }
+        if (max !== undefined && min > max) {
+            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
+            cxt.fail();
+            return;
+        }
+        if ((0, util_1.alwaysValidSchema)(it, schema)) {
+            let cond = (0, codegen_1._) `${len} >= ${min}`;
+            if (max !== undefined)
+                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
+            cxt.pass(cond);
+            return;
+        }
+        it.items = true;
+        const valid = gen.name("valid");
+        if (max === undefined && min === 1) {
+            validateItems(valid, () => gen.if(valid, () => gen.break()));
+        }
+        else if (min === 0) {
+            gen.let(valid, true);
+            if (max !== undefined)
+                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
+        }
+        else {
+            gen.let(valid, false);
+            validateItemsWithCount();
+        }
+        cxt.result(valid, () => cxt.reset());
+        function validateItemsWithCount() {
+            const schValid = gen.name("_valid");
+            const count = gen.let("count", 0);
+            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
+        }
+        function validateItems(_valid, block) {
+            gen.forRange("i", 0, len, (i) => {
+                cxt.subschema({
+                    keyword: "contains",
+                    dataProp: i,
+                    dataPropType: util_1.Type.Num,
+                    compositeRule: true,
+                }, _valid);
+                block();
+            });
+        }
+        function checkLimits(count) {
+            gen.code((0, codegen_1._) `${count}++`);
+            if (max === undefined) {
+                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
+            }
+            else {
+                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
+                if (min === 1)
+                    gen.assign(valid, true);
+                else
+                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
+            }
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=contains.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/dependencies.js b/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
index e81f86d..606cffe 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
@@ -82,4 +82,3 @@ function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
 }
 exports.validateSchemaDeps = validateSchemaDeps;
 exports.default = def;
-//# sourceMappingURL=dependencies.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/dependencies.js.bak b/node_modules/ajv/dist/vocabularies/applicator/dependencies.js.bak
new file mode 100644
index 0000000..e81f86d
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/dependencies.js.bak
@@ -0,0 +1,85 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const code_1 = require("../code");
+exports.error = {
+    message: ({ params: { property, depsCount, deps } }) => {
+        const property_ies = depsCount === 1 ? "property" : "properties";
+        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
+    },
+    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
+    missingProperty: ${missingProperty},
+    depsCount: ${depsCount},
+    deps: ${deps}}`, // TODO change to reference
+};
+const def = {
+    keyword: "dependencies",
+    type: "object",
+    schemaType: "object",
+    error: exports.error,
+    code(cxt) {
+        const [propDeps, schDeps] = splitDependencies(cxt);
+        validatePropertyDeps(cxt, propDeps);
+        validateSchemaDeps(cxt, schDeps);
+    },
+};
+function splitDependencies({ schema }) {
+    const propertyDeps = {};
+    const schemaDeps = {};
+    for (const key in schema) {
+        if (key === "__proto__")
+            continue;
+        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
+        deps[key] = schema[key];
+    }
+    return [propertyDeps, schemaDeps];
+}
+function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
+    const { gen, data, it } = cxt;
+    if (Object.keys(propertyDeps).length === 0)
+        return;
+    const missing = gen.let("missing");
+    for (const prop in propertyDeps) {
+        const deps = propertyDeps[prop];
+        if (deps.length === 0)
+            continue;
+        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
+        cxt.setParams({
+            property: prop,
+            depsCount: deps.length,
+            deps: deps.join(", "),
+        });
+        if (it.allErrors) {
+            gen.if(hasProperty, () => {
+                for (const depProp of deps) {
+                    (0, code_1.checkReportMissingProp)(cxt, depProp);
+                }
+            });
+        }
+        else {
+            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
+            (0, code_1.reportMissingProp)(cxt, missing);
+            gen.else();
+        }
+    }
+}
+exports.validatePropertyDeps = validatePropertyDeps;
+function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
+    const { gen, data, keyword, it } = cxt;
+    const valid = gen.name("valid");
+    for (const prop in schemaDeps) {
+        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
+            continue;
+        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
+            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
+            cxt.mergeValidEvaluated(schCxt, valid);
+        }, () => gen.var(valid, true) // TODO var
+        );
+        cxt.ok(valid);
+    }
+}
+exports.validateSchemaDeps = validateSchemaDeps;
+exports.default = def;
+//# sourceMappingURL=dependencies.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js b/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js
index 66ef2e8..7a754b6 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js
@@ -8,4 +8,3 @@ const def = {
     code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt),
 };
 exports.default = def;
-//# sourceMappingURL=dependentSchemas.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js.bak b/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js.bak
new file mode 100644
index 0000000..66ef2e8
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js.bak
@@ -0,0 +1,11 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dependencies_1 = require("./dependencies");
+const def = {
+    keyword: "dependentSchemas",
+    type: "object",
+    schemaType: "object",
+    code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt),
+};
+exports.default = def;
+//# sourceMappingURL=dependentSchemas.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/if.js b/node_modules/ajv/dist/vocabularies/applicator/if.js
index 2c42a3e..89534b6 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/if.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/if.js
@@ -63,4 +63,3 @@ function hasSchema(it, keyword) {
     return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
 }
 exports.default = def;
-//# sourceMappingURL=if.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/if.js.bak b/node_modules/ajv/dist/vocabularies/applicator/if.js.bak
new file mode 100644
index 0000000..2c42a3e
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/if.js.bak
@@ -0,0 +1,66 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
+    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
+};
+const def = {
+    keyword: "if",
+    schemaType: ["object", "boolean"],
+    trackErrors: true,
+    error,
+    code(cxt) {
+        const { gen, parentSchema, it } = cxt;
+        if (parentSchema.then === undefined && parentSchema.else === undefined) {
+            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
+        }
+        const hasThen = hasSchema(it, "then");
+        const hasElse = hasSchema(it, "else");
+        if (!hasThen && !hasElse)
+            return;
+        const valid = gen.let("valid", true);
+        const schValid = gen.name("_valid");
+        validateIf();
+        cxt.reset();
+        if (hasThen && hasElse) {
+            const ifClause = gen.let("ifClause");
+            cxt.setParams({ ifClause });
+            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
+        }
+        else if (hasThen) {
+            gen.if(schValid, validateClause("then"));
+        }
+        else {
+            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
+        }
+        cxt.pass(valid, () => cxt.error(true));
+        function validateIf() {
+            const schCxt = cxt.subschema({
+                keyword: "if",
+                compositeRule: true,
+                createErrors: false,
+                allErrors: false,
+            }, schValid);
+            cxt.mergeEvaluated(schCxt);
+        }
+        function validateClause(keyword, ifClause) {
+            return () => {
+                const schCxt = cxt.subschema({ keyword }, schValid);
+                gen.assign(valid, schValid);
+                cxt.mergeValidEvaluated(schCxt, valid);
+                if (ifClause)
+                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
+                else
+                    cxt.setParams({ ifClause: keyword });
+            };
+        }
+    },
+};
+function hasSchema(it, keyword) {
+    const schema = it.schema[keyword];
+    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
+}
+exports.default = def;
+//# sourceMappingURL=if.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/index.js b/node_modules/ajv/dist/vocabularies/applicator/index.js
index cf592f2..95352f1 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/index.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/index.js
@@ -41,4 +41,3 @@ function getApplicator(draft2020 = false) {
     return applicator;
 }
 exports.default = getApplicator;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/index.js.bak b/node_modules/ajv/dist/vocabularies/applicator/index.js.bak
new file mode 100644
index 0000000..cf592f2
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/index.js.bak
@@ -0,0 +1,44 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const additionalItems_1 = require("./additionalItems");
+const prefixItems_1 = require("./prefixItems");
+const items_1 = require("./items");
+const items2020_1 = require("./items2020");
+const contains_1 = require("./contains");
+const dependencies_1 = require("./dependencies");
+const propertyNames_1 = require("./propertyNames");
+const additionalProperties_1 = require("./additionalProperties");
+const properties_1 = require("./properties");
+const patternProperties_1 = require("./patternProperties");
+const not_1 = require("./not");
+const anyOf_1 = require("./anyOf");
+const oneOf_1 = require("./oneOf");
+const allOf_1 = require("./allOf");
+const if_1 = require("./if");
+const thenElse_1 = require("./thenElse");
+function getApplicator(draft2020 = false) {
+    const applicator = [
+        // any
+        not_1.default,
+        anyOf_1.default,
+        oneOf_1.default,
+        allOf_1.default,
+        if_1.default,
+        thenElse_1.default,
+        // object
+        propertyNames_1.default,
+        additionalProperties_1.default,
+        dependencies_1.default,
+        properties_1.default,
+        patternProperties_1.default,
+    ];
+    // array
+    if (draft2020)
+        applicator.push(prefixItems_1.default, items2020_1.default);
+    else
+        applicator.push(additionalItems_1.default, items_1.default);
+    applicator.push(contains_1.default);
+    return applicator;
+}
+exports.default = getApplicator;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/items.js b/node_modules/ajv/dist/vocabularies/applicator/items.js
index 26f527b..f00b120 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/items.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/items.js
@@ -49,4 +49,3 @@ function validateTuple(cxt, extraItems, schArr = cxt.schema) {
 }
 exports.validateTuple = validateTuple;
 exports.default = def;
-//# sourceMappingURL=items.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/items.js.bak b/node_modules/ajv/dist/vocabularies/applicator/items.js.bak
new file mode 100644
index 0000000..26f527b
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/items.js.bak
@@ -0,0 +1,52 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateTuple = void 0;
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const code_1 = require("../code");
+const def = {
+    keyword: "items",
+    type: "array",
+    schemaType: ["object", "array", "boolean"],
+    before: "uniqueItems",
+    code(cxt) {
+        const { schema, it } = cxt;
+        if (Array.isArray(schema))
+            return validateTuple(cxt, "additionalItems", schema);
+        it.items = true;
+        if ((0, util_1.alwaysValidSchema)(it, schema))
+            return;
+        cxt.ok((0, code_1.validateArray)(cxt));
+    },
+};
+function validateTuple(cxt, extraItems, schArr = cxt.schema) {
+    const { gen, parentSchema, data, keyword, it } = cxt;
+    checkStrictTuple(parentSchema);
+    if (it.opts.unevaluated && schArr.length && it.items !== true) {
+        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
+    }
+    const valid = gen.name("valid");
+    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
+    schArr.forEach((sch, i) => {
+        if ((0, util_1.alwaysValidSchema)(it, sch))
+            return;
+        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
+            keyword,
+            schemaProp: i,
+            dataProp: i,
+        }, valid));
+        cxt.ok(valid);
+    });
+    function checkStrictTuple(sch) {
+        const { opts, errSchemaPath } = it;
+        const l = schArr.length;
+        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
+        if (opts.strictTuples && !fullTuple) {
+            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
+            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
+        }
+    }
+}
+exports.validateTuple = validateTuple;
+exports.default = def;
+//# sourceMappingURL=items.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/items2020.js b/node_modules/ajv/dist/vocabularies/applicator/items2020.js
index f2387d7..e79848d 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/items2020.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/items2020.js
@@ -27,4 +27,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=items2020.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/items2020.js.bak b/node_modules/ajv/dist/vocabularies/applicator/items2020.js.bak
new file mode 100644
index 0000000..f2387d7
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/items2020.js.bak
@@ -0,0 +1,30 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const code_1 = require("../code");
+const additionalItems_1 = require("./additionalItems");
+const error = {
+    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
+    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
+};
+const def = {
+    keyword: "items",
+    type: "array",
+    schemaType: ["object", "boolean"],
+    before: "uniqueItems",
+    error,
+    code(cxt) {
+        const { schema, parentSchema, it } = cxt;
+        const { prefixItems } = parentSchema;
+        it.items = true;
+        if ((0, util_1.alwaysValidSchema)(it, schema))
+            return;
+        if (prefixItems)
+            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
+        else
+            cxt.ok((0, code_1.validateArray)(cxt));
+    },
+};
+exports.default = def;
+//# sourceMappingURL=items2020.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/not.js b/node_modules/ajv/dist/vocabularies/applicator/not.js
index 89f6fdd..4d39547 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/not.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/not.js
@@ -23,4 +23,3 @@ const def = {
     error: { message: "must NOT be valid" },
 };
 exports.default = def;
-//# sourceMappingURL=not.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/not.js.bak b/node_modules/ajv/dist/vocabularies/applicator/not.js.bak
new file mode 100644
index 0000000..89f6fdd
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/not.js.bak
@@ -0,0 +1,26 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: "not",
+    schemaType: ["object", "boolean"],
+    trackErrors: true,
+    code(cxt) {
+        const { gen, schema, it } = cxt;
+        if ((0, util_1.alwaysValidSchema)(it, schema)) {
+            cxt.fail();
+            return;
+        }
+        const valid = gen.name("valid");
+        cxt.subschema({
+            keyword: "not",
+            compositeRule: true,
+            createErrors: false,
+            allErrors: false,
+        }, valid);
+        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
+    },
+    error: { message: "must NOT be valid" },
+};
+exports.default = def;
+//# sourceMappingURL=not.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/oneOf.js b/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
index 441db2a..a434da7 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
@@ -57,4 +57,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=oneOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/oneOf.js.bak b/node_modules/ajv/dist/vocabularies/applicator/oneOf.js.bak
new file mode 100644
index 0000000..441db2a
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/oneOf.js.bak
@@ -0,0 +1,60 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: "must match exactly one schema in oneOf",
+    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
+};
+const def = {
+    keyword: "oneOf",
+    schemaType: "array",
+    trackErrors: true,
+    error,
+    code(cxt) {
+        const { gen, schema, parentSchema, it } = cxt;
+        /* istanbul ignore if */
+        if (!Array.isArray(schema))
+            throw new Error("ajv implementation error");
+        if (it.opts.discriminator && parentSchema.discriminator)
+            return;
+        const schArr = schema;
+        const valid = gen.let("valid", false);
+        const passing = gen.let("passing", null);
+        const schValid = gen.name("_valid");
+        cxt.setParams({ passing });
+        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
+        gen.block(validateOneOf);
+        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
+        function validateOneOf() {
+            schArr.forEach((sch, i) => {
+                let schCxt;
+                if ((0, util_1.alwaysValidSchema)(it, sch)) {
+                    gen.var(schValid, true);
+                }
+                else {
+                    schCxt = cxt.subschema({
+                        keyword: "oneOf",
+                        schemaProp: i,
+                        compositeRule: true,
+                    }, schValid);
+                }
+                if (i > 0) {
+                    gen
+                        .if((0, codegen_1._) `${schValid} && ${valid}`)
+                        .assign(valid, false)
+                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
+                        .else();
+                }
+                gen.if(schValid, () => {
+                    gen.assign(valid, true);
+                    gen.assign(passing, i);
+                    if (schCxt)
+                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
+                });
+            });
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=oneOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js b/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
index 48501c6..9836185 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
@@ -72,4 +72,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=patternProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js.bak b/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js.bak
new file mode 100644
index 0000000..48501c6
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js.bak
@@ -0,0 +1,75 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const code_1 = require("../code");
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const util_2 = require("../../compile/util");
+const def = {
+    keyword: "patternProperties",
+    type: "object",
+    schemaType: "object",
+    code(cxt) {
+        const { gen, schema, data, parentSchema, it } = cxt;
+        const { opts } = it;
+        const patterns = (0, code_1.allSchemaProperties)(schema);
+        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
+        if (patterns.length === 0 ||
+            (alwaysValidPatterns.length === patterns.length &&
+                (!it.opts.unevaluated || it.props === true))) {
+            return;
+        }
+        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
+        const valid = gen.name("valid");
+        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
+            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
+        }
+        const { props } = it;
+        validatePatternProperties();
+        function validatePatternProperties() {
+            for (const pat of patterns) {
+                if (checkProperties)
+                    checkMatchingProperties(pat);
+                if (it.allErrors) {
+                    validateProperties(pat);
+                }
+                else {
+                    gen.var(valid, true); // TODO var
+                    validateProperties(pat);
+                    gen.if(valid);
+                }
+            }
+        }
+        function checkMatchingProperties(pat) {
+            for (const prop in checkProperties) {
+                if (new RegExp(pat).test(prop)) {
+                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
+                }
+            }
+        }
+        function validateProperties(pat) {
+            gen.forIn("key", data, (key) => {
+                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
+                    const alwaysValid = alwaysValidPatterns.includes(pat);
+                    if (!alwaysValid) {
+                        cxt.subschema({
+                            keyword: "patternProperties",
+                            schemaProp: pat,
+                            dataProp: key,
+                            dataPropType: util_2.Type.Str,
+                        }, valid);
+                    }
+                    if (it.opts.unevaluated && props !== true) {
+                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
+                    }
+                    else if (!alwaysValid && !it.allErrors) {
+                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
+                        // or if all properties were evaluated (props === true)
+                        gen.if((0, codegen_1.not)(valid), () => gen.break());
+                    }
+                });
+            });
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=patternProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js b/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
index 727bc23..1d84ee8 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
@@ -9,4 +9,3 @@ const def = {
     code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
 };
 exports.default = def;
-//# sourceMappingURL=prefixItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js.bak b/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js.bak
new file mode 100644
index 0000000..727bc23
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js.bak
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const items_1 = require("./items");
+const def = {
+    keyword: "prefixItems",
+    type: "array",
+    schemaType: ["array"],
+    before: "uniqueItems",
+    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
+};
+exports.default = def;
+//# sourceMappingURL=prefixItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/properties.js b/node_modules/ajv/dist/vocabularies/applicator/properties.js
index 7347358..6c17f65 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/properties.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/properties.js
@@ -51,4 +51,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=properties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/properties.js.bak b/node_modules/ajv/dist/vocabularies/applicator/properties.js.bak
new file mode 100644
index 0000000..7347358
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/properties.js.bak
@@ -0,0 +1,54 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const validate_1 = require("../../compile/validate");
+const code_1 = require("../code");
+const util_1 = require("../../compile/util");
+const additionalProperties_1 = require("./additionalProperties");
+const def = {
+    keyword: "properties",
+    type: "object",
+    schemaType: "object",
+    code(cxt) {
+        const { gen, schema, parentSchema, data, it } = cxt;
+        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
+            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
+        }
+        const allProps = (0, code_1.allSchemaProperties)(schema);
+        for (const prop of allProps) {
+            it.definedProperties.add(prop);
+        }
+        if (it.opts.unevaluated && allProps.length && it.props !== true) {
+            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
+        }
+        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
+        if (properties.length === 0)
+            return;
+        const valid = gen.name("valid");
+        for (const prop of properties) {
+            if (hasDefault(prop)) {
+                applyPropertySchema(prop);
+            }
+            else {
+                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
+                applyPropertySchema(prop);
+                if (!it.allErrors)
+                    gen.else().var(valid, true);
+                gen.endIf();
+            }
+            cxt.it.definedProperties.add(prop);
+            cxt.ok(valid);
+        }
+        function hasDefault(prop) {
+            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
+        }
+        function applyPropertySchema(prop) {
+            cxt.subschema({
+                keyword: "properties",
+                schemaProp: prop,
+                dataProp: prop,
+            }, valid);
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=properties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js b/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
index f387115..a28fe4c 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
@@ -35,4 +35,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=propertyNames.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js.bak b/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js.bak
new file mode 100644
index 0000000..f387115
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js.bak
@@ -0,0 +1,38 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: "property name must be valid",
+    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
+};
+const def = {
+    keyword: "propertyNames",
+    type: "object",
+    schemaType: ["object", "boolean"],
+    error,
+    code(cxt) {
+        const { gen, schema, data, it } = cxt;
+        if ((0, util_1.alwaysValidSchema)(it, schema))
+            return;
+        const valid = gen.name("valid");
+        gen.forIn("key", data, (key) => {
+            cxt.setParams({ propertyName: key });
+            cxt.subschema({
+                keyword: "propertyNames",
+                data: key,
+                dataTypes: ["string"],
+                propertyName: key,
+                compositeRule: true,
+            }, valid);
+            gen.if((0, codegen_1.not)(valid), () => {
+                cxt.error(true);
+                if (!it.allErrors)
+                    gen.break();
+            });
+        });
+        cxt.ok(valid);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=propertyNames.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/thenElse.js b/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
index 1ae6390..6a8ca05 100644
--- a/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
+++ b/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
@@ -10,4 +10,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=thenElse.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/applicator/thenElse.js.bak b/node_modules/ajv/dist/vocabularies/applicator/thenElse.js.bak
new file mode 100644
index 0000000..1ae6390
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/applicator/thenElse.js.bak
@@ -0,0 +1,13 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: ["then", "else"],
+    schemaType: ["object", "boolean"],
+    code({ keyword, parentSchema, it }) {
+        if (parentSchema.if === undefined)
+            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=thenElse.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/code.js b/node_modules/ajv/dist/vocabularies/code.js
index 8cb8993..76b020c 100644
--- a/node_modules/ajv/dist/vocabularies/code.js
+++ b/node_modules/ajv/dist/vocabularies/code.js
@@ -128,4 +128,3 @@ function validateUnion(cxt) {
     cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
 }
 exports.validateUnion = validateUnion;
-//# sourceMappingURL=code.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/code.js.bak b/node_modules/ajv/dist/vocabularies/code.js.bak
new file mode 100644
index 0000000..8cb8993
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/code.js.bak
@@ -0,0 +1,131 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
+const codegen_1 = require("../compile/codegen");
+const util_1 = require("../compile/util");
+const names_1 = require("../compile/names");
+const util_2 = require("../compile/util");
+function checkReportMissingProp(cxt, prop) {
+    const { gen, data, it } = cxt;
+    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
+        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
+        cxt.error();
+    });
+}
+exports.checkReportMissingProp = checkReportMissingProp;
+function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
+    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
+}
+exports.checkMissingProp = checkMissingProp;
+function reportMissingProp(cxt, missing) {
+    cxt.setParams({ missingProperty: missing }, true);
+    cxt.error();
+}
+exports.reportMissingProp = reportMissingProp;
+function hasPropFunc(gen) {
+    return gen.scopeValue("func", {
+        // eslint-disable-next-line @typescript-eslint/unbound-method
+        ref: Object.prototype.hasOwnProperty,
+        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
+    });
+}
+exports.hasPropFunc = hasPropFunc;
+function isOwnProperty(gen, data, property) {
+    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
+}
+exports.isOwnProperty = isOwnProperty;
+function propertyInData(gen, data, property, ownProperties) {
+    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
+    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
+}
+exports.propertyInData = propertyInData;
+function noPropertyInData(gen, data, property, ownProperties) {
+    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
+    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
+}
+exports.noPropertyInData = noPropertyInData;
+function allSchemaProperties(schemaMap) {
+    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
+}
+exports.allSchemaProperties = allSchemaProperties;
+function schemaProperties(it, schemaMap) {
+    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
+}
+exports.schemaProperties = schemaProperties;
+function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
+    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
+    const valCxt = [
+        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
+        [names_1.default.parentData, it.parentData],
+        [names_1.default.parentDataProperty, it.parentDataProperty],
+        [names_1.default.rootData, names_1.default.rootData],
+    ];
+    if (it.opts.dynamicRef)
+        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
+    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
+    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
+}
+exports.callValidateCode = callValidateCode;
+const newRegExp = (0, codegen_1._) `new RegExp`;
+function usePattern({ gen, it: { opts } }, pattern) {
+    const u = opts.unicodeRegExp ? "u" : "";
+    const { regExp } = opts.code;
+    const rx = regExp(pattern, u);
+    return gen.scopeValue("pattern", {
+        key: rx.toString(),
+        ref: rx,
+        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
+    });
+}
+exports.usePattern = usePattern;
+function validateArray(cxt) {
+    const { gen, data, keyword, it } = cxt;
+    const valid = gen.name("valid");
+    if (it.allErrors) {
+        const validArr = gen.let("valid", true);
+        validateItems(() => gen.assign(validArr, false));
+        return validArr;
+    }
+    gen.var(valid, true);
+    validateItems(() => gen.break());
+    return valid;
+    function validateItems(notValid) {
+        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
+        gen.forRange("i", 0, len, (i) => {
+            cxt.subschema({
+                keyword,
+                dataProp: i,
+                dataPropType: util_1.Type.Num,
+            }, valid);
+            gen.if((0, codegen_1.not)(valid), notValid);
+        });
+    }
+}
+exports.validateArray = validateArray;
+function validateUnion(cxt) {
+    const { gen, schema, keyword, it } = cxt;
+    /* istanbul ignore if */
+    if (!Array.isArray(schema))
+        throw new Error("ajv implementation error");
+    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
+    if (alwaysValid && !it.opts.unevaluated)
+        return;
+    const valid = gen.let("valid", false);
+    const schValid = gen.name("_valid");
+    gen.block(() => schema.forEach((_sch, i) => {
+        const schCxt = cxt.subschema({
+            keyword,
+            schemaProp: i,
+            compositeRule: true,
+        }, schValid);
+        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
+        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
+        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
+        // or if all properties and items were evaluated (it.props === true && it.items === true)
+        if (!merged)
+            gen.if((0, codegen_1.not)(valid));
+    }));
+    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
+}
+exports.validateUnion = validateUnion;
+//# sourceMappingURL=code.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/core/id.js b/node_modules/ajv/dist/vocabularies/core/id.js
index 313598a..8844f35 100644
--- a/node_modules/ajv/dist/vocabularies/core/id.js
+++ b/node_modules/ajv/dist/vocabularies/core/id.js
@@ -7,4 +7,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=id.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/core/id.js.bak b/node_modules/ajv/dist/vocabularies/core/id.js.bak
new file mode 100644
index 0000000..313598a
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/core/id.js.bak
@@ -0,0 +1,10 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const def = {
+    keyword: "id",
+    code() {
+        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
+    },
+};
+exports.default = def;
+//# sourceMappingURL=id.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/core/index.js b/node_modules/ajv/dist/vocabularies/core/index.js
index 87656d7..1bb6d73 100644
--- a/node_modules/ajv/dist/vocabularies/core/index.js
+++ b/node_modules/ajv/dist/vocabularies/core/index.js
@@ -13,4 +13,3 @@ const core = [
     ref_1.default,
 ];
 exports.default = core;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/core/index.js.bak b/node_modules/ajv/dist/vocabularies/core/index.js.bak
new file mode 100644
index 0000000..87656d7
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/core/index.js.bak
@@ -0,0 +1,16 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const id_1 = require("./id");
+const ref_1 = require("./ref");
+const core = [
+    "$schema",
+    "$id",
+    "$defs",
+    "$vocabulary",
+    { keyword: "$comment" },
+    "definitions",
+    id_1.default,
+    ref_1.default,
+];
+exports.default = core;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/core/ref.js b/node_modules/ajv/dist/vocabularies/core/ref.js
index bac1ae8..d2e4d13 100644
--- a/node_modules/ajv/dist/vocabularies/core/ref.js
+++ b/node_modules/ajv/dist/vocabularies/core/ref.js
@@ -119,4 +119,3 @@ function callRef(cxt, v, sch, $async) {
 }
 exports.callRef = callRef;
 exports.default = def;
-//# sourceMappingURL=ref.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/core/ref.js.bak b/node_modules/ajv/dist/vocabularies/core/ref.js.bak
new file mode 100644
index 0000000..bac1ae8
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/core/ref.js.bak
@@ -0,0 +1,122 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.callRef = exports.getValidate = void 0;
+const ref_error_1 = require("../../compile/ref_error");
+const code_1 = require("../code");
+const codegen_1 = require("../../compile/codegen");
+const names_1 = require("../../compile/names");
+const compile_1 = require("../../compile");
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: "$ref",
+    schemaType: "string",
+    code(cxt) {
+        const { gen, schema: $ref, it } = cxt;
+        const { baseId, schemaEnv: env, validateName, opts, self } = it;
+        const { root } = env;
+        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
+            return callRootRef();
+        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
+        if (schOrEnv === undefined)
+            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
+        if (schOrEnv instanceof compile_1.SchemaEnv)
+            return callValidate(schOrEnv);
+        return inlineRefSchema(schOrEnv);
+        function callRootRef() {
+            if (env === root)
+                return callRef(cxt, validateName, env, env.$async);
+            const rootName = gen.scopeValue("root", { ref: root });
+            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
+        }
+        function callValidate(sch) {
+            const v = getValidate(cxt, sch);
+            callRef(cxt, v, sch, sch.$async);
+        }
+        function inlineRefSchema(sch) {
+            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
+            const valid = gen.name("valid");
+            const schCxt = cxt.subschema({
+                schema: sch,
+                dataTypes: [],
+                schemaPath: codegen_1.nil,
+                topSchemaRef: schName,
+                errSchemaPath: $ref,
+            }, valid);
+            cxt.mergeEvaluated(schCxt);
+            cxt.ok(valid);
+        }
+    },
+};
+function getValidate(cxt, sch) {
+    const { gen } = cxt;
+    return sch.validate
+        ? gen.scopeValue("validate", { ref: sch.validate })
+        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
+}
+exports.getValidate = getValidate;
+function callRef(cxt, v, sch, $async) {
+    const { gen, it } = cxt;
+    const { allErrors, schemaEnv: env, opts } = it;
+    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
+    if ($async)
+        callAsyncRef();
+    else
+        callSyncRef();
+    function callAsyncRef() {
+        if (!env.$async)
+            throw new Error("async schema referenced by sync schema");
+        const valid = gen.let("valid");
+        gen.try(() => {
+            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
+            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
+            if (!allErrors)
+                gen.assign(valid, true);
+        }, (e) => {
+            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
+            addErrorsFrom(e);
+            if (!allErrors)
+                gen.assign(valid, false);
+        });
+        cxt.ok(valid);
+    }
+    function callSyncRef() {
+        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
+    }
+    function addErrorsFrom(source) {
+        const errs = (0, codegen_1._) `${source}.errors`;
+        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
+        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
+    }
+    function addEvaluatedFrom(source) {
+        var _a;
+        if (!it.opts.unevaluated)
+            return;
+        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
+        // TODO refactor
+        if (it.props !== true) {
+            if (schEvaluated && !schEvaluated.dynamicProps) {
+                if (schEvaluated.props !== undefined) {
+                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
+                }
+            }
+            else {
+                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
+                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
+            }
+        }
+        if (it.items !== true) {
+            if (schEvaluated && !schEvaluated.dynamicItems) {
+                if (schEvaluated.items !== undefined) {
+                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
+                }
+            }
+            else {
+                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
+                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
+            }
+        }
+    }
+}
+exports.callRef = callRef;
+exports.default = def;
+//# sourceMappingURL=ref.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/discriminator/index.js b/node_modules/ajv/dist/vocabularies/discriminator/index.js
index ccdb340..c7133ba 100644
--- a/node_modules/ajv/dist/vocabularies/discriminator/index.js
+++ b/node_modules/ajv/dist/vocabularies/discriminator/index.js
@@ -97,4 +97,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/discriminator/index.js.bak b/node_modules/ajv/dist/vocabularies/discriminator/index.js.bak
new file mode 100644
index 0000000..ccdb340
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/discriminator/index.js.bak
@@ -0,0 +1,100 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const types_1 = require("../discriminator/types");
+const compile_1 = require("../../compile");
+const util_1 = require("../../compile/util");
+const error = {
+    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
+        ? `tag "${tagName}" must be string`
+        : `value of tag "${tagName}" must be in oneOf`,
+    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
+};
+const def = {
+    keyword: "discriminator",
+    type: "object",
+    schemaType: "object",
+    error,
+    code(cxt) {
+        const { gen, data, schema, parentSchema, it } = cxt;
+        const { oneOf } = parentSchema;
+        if (!it.opts.discriminator) {
+            throw new Error("discriminator: requires discriminator option");
+        }
+        const tagName = schema.propertyName;
+        if (typeof tagName != "string")
+            throw new Error("discriminator: requires propertyName");
+        if (schema.mapping)
+            throw new Error("discriminator: mapping is not supported");
+        if (!oneOf)
+            throw new Error("discriminator: requires oneOf keyword");
+        const valid = gen.let("valid", false);
+        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
+        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
+        cxt.ok(valid);
+        function validateMapping() {
+            const mapping = getMapping();
+            gen.if(false);
+            for (const tagValue in mapping) {
+                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
+                gen.assign(valid, applyTagSchema(mapping[tagValue]));
+            }
+            gen.else();
+            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
+            gen.endIf();
+        }
+        function applyTagSchema(schemaProp) {
+            const _valid = gen.name("valid");
+            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
+            cxt.mergeEvaluated(schCxt, codegen_1.Name);
+            return _valid;
+        }
+        function getMapping() {
+            var _a;
+            const oneOfMapping = {};
+            const topRequired = hasRequired(parentSchema);
+            let tagRequired = true;
+            for (let i = 0; i < oneOf.length; i++) {
+                let sch = oneOf[i];
+                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
+                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
+                    if (sch instanceof compile_1.SchemaEnv)
+                        sch = sch.schema;
+                }
+                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
+                if (typeof propSch != "object") {
+                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
+                }
+                tagRequired = tagRequired && (topRequired || hasRequired(sch));
+                addMappings(propSch, i);
+            }
+            if (!tagRequired)
+                throw new Error(`discriminator: "${tagName}" must be required`);
+            return oneOfMapping;
+            function hasRequired({ required }) {
+                return Array.isArray(required) && required.includes(tagName);
+            }
+            function addMappings(sch, i) {
+                if (sch.const) {
+                    addMapping(sch.const, i);
+                }
+                else if (sch.enum) {
+                    for (const tagValue of sch.enum) {
+                        addMapping(tagValue, i);
+                    }
+                }
+                else {
+                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
+                }
+            }
+            function addMapping(tagValue, i) {
+                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
+                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
+                }
+                oneOfMapping[tagValue] = i;
+            }
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/discriminator/types.js b/node_modules/ajv/dist/vocabularies/discriminator/types.js
index d538f0c..276f760 100644
--- a/node_modules/ajv/dist/vocabularies/discriminator/types.js
+++ b/node_modules/ajv/dist/vocabularies/discriminator/types.js
@@ -6,4 +6,3 @@ var DiscrError;
     DiscrError["Tag"] = "tag";
     DiscrError["Mapping"] = "mapping";
 })(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
-//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/discriminator/types.js.bak b/node_modules/ajv/dist/vocabularies/discriminator/types.js.bak
new file mode 100644
index 0000000..d538f0c
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/discriminator/types.js.bak
@@ -0,0 +1,9 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DiscrError = void 0;
+var DiscrError;
+(function (DiscrError) {
+    DiscrError["Tag"] = "tag";
+    DiscrError["Mapping"] = "mapping";
+})(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
+//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/draft2020.js b/node_modules/ajv/dist/vocabularies/draft2020.js
index 23d244a..b01bcce 100644
--- a/node_modules/ajv/dist/vocabularies/draft2020.js
+++ b/node_modules/ajv/dist/vocabularies/draft2020.js
@@ -20,4 +20,3 @@ const draft2020Vocabularies = [
     unevaluated_1.default,
 ];
 exports.default = draft2020Vocabularies;
-//# sourceMappingURL=draft2020.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/draft2020.js.bak b/node_modules/ajv/dist/vocabularies/draft2020.js.bak
new file mode 100644
index 0000000..23d244a
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/draft2020.js.bak
@@ -0,0 +1,23 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const core_1 = require("./core");
+const validation_1 = require("./validation");
+const applicator_1 = require("./applicator");
+const dynamic_1 = require("./dynamic");
+const next_1 = require("./next");
+const unevaluated_1 = require("./unevaluated");
+const format_1 = require("./format");
+const metadata_1 = require("./metadata");
+const draft2020Vocabularies = [
+    dynamic_1.default,
+    core_1.default,
+    validation_1.default,
+    (0, applicator_1.default)(true),
+    format_1.default,
+    metadata_1.metadataVocabulary,
+    metadata_1.contentVocabulary,
+    next_1.default,
+    unevaluated_1.default,
+];
+exports.default = draft2020Vocabularies;
+//# sourceMappingURL=draft2020.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/draft7.js b/node_modules/ajv/dist/vocabularies/draft7.js
index 1e993de..5594e79 100644
--- a/node_modules/ajv/dist/vocabularies/draft7.js
+++ b/node_modules/ajv/dist/vocabularies/draft7.js
@@ -14,4 +14,3 @@ const draft7Vocabularies = [
     metadata_1.contentVocabulary,
 ];
 exports.default = draft7Vocabularies;
-//# sourceMappingURL=draft7.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/draft7.js.bak b/node_modules/ajv/dist/vocabularies/draft7.js.bak
new file mode 100644
index 0000000..1e993de
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/draft7.js.bak
@@ -0,0 +1,17 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const core_1 = require("./core");
+const validation_1 = require("./validation");
+const applicator_1 = require("./applicator");
+const format_1 = require("./format");
+const metadata_1 = require("./metadata");
+const draft7Vocabularies = [
+    core_1.default,
+    validation_1.default,
+    (0, applicator_1.default)(),
+    format_1.default,
+    metadata_1.metadataVocabulary,
+    metadata_1.contentVocabulary,
+];
+exports.default = draft7Vocabularies;
+//# sourceMappingURL=draft7.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js b/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js
index 972dc35..4866a6f 100644
--- a/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js
+++ b/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js
@@ -27,4 +27,3 @@ function _getValidate(cxt) {
     return (0, ref_1.getValidate)(cxt, sch);
 }
 exports.default = def;
-//# sourceMappingURL=dynamicAnchor.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js.bak b/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js.bak
new file mode 100644
index 0000000..972dc35
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js.bak
@@ -0,0 +1,30 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.dynamicAnchor = void 0;
+const codegen_1 = require("../../compile/codegen");
+const names_1 = require("../../compile/names");
+const compile_1 = require("../../compile");
+const ref_1 = require("../core/ref");
+const def = {
+    keyword: "$dynamicAnchor",
+    schemaType: "string",
+    code: (cxt) => dynamicAnchor(cxt, cxt.schema),
+};
+function dynamicAnchor(cxt, anchor) {
+    const { gen, it } = cxt;
+    it.schemaEnv.root.dynamicAnchors[anchor] = true;
+    const v = (0, codegen_1._) `${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;
+    const validate = it.errSchemaPath === "#" ? it.validateName : _getValidate(cxt);
+    gen.if((0, codegen_1._) `!${v}`, () => gen.assign(v, validate));
+}
+exports.dynamicAnchor = dynamicAnchor;
+function _getValidate(cxt) {
+    const { schemaEnv, schema, self } = cxt.it;
+    const { root, baseId, localRefs, meta } = schemaEnv.root;
+    const { schemaId } = self.opts;
+    const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });
+    compile_1.compileSchema.call(self, sch);
+    return (0, ref_1.getValidate)(cxt, sch);
+}
+exports.default = def;
+//# sourceMappingURL=dynamicAnchor.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js b/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js
index 9f010a0..3e8d412 100644
--- a/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js
+++ b/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js
@@ -48,4 +48,3 @@ function dynamicRef(cxt, ref) {
 }
 exports.dynamicRef = dynamicRef;
 exports.default = def;
-//# sourceMappingURL=dynamicRef.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js.bak b/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js.bak
new file mode 100644
index 0000000..9f010a0
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js.bak
@@ -0,0 +1,51 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.dynamicRef = void 0;
+const codegen_1 = require("../../compile/codegen");
+const names_1 = require("../../compile/names");
+const ref_1 = require("../core/ref");
+const def = {
+    keyword: "$dynamicRef",
+    schemaType: "string",
+    code: (cxt) => dynamicRef(cxt, cxt.schema),
+};
+function dynamicRef(cxt, ref) {
+    const { gen, keyword, it } = cxt;
+    if (ref[0] !== "#")
+        throw new Error(`"${keyword}" only supports hash fragment reference`);
+    const anchor = ref.slice(1);
+    if (it.allErrors) {
+        _dynamicRef();
+    }
+    else {
+        const valid = gen.let("valid", false);
+        _dynamicRef(valid);
+        cxt.ok(valid);
+    }
+    function _dynamicRef(valid) {
+        // TODO the assumption here is that `recursiveRef: #` always points to the root
+        // of the schema object, which is not correct, because there may be $id that
+        // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.
+        // Because of that 2 tests in recursiveRef.json fail.
+        // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ "$ref": "#" }`).
+        // (This problem is not tested in JSON-Schema-Test-Suite)
+        if (it.schemaEnv.root.dynamicAnchors[anchor]) {
+            const v = gen.let("_v", (0, codegen_1._) `${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);
+            gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
+        }
+        else {
+            _callRef(it.validateName, valid)();
+        }
+    }
+    function _callRef(validate, valid) {
+        return valid
+            ? () => gen.block(() => {
+                (0, ref_1.callRef)(cxt, validate);
+                gen.let(valid, true);
+            })
+            : () => (0, ref_1.callRef)(cxt, validate);
+    }
+}
+exports.dynamicRef = dynamicRef;
+exports.default = def;
+//# sourceMappingURL=dynamicRef.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/index.js b/node_modules/ajv/dist/vocabularies/dynamic/index.js
index f2388a7..04f794d 100644
--- a/node_modules/ajv/dist/vocabularies/dynamic/index.js
+++ b/node_modules/ajv/dist/vocabularies/dynamic/index.js
@@ -6,4 +6,3 @@ const recursiveAnchor_1 = require("./recursiveAnchor");
 const recursiveRef_1 = require("./recursiveRef");
 const dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
 exports.default = dynamic;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/index.js.bak b/node_modules/ajv/dist/vocabularies/dynamic/index.js.bak
new file mode 100644
index 0000000..f2388a7
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/dynamic/index.js.bak
@@ -0,0 +1,9 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dynamicAnchor_1 = require("./dynamicAnchor");
+const dynamicRef_1 = require("./dynamicRef");
+const recursiveAnchor_1 = require("./recursiveAnchor");
+const recursiveRef_1 = require("./recursiveRef");
+const dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
+exports.default = dynamic;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js b/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js
index 9fd8323..ab8f22d 100644
--- a/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js
+++ b/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js
@@ -13,4 +13,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=recursiveAnchor.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js.bak b/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js.bak
new file mode 100644
index 0000000..9fd8323
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js.bak
@@ -0,0 +1,16 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dynamicAnchor_1 = require("./dynamicAnchor");
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: "$recursiveAnchor",
+    schemaType: "boolean",
+    code(cxt) {
+        if (cxt.schema)
+            (0, dynamicAnchor_1.dynamicAnchor)(cxt, "");
+        else
+            (0, util_1.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
+    },
+};
+exports.default = def;
+//# sourceMappingURL=recursiveAnchor.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js b/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js
index 8cd5c69..cc3f0a7 100644
--- a/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js
+++ b/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js
@@ -7,4 +7,3 @@ const def = {
     code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema),
 };
 exports.default = def;
-//# sourceMappingURL=recursiveRef.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js.bak b/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js.bak
new file mode 100644
index 0000000..8cd5c69
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js.bak
@@ -0,0 +1,10 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dynamicRef_1 = require("./dynamicRef");
+const def = {
+    keyword: "$recursiveRef",
+    schemaType: "string",
+    code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema),
+};
+exports.default = def;
+//# sourceMappingURL=recursiveRef.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/errors.js b/node_modules/ajv/dist/vocabularies/errors.js
index d4d3fba..c8ad2e5 100644
--- a/node_modules/ajv/dist/vocabularies/errors.js
+++ b/node_modules/ajv/dist/vocabularies/errors.js
@@ -1,3 +1,2 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-//# sourceMappingURL=errors.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/errors.js.bak b/node_modules/ajv/dist/vocabularies/errors.js.bak
new file mode 100644
index 0000000..d4d3fba
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/errors.js.bak
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+//# sourceMappingURL=errors.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/format/format.js b/node_modules/ajv/dist/vocabularies/format/format.js
index aa667c1..1b2ca0e 100644
--- a/node_modules/ajv/dist/vocabularies/format/format.js
+++ b/node_modules/ajv/dist/vocabularies/format/format.js
@@ -89,4 +89,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=format.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/format/format.js.bak b/node_modules/ajv/dist/vocabularies/format/format.js.bak
new file mode 100644
index 0000000..aa667c1
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/format/format.js.bak
@@ -0,0 +1,92 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const error = {
+    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
+    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
+};
+const def = {
+    keyword: "format",
+    type: ["number", "string"],
+    schemaType: "string",
+    $data: true,
+    error,
+    code(cxt, ruleType) {
+        const { gen, data, $data, schema, schemaCode, it } = cxt;
+        const { opts, errSchemaPath, schemaEnv, self } = it;
+        if (!opts.validateFormats)
+            return;
+        if ($data)
+            validate$DataFormat();
+        else
+            validateFormat();
+        function validate$DataFormat() {
+            const fmts = gen.scopeValue("formats", {
+                ref: self.formats,
+                code: opts.code.formats,
+            });
+            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
+            const fType = gen.let("fType");
+            const format = gen.let("format");
+            // TODO simplify
+            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
+            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
+            function unknownFmt() {
+                if (opts.strictSchema === false)
+                    return codegen_1.nil;
+                return (0, codegen_1._) `${schemaCode} && !${format}`;
+            }
+            function invalidFmt() {
+                const callFormat = schemaEnv.$async
+                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
+                    : (0, codegen_1._) `${format}(${data})`;
+                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
+                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
+            }
+        }
+        function validateFormat() {
+            const formatDef = self.formats[schema];
+            if (!formatDef) {
+                unknownFormat();
+                return;
+            }
+            if (formatDef === true)
+                return;
+            const [fmtType, format, fmtRef] = getFormat(formatDef);
+            if (fmtType === ruleType)
+                cxt.pass(validCondition());
+            function unknownFormat() {
+                if (opts.strictSchema === false) {
+                    self.logger.warn(unknownMsg());
+                    return;
+                }
+                throw new Error(unknownMsg());
+                function unknownMsg() {
+                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
+                }
+            }
+            function getFormat(fmtDef) {
+                const code = fmtDef instanceof RegExp
+                    ? (0, codegen_1.regexpCode)(fmtDef)
+                    : opts.code.formats
+                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
+                        : undefined;
+                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
+                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
+                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
+                }
+                return ["string", fmtDef, fmt];
+            }
+            function validCondition() {
+                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
+                    if (!schemaEnv.$async)
+                        throw new Error("async format in sync schema");
+                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
+                }
+                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
+            }
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=format.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/format/index.js b/node_modules/ajv/dist/vocabularies/format/index.js
index d19023d..cb8b0df 100644
--- a/node_modules/ajv/dist/vocabularies/format/index.js
+++ b/node_modules/ajv/dist/vocabularies/format/index.js
@@ -3,4 +3,3 @@ Object.defineProperty(exports, "__esModule", { value: true });
 const format_1 = require("./format");
 const format = [format_1.default];
 exports.default = format;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/format/index.js.bak b/node_modules/ajv/dist/vocabularies/format/index.js.bak
new file mode 100644
index 0000000..d19023d
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/format/index.js.bak
@@ -0,0 +1,6 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const format_1 = require("./format");
+const format = [format_1.default];
+exports.default = format;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/discriminator.js b/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
index e7074d2..7e8ea8e 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
@@ -68,4 +68,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=discriminator.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/discriminator.js.bak b/node_modules/ajv/dist/vocabularies/jtd/discriminator.js.bak
new file mode 100644
index 0000000..e7074d2
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/discriminator.js.bak
@@ -0,0 +1,71 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const metadata_1 = require("./metadata");
+const nullable_1 = require("./nullable");
+const error_1 = require("./error");
+const types_1 = require("../discriminator/types");
+const error = {
+    message: (cxt) => {
+        const { schema, params } = cxt;
+        return params.discrError
+            ? params.discrError === types_1.DiscrError.Tag
+                ? `tag "${schema}" must be string`
+                : `value of tag "${schema}" must be in mapping`
+            : (0, error_1.typeErrorMessage)(cxt, "object");
+    },
+    params: (cxt) => {
+        const { schema, params } = cxt;
+        return params.discrError
+            ? (0, codegen_1._) `{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`
+            : (0, error_1.typeErrorParams)(cxt, "object");
+    },
+};
+const def = {
+    keyword: "discriminator",
+    schemaType: "string",
+    implements: ["mapping"],
+    error,
+    code(cxt) {
+        (0, metadata_1.checkMetadata)(cxt);
+        const { gen, data, schema, parentSchema } = cxt;
+        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
+        gen.if(cond);
+        validateDiscriminator();
+        gen.elseIf((0, codegen_1.not)(valid));
+        cxt.error();
+        gen.endIf();
+        cxt.ok(valid);
+        function validateDiscriminator() {
+            const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(schema)}`);
+            gen.if((0, codegen_1._) `${tag} === undefined`);
+            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
+            gen.elseIf((0, codegen_1._) `typeof ${tag} == "string"`);
+            validateMapping(tag);
+            gen.else();
+            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
+            gen.endIf();
+        }
+        function validateMapping(tag) {
+            gen.if(false);
+            for (const tagValue in parentSchema.mapping) {
+                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
+                gen.assign(valid, applyTagSchema(tagValue));
+            }
+            gen.else();
+            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
+            gen.endIf();
+        }
+        function applyTagSchema(schemaProp) {
+            const _valid = gen.name("valid");
+            cxt.subschema({
+                keyword: "mapping",
+                schemaProp,
+                jtdDiscriminator: schema,
+            }, _valid);
+            return _valid;
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=discriminator.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/elements.js b/node_modules/ajv/dist/vocabularies/jtd/elements.js
index 9b8fb54..8e35ab5 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/elements.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/elements.js
@@ -21,4 +21,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=elements.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/elements.js.bak b/node_modules/ajv/dist/vocabularies/jtd/elements.js.bak
new file mode 100644
index 0000000..9b8fb54
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/elements.js.bak
@@ -0,0 +1,24 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const util_1 = require("../../compile/util");
+const code_1 = require("../code");
+const codegen_1 = require("../../compile/codegen");
+const metadata_1 = require("./metadata");
+const nullable_1 = require("./nullable");
+const error_1 = require("./error");
+const def = {
+    keyword: "elements",
+    schemaType: "object",
+    error: (0, error_1.typeError)("array"),
+    code(cxt) {
+        (0, metadata_1.checkMetadata)(cxt);
+        const { gen, data, schema, it } = cxt;
+        if ((0, util_1.alwaysValidSchema)(it, schema))
+            return;
+        const [valid] = (0, nullable_1.checkNullable)(cxt);
+        gen.if((0, codegen_1.not)(valid), () => gen.if((0, codegen_1._) `Array.isArray(${data})`, () => gen.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
+        cxt.ok(valid);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=elements.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/enum.js b/node_modules/ajv/dist/vocabularies/jtd/enum.js
index 78b01ee..ce274a6 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/enum.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/enum.js
@@ -40,4 +40,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=enum.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/enum.js.bak b/node_modules/ajv/dist/vocabularies/jtd/enum.js.bak
new file mode 100644
index 0000000..78b01ee
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/enum.js.bak
@@ -0,0 +1,43 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const metadata_1 = require("./metadata");
+const nullable_1 = require("./nullable");
+const error = {
+    message: "must be equal to one of the allowed values",
+    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
+};
+const def = {
+    keyword: "enum",
+    schemaType: "array",
+    error,
+    code(cxt) {
+        (0, metadata_1.checkMetadata)(cxt);
+        const { gen, data, schema, schemaValue, parentSchema, it } = cxt;
+        if (schema.length === 0)
+            throw new Error("enum must have non-empty array");
+        if (schema.length !== new Set(schema).size)
+            throw new Error("enum items must be unique");
+        let valid;
+        const isString = (0, codegen_1._) `typeof ${data} == "string"`;
+        if (schema.length >= it.opts.loopEnum) {
+            let cond;
+            [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
+            gen.if(cond, loopEnum);
+        }
+        else {
+            /* istanbul ignore if */
+            if (!Array.isArray(schema))
+                throw new Error("ajv implementation error");
+            valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._) `${data} === ${value}`)));
+            if (parentSchema.nullable)
+                valid = (0, codegen_1.or)((0, codegen_1._) `${data} === null`, valid);
+        }
+        cxt.pass(valid);
+        function loopEnum() {
+            gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1._) `${valid} = ${data} === ${v}`, () => gen.break()));
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=enum.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/error.js b/node_modules/ajv/dist/vocabularies/jtd/error.js
index 1a3920a..7c4ca57 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/error.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/error.js
@@ -17,4 +17,3 @@ function typeErrorParams({ parentSchema }, t) {
     return (0, codegen_1._) `{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
 }
 exports.typeErrorParams = typeErrorParams;
-//# sourceMappingURL=error.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/error.js.bak b/node_modules/ajv/dist/vocabularies/jtd/error.js.bak
new file mode 100644
index 0000000..1a3920a
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/error.js.bak
@@ -0,0 +1,20 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.typeErrorParams = exports.typeErrorMessage = exports.typeError = void 0;
+const codegen_1 = require("../../compile/codegen");
+function typeError(t) {
+    return {
+        message: (cxt) => typeErrorMessage(cxt, t),
+        params: (cxt) => typeErrorParams(cxt, t),
+    };
+}
+exports.typeError = typeError;
+function typeErrorMessage({ parentSchema }, t) {
+    return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
+}
+exports.typeErrorMessage = typeErrorMessage;
+function typeErrorParams({ parentSchema }, t) {
+    return (0, codegen_1._) `{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
+}
+exports.typeErrorParams = typeErrorParams;
+//# sourceMappingURL=error.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/index.js b/node_modules/ajv/dist/vocabularies/jtd/index.js
index 18f40ab..ffd69a0 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/index.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/index.js
@@ -26,4 +26,3 @@ const jtdVocabulary = [
     { keyword: "nullable", schemaType: "boolean" },
 ];
 exports.default = jtdVocabulary;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/index.js.bak b/node_modules/ajv/dist/vocabularies/jtd/index.js.bak
new file mode 100644
index 0000000..18f40ab
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/index.js.bak
@@ -0,0 +1,29 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const ref_1 = require("./ref");
+const type_1 = require("./type");
+const enum_1 = require("./enum");
+const elements_1 = require("./elements");
+const properties_1 = require("./properties");
+const optionalProperties_1 = require("./optionalProperties");
+const discriminator_1 = require("./discriminator");
+const values_1 = require("./values");
+const union_1 = require("./union");
+const metadata_1 = require("./metadata");
+const jtdVocabulary = [
+    "definitions",
+    ref_1.default,
+    type_1.default,
+    enum_1.default,
+    elements_1.default,
+    properties_1.default,
+    optionalProperties_1.default,
+    discriminator_1.default,
+    values_1.default,
+    union_1.default,
+    metadata_1.default,
+    { keyword: "additionalProperties", schemaType: "boolean" },
+    { keyword: "nullable", schemaType: "boolean" },
+];
+exports.default = jtdVocabulary;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/metadata.js b/node_modules/ajv/dist/vocabularies/jtd/metadata.js
index eeb3c91..0aa3a01 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/metadata.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/metadata.js
@@ -22,4 +22,3 @@ function checkMetadata({ it, keyword }, metadata) {
 }
 exports.checkMetadata = checkMetadata;
 exports.default = def;
-//# sourceMappingURL=metadata.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/metadata.js.bak b/node_modules/ajv/dist/vocabularies/jtd/metadata.js.bak
new file mode 100644
index 0000000..eeb3c91
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/metadata.js.bak
@@ -0,0 +1,25 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.checkMetadata = void 0;
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: "metadata",
+    schemaType: "object",
+    code(cxt) {
+        checkMetadata(cxt);
+        const { gen, schema, it } = cxt;
+        if ((0, util_1.alwaysValidSchema)(it, schema))
+            return;
+        const valid = gen.name("valid");
+        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
+        cxt.ok(valid);
+    },
+};
+function checkMetadata({ it, keyword }, metadata) {
+    if (it.jtdMetadata !== metadata) {
+        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
+    }
+}
+exports.checkMetadata = checkMetadata;
+exports.default = def;
+//# sourceMappingURL=metadata.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/nullable.js b/node_modules/ajv/dist/vocabularies/jtd/nullable.js
index 8c92d2c..2564aed 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/nullable.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/nullable.js
@@ -19,4 +19,3 @@ function checkNullableObject(cxt, cond) {
     return [valid, (0, codegen_1._) `${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
 }
 exports.checkNullableObject = checkNullableObject;
-//# sourceMappingURL=nullable.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/nullable.js.bak b/node_modules/ajv/dist/vocabularies/jtd/nullable.js.bak
new file mode 100644
index 0000000..8c92d2c
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/nullable.js.bak
@@ -0,0 +1,22 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.checkNullableObject = exports.checkNullable = void 0;
+const codegen_1 = require("../../compile/codegen");
+function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
+    const valid = gen.name("valid");
+    if (parentSchema.nullable) {
+        gen.let(valid, (0, codegen_1._) `${data} === null`);
+        cond = (0, codegen_1.not)(valid);
+    }
+    else {
+        gen.let(valid, false);
+    }
+    return [valid, cond];
+}
+exports.checkNullable = checkNullable;
+function checkNullableObject(cxt, cond) {
+    const [valid, cond_] = checkNullable(cxt, cond);
+    return [valid, (0, codegen_1._) `${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
+}
+exports.checkNullableObject = checkNullableObject;
+//# sourceMappingURL=nullable.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js b/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
index fe27275..49a6dd0 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
@@ -12,4 +12,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=optionalProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js.bak b/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js.bak
new file mode 100644
index 0000000..fe27275
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js.bak
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const properties_1 = require("./properties");
+const def = {
+    keyword: "optionalProperties",
+    schemaType: "object",
+    error: properties_1.error,
+    code(cxt) {
+        if (cxt.parentSchema.properties)
+            return;
+        (0, properties_1.validateProperties)(cxt);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=optionalProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/properties.js b/node_modules/ajv/dist/vocabularies/jtd/properties.js
index f4e9de4..f348f9b 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/properties.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/properties.js
@@ -146,4 +146,3 @@ function validateProperties(cxt) {
 }
 exports.validateProperties = validateProperties;
 exports.default = def;
-//# sourceMappingURL=properties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/properties.js.bak b/node_modules/ajv/dist/vocabularies/jtd/properties.js.bak
new file mode 100644
index 0000000..f4e9de4
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/properties.js.bak
@@ -0,0 +1,149 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.validateProperties = exports.error = void 0;
+const code_1 = require("../code");
+const util_1 = require("../../compile/util");
+const codegen_1 = require("../../compile/codegen");
+const metadata_1 = require("./metadata");
+const nullable_1 = require("./nullable");
+const error_1 = require("./error");
+var PropError;
+(function (PropError) {
+    PropError["Additional"] = "additional";
+    PropError["Missing"] = "missing";
+})(PropError || (PropError = {}));
+exports.error = {
+    message: (cxt) => {
+        const { params } = cxt;
+        return params.propError
+            ? params.propError === PropError.Additional
+                ? "must NOT have additional properties"
+                : `must have property '${params.missingProperty}'`
+            : (0, error_1.typeErrorMessage)(cxt, "object");
+    },
+    params: (cxt) => {
+        const { params } = cxt;
+        return params.propError
+            ? params.propError === PropError.Additional
+                ? (0, codegen_1._) `{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}`
+                : (0, codegen_1._) `{error: ${params.propError}, missingProperty: ${params.missingProperty}}`
+            : (0, error_1.typeErrorParams)(cxt, "object");
+    },
+};
+const def = {
+    keyword: "properties",
+    schemaType: "object",
+    error: exports.error,
+    code: validateProperties,
+};
+// const error: KeywordErrorDefinition = {
+//   message: "should NOT have additional properties",
+//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,
+// }
+function validateProperties(cxt) {
+    (0, metadata_1.checkMetadata)(cxt);
+    const { gen, data, parentSchema, it } = cxt;
+    const { additionalProperties, nullable } = parentSchema;
+    if (it.jtdDiscriminator && nullable)
+        throw new Error("JTD: nullable inside discriminator mapping");
+    if (commonProperties()) {
+        throw new Error("JTD: properties and optionalProperties have common members");
+    }
+    const [allProps, properties] = schemaProperties("properties");
+    const [allOptProps, optProperties] = schemaProperties("optionalProperties");
+    if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
+        return;
+    }
+    const [valid, cond] = it.jtdDiscriminator === undefined
+        ? (0, nullable_1.checkNullableObject)(cxt, data)
+        : [gen.let("valid", false), true];
+    gen.if(cond, () => gen.assign(valid, true).block(() => {
+        validateProps(properties, "properties", true);
+        validateProps(optProperties, "optionalProperties");
+        if (!additionalProperties)
+            validateAdditional();
+    }));
+    cxt.pass(valid);
+    function commonProperties() {
+        const props = parentSchema.properties;
+        const optProps = parentSchema.optionalProperties;
+        if (!(props && optProps))
+            return false;
+        for (const p in props) {
+            if (Object.prototype.hasOwnProperty.call(optProps, p))
+                return true;
+        }
+        return false;
+    }
+    function schemaProperties(keyword) {
+        const schema = parentSchema[keyword];
+        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
+        if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
+            throw new Error(`JTD: discriminator tag used in ${keyword}`);
+        }
+        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
+        return [allPs, ps];
+    }
+    function validateProps(props, keyword, required) {
+        const _valid = gen.var("valid");
+        for (const prop of props) {
+            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
+            cxt.ok(_valid);
+        }
+        function missingProperty(prop) {
+            if (required) {
+                gen.assign(_valid, false);
+                cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
+            }
+            else {
+                gen.assign(_valid, true);
+            }
+        }
+    }
+    function applyPropertySchema(prop, keyword, _valid) {
+        cxt.subschema({
+            keyword,
+            schemaProp: prop,
+            dataProp: prop,
+        }, _valid);
+    }
+    function validateAdditional() {
+        gen.forIn("key", data, (key) => {
+            const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
+            const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
+            const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
+            gen.if(extra, () => {
+                if (it.opts.removeAdditional) {
+                    gen.code((0, codegen_1._) `delete ${data}[${key}]`);
+                }
+                else {
+                    cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
+                    if (!it.opts.allErrors)
+                        gen.break();
+                }
+            });
+        });
+    }
+    function isAdditional(key, props, keyword, jtdDiscriminator) {
+        let additional;
+        if (props.length > 8) {
+            // TODO maybe an option instead of hard-coded 8?
+            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
+            additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
+            if (jtdDiscriminator !== undefined) {
+                additional = (0, codegen_1.and)(additional, (0, codegen_1._) `${key} !== ${jtdDiscriminator}`);
+            }
+        }
+        else if (props.length || jtdDiscriminator !== undefined) {
+            const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);
+            additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`));
+        }
+        else {
+            additional = true;
+        }
+        return additional;
+    }
+}
+exports.validateProperties = validateProperties;
+exports.default = def;
+//# sourceMappingURL=properties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/ref.js b/node_modules/ajv/dist/vocabularies/jtd/ref.js
index b7c6b02..b52daf0 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/ref.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/ref.js
@@ -64,4 +64,3 @@ function hasRef(schema) {
 }
 exports.hasRef = hasRef;
 exports.default = def;
-//# sourceMappingURL=ref.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/ref.js.bak b/node_modules/ajv/dist/vocabularies/jtd/ref.js.bak
new file mode 100644
index 0000000..b7c6b02
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/ref.js.bak
@@ -0,0 +1,67 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.hasRef = void 0;
+const compile_1 = require("../../compile");
+const codegen_1 = require("../../compile/codegen");
+const ref_error_1 = require("../../compile/ref_error");
+const names_1 = require("../../compile/names");
+const ref_1 = require("../core/ref");
+const metadata_1 = require("./metadata");
+const def = {
+    keyword: "ref",
+    schemaType: "string",
+    code(cxt) {
+        (0, metadata_1.checkMetadata)(cxt);
+        const { gen, data, schema: ref, parentSchema, it } = cxt;
+        const { schemaEnv: { root }, } = it;
+        const valid = gen.name("valid");
+        if (parentSchema.nullable) {
+            gen.var(valid, (0, codegen_1._) `${data} === null`);
+            gen.if((0, codegen_1.not)(valid), validateJtdRef);
+        }
+        else {
+            gen.var(valid, false);
+            validateJtdRef();
+        }
+        cxt.ok(valid);
+        function validateJtdRef() {
+            var _a;
+            const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];
+            if (!refSchema) {
+                throw new ref_error_1.default(it.opts.uriResolver, "", ref, `No definition ${ref}`);
+            }
+            if (hasRef(refSchema) || !it.opts.inlineRefs)
+                callValidate(refSchema);
+            else
+                inlineRefSchema(refSchema);
+        }
+        function callValidate(schema) {
+            const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
+            const v = (0, ref_1.getValidate)(cxt, sch);
+            const errsCount = gen.const("_errs", names_1.default.errors);
+            (0, ref_1.callRef)(cxt, v, sch, sch.$async);
+            gen.assign(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
+        }
+        function inlineRefSchema(schema) {
+            const schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
+            cxt.subschema({
+                schema,
+                dataTypes: [],
+                schemaPath: codegen_1.nil,
+                topSchemaRef: schName,
+                errSchemaPath: `/definitions/${ref}`,
+            }, valid);
+        }
+    },
+};
+function hasRef(schema) {
+    for (const key in schema) {
+        let sch;
+        if (key === "ref" || (typeof (sch = schema[key]) == "object" && hasRef(sch)))
+            return true;
+    }
+    return false;
+}
+exports.hasRef = hasRef;
+exports.default = def;
+//# sourceMappingURL=ref.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/type.js b/node_modules/ajv/dist/vocabularies/jtd/type.js
index 17a0b51..f84d023 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/type.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/type.js
@@ -66,4 +66,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=type.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/type.js.bak b/node_modules/ajv/dist/vocabularies/jtd/type.js.bak
new file mode 100644
index 0000000..17a0b51
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/type.js.bak
@@ -0,0 +1,69 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.intRange = void 0;
+const codegen_1 = require("../../compile/codegen");
+const timestamp_1 = require("../../runtime/timestamp");
+const util_1 = require("../../compile/util");
+const metadata_1 = require("./metadata");
+const error_1 = require("./error");
+exports.intRange = {
+    int8: [-128, 127, 3],
+    uint8: [0, 255, 3],
+    int16: [-32768, 32767, 5],
+    uint16: [0, 65535, 5],
+    int32: [-2147483648, 2147483647, 10],
+    uint32: [0, 4294967295, 10],
+};
+const error = {
+    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
+    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema),
+};
+function timestampCode(cxt) {
+    const { gen, data, it } = cxt;
+    const { timestamp, allowDate } = it.opts;
+    if (timestamp === "date")
+        return (0, codegen_1._) `${data} instanceof Date `;
+    const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
+    const allowDateArg = allowDate ? (0, codegen_1._) `, true` : codegen_1.nil;
+    const validString = (0, codegen_1._) `typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
+    return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._) `${data} instanceof Date`, validString);
+}
+const def = {
+    keyword: "type",
+    schemaType: "string",
+    error,
+    code(cxt) {
+        (0, metadata_1.checkMetadata)(cxt);
+        const { data, schema, parentSchema, it } = cxt;
+        let cond;
+        switch (schema) {
+            case "boolean":
+            case "string":
+                cond = (0, codegen_1._) `typeof ${data} == ${schema}`;
+                break;
+            case "timestamp": {
+                cond = timestampCode(cxt);
+                break;
+            }
+            case "float32":
+            case "float64":
+                cond = (0, codegen_1._) `typeof ${data} == "number"`;
+                break;
+            default: {
+                const sch = schema;
+                cond = (0, codegen_1._) `typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
+                if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
+                    if (sch === "uint32")
+                        cond = (0, codegen_1._) `${cond} && ${data} >= 0`;
+                }
+                else {
+                    const [min, max] = exports.intRange[sch];
+                    cond = (0, codegen_1._) `${cond} && ${data} >= ${min} && ${data} <= ${max}`;
+                }
+            }
+        }
+        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._) `${data} === null`, cond) : cond);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=type.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/union.js b/node_modules/ajv/dist/vocabularies/jtd/union.js
index 01a9439..9985cf8 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/union.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/union.js
@@ -9,4 +9,3 @@ const def = {
     error: { message: "must match a schema in union" },
 };
 exports.default = def;
-//# sourceMappingURL=union.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/union.js.bak b/node_modules/ajv/dist/vocabularies/jtd/union.js.bak
new file mode 100644
index 0000000..01a9439
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/union.js.bak
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const code_1 = require("../code");
+const def = {
+    keyword: "union",
+    schemaType: "array",
+    trackErrors: true,
+    code: code_1.validateUnion,
+    error: { message: "must match a schema in union" },
+};
+exports.default = def;
+//# sourceMappingURL=union.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/values.js b/node_modules/ajv/dist/vocabularies/jtd/values.js
index 3c2c95f..c1e1432 100644
--- a/node_modules/ajv/dist/vocabularies/jtd/values.js
+++ b/node_modules/ajv/dist/vocabularies/jtd/values.js
@@ -48,4 +48,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=values.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/jtd/values.js.bak b/node_modules/ajv/dist/vocabularies/jtd/values.js.bak
new file mode 100644
index 0000000..3c2c95f
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/jtd/values.js.bak
@@ -0,0 +1,51 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const util_1 = require("../../compile/util");
+const codegen_1 = require("../../compile/codegen");
+const metadata_1 = require("./metadata");
+const nullable_1 = require("./nullable");
+const error_1 = require("./error");
+const def = {
+    keyword: "values",
+    schemaType: "object",
+    error: (0, error_1.typeError)("object"),
+    code(cxt) {
+        (0, metadata_1.checkMetadata)(cxt);
+        const { gen, data, schema, it } = cxt;
+        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
+        if ((0, util_1.alwaysValidSchema)(it, schema)) {
+            gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
+        }
+        else {
+            gen.if(cond);
+            gen.assign(valid, validateMap());
+            gen.elseIf((0, codegen_1.not)(valid));
+            cxt.error();
+            gen.endIf();
+        }
+        cxt.ok(valid);
+        function validateMap() {
+            const _valid = gen.name("valid");
+            if (it.allErrors) {
+                const validMap = gen.let("valid", true);
+                validateValues(() => gen.assign(validMap, false));
+                return validMap;
+            }
+            gen.var(_valid, true);
+            validateValues(() => gen.break());
+            return _valid;
+            function validateValues(notValid) {
+                gen.forIn("key", data, (key) => {
+                    cxt.subschema({
+                        keyword: "values",
+                        dataProp: key,
+                        dataPropType: util_1.Type.Str,
+                    }, _valid);
+                    gen.if((0, codegen_1.not)(_valid), notValid);
+                });
+            }
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=values.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/metadata.js b/node_modules/ajv/dist/vocabularies/metadata.js
index f07bf28..8be9473 100644
--- a/node_modules/ajv/dist/vocabularies/metadata.js
+++ b/node_modules/ajv/dist/vocabularies/metadata.js
@@ -15,4 +15,3 @@ exports.contentVocabulary = [
     "contentEncoding",
     "contentSchema",
 ];
-//# sourceMappingURL=metadata.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/metadata.js.bak b/node_modules/ajv/dist/vocabularies/metadata.js.bak
new file mode 100644
index 0000000..f07bf28
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/metadata.js.bak
@@ -0,0 +1,18 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.contentVocabulary = exports.metadataVocabulary = void 0;
+exports.metadataVocabulary = [
+    "title",
+    "description",
+    "default",
+    "deprecated",
+    "readOnly",
+    "writeOnly",
+    "examples",
+];
+exports.contentVocabulary = [
+    "contentMediaType",
+    "contentEncoding",
+    "contentSchema",
+];
+//# sourceMappingURL=metadata.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/next.js b/node_modules/ajv/dist/vocabularies/next.js
index c861b32..1a6b715 100644
--- a/node_modules/ajv/dist/vocabularies/next.js
+++ b/node_modules/ajv/dist/vocabularies/next.js
@@ -5,4 +5,3 @@ const dependentSchemas_1 = require("./applicator/dependentSchemas");
 const limitContains_1 = require("./validation/limitContains");
 const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
 exports.default = next;
-//# sourceMappingURL=next.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/next.js.bak b/node_modules/ajv/dist/vocabularies/next.js.bak
new file mode 100644
index 0000000..c861b32
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/next.js.bak
@@ -0,0 +1,8 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dependentRequired_1 = require("./validation/dependentRequired");
+const dependentSchemas_1 = require("./applicator/dependentSchemas");
+const limitContains_1 = require("./validation/limitContains");
+const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
+exports.default = next;
+//# sourceMappingURL=next.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/unevaluated/index.js b/node_modules/ajv/dist/vocabularies/unevaluated/index.js
index 30e3167..9a08195 100644
--- a/node_modules/ajv/dist/vocabularies/unevaluated/index.js
+++ b/node_modules/ajv/dist/vocabularies/unevaluated/index.js
@@ -4,4 +4,3 @@ const unevaluatedProperties_1 = require("./unevaluatedProperties");
 const unevaluatedItems_1 = require("./unevaluatedItems");
 const unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
 exports.default = unevaluated;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/unevaluated/index.js.bak b/node_modules/ajv/dist/vocabularies/unevaluated/index.js.bak
new file mode 100644
index 0000000..30e3167
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/unevaluated/index.js.bak
@@ -0,0 +1,7 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const unevaluatedProperties_1 = require("./unevaluatedProperties");
+const unevaluatedItems_1 = require("./unevaluatedItems");
+const unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
+exports.default = unevaluated;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js
index 0a0cd3a..aca8868 100644
--- a/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js
+++ b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js
@@ -37,4 +37,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=unevaluatedItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js.bak b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js.bak
new file mode 100644
index 0000000..0a0cd3a
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js.bak
@@ -0,0 +1,40 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
+    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
+};
+const def = {
+    keyword: "unevaluatedItems",
+    type: "array",
+    schemaType: ["boolean", "object"],
+    error,
+    code(cxt) {
+        const { gen, schema, data, it } = cxt;
+        const items = it.items || 0;
+        if (items === true)
+            return;
+        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
+        if (schema === false) {
+            cxt.setParams({ len: items });
+            cxt.fail((0, codegen_1._) `${len} > ${items}`);
+        }
+        else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
+            const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items}`);
+            gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));
+            cxt.ok(valid);
+        }
+        it.items = true;
+        function validateItems(valid, from) {
+            gen.forRange("i", from, len, (i) => {
+                cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1.Type.Num }, valid);
+                if (!it.allErrors)
+                    gen.if((0, codegen_1.not)(valid), () => gen.break());
+            });
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=unevaluatedItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js
index ad29849..452a03d 100644
--- a/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js
+++ b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js
@@ -62,4 +62,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=unevaluatedProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js.bak b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js.bak
new file mode 100644
index 0000000..ad29849
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js.bak
@@ -0,0 +1,65 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const names_1 = require("../../compile/names");
+const error = {
+    message: "must NOT have unevaluated properties",
+    params: ({ params }) => (0, codegen_1._) `{unevaluatedProperty: ${params.unevaluatedProperty}}`,
+};
+const def = {
+    keyword: "unevaluatedProperties",
+    type: "object",
+    schemaType: ["boolean", "object"],
+    trackErrors: true,
+    error,
+    code(cxt) {
+        const { gen, schema, data, errsCount, it } = cxt;
+        /* istanbul ignore if */
+        if (!errsCount)
+            throw new Error("ajv implementation error");
+        const { allErrors, props } = it;
+        if (props instanceof codegen_1.Name) {
+            gen.if((0, codegen_1._) `${props} !== true`, () => gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
+        }
+        else if (props !== true) {
+            gen.forIn("key", data, (key) => props === undefined
+                ? unevaluatedPropCode(key)
+                : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
+        }
+        it.props = true;
+        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
+        function unevaluatedPropCode(key) {
+            if (schema === false) {
+                cxt.setParams({ unevaluatedProperty: key });
+                cxt.error();
+                if (!allErrors)
+                    gen.break();
+                return;
+            }
+            if (!(0, util_1.alwaysValidSchema)(it, schema)) {
+                const valid = gen.name("valid");
+                cxt.subschema({
+                    keyword: "unevaluatedProperties",
+                    dataProp: key,
+                    dataPropType: util_1.Type.Str,
+                }, valid);
+                if (!allErrors)
+                    gen.if((0, codegen_1.not)(valid), () => gen.break());
+            }
+        }
+        function unevaluatedDynamic(evaluatedProps, key) {
+            return (0, codegen_1._) `!${evaluatedProps} || !${evaluatedProps}[${key}]`;
+        }
+        function unevaluatedStatic(evaluatedProps, key) {
+            const ps = [];
+            for (const p in evaluatedProps) {
+                if (evaluatedProps[p] === true)
+                    ps.push((0, codegen_1._) `${key} !== ${p}`);
+            }
+            return (0, codegen_1.and)(...ps);
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=unevaluatedProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/const.js b/node_modules/ajv/dist/vocabularies/validation/const.js
index 9564496..91de2c6 100644
--- a/node_modules/ajv/dist/vocabularies/validation/const.js
+++ b/node_modules/ajv/dist/vocabularies/validation/const.js
@@ -22,4 +22,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=const.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/const.js.bak b/node_modules/ajv/dist/vocabularies/validation/const.js.bak
new file mode 100644
index 0000000..9564496
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/const.js.bak
@@ -0,0 +1,25 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const equal_1 = require("../../runtime/equal");
+const error = {
+    message: "must be equal to constant",
+    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
+};
+const def = {
+    keyword: "const",
+    $data: true,
+    error,
+    code(cxt) {
+        const { gen, data, $data, schemaCode, schema } = cxt;
+        if ($data || (schema && typeof schema == "object")) {
+            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
+        }
+        else {
+            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=const.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js b/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js
index 09e5963..f3cd32b 100644
--- a/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js
+++ b/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js
@@ -9,4 +9,3 @@ const def = {
     code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt),
 };
 exports.default = def;
-//# sourceMappingURL=dependentRequired.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js.bak b/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js.bak
new file mode 100644
index 0000000..09e5963
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/dependentRequired.js.bak
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dependencies_1 = require("../applicator/dependencies");
+const def = {
+    keyword: "dependentRequired",
+    type: "object",
+    schemaType: "object",
+    error: dependencies_1.error,
+    code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt),
+};
+exports.default = def;
+//# sourceMappingURL=dependentRequired.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/enum.js b/node_modules/ajv/dist/vocabularies/validation/enum.js
index eab6487..c79ee3c 100644
--- a/node_modules/ajv/dist/vocabularies/validation/enum.js
+++ b/node_modules/ajv/dist/vocabularies/validation/enum.js
@@ -45,4 +45,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=enum.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/enum.js.bak b/node_modules/ajv/dist/vocabularies/validation/enum.js.bak
new file mode 100644
index 0000000..eab6487
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/enum.js.bak
@@ -0,0 +1,48 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const equal_1 = require("../../runtime/equal");
+const error = {
+    message: "must be equal to one of the allowed values",
+    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
+};
+const def = {
+    keyword: "enum",
+    schemaType: "array",
+    $data: true,
+    error,
+    code(cxt) {
+        const { gen, data, $data, schema, schemaCode, it } = cxt;
+        if (!$data && schema.length === 0)
+            throw new Error("enum must have non-empty array");
+        const useLoop = schema.length >= it.opts.loopEnum;
+        let eql;
+        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
+        let valid;
+        if (useLoop || $data) {
+            valid = gen.let("valid");
+            cxt.block$data(valid, loopEnum);
+        }
+        else {
+            /* istanbul ignore if */
+            if (!Array.isArray(schema))
+                throw new Error("ajv implementation error");
+            const vSchema = gen.const("vSchema", schemaCode);
+            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
+        }
+        cxt.pass(valid);
+        function loopEnum() {
+            gen.assign(valid, false);
+            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
+        }
+        function equalCode(vSchema, i) {
+            const sch = schema[i];
+            return typeof sch === "object" && sch !== null
+                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
+                : (0, codegen_1._) `${data} === ${sch}`;
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=enum.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/index.js b/node_modules/ajv/dist/vocabularies/validation/index.js
index 7b56b4e..b3e3ed0 100644
--- a/node_modules/ajv/dist/vocabularies/validation/index.js
+++ b/node_modules/ajv/dist/vocabularies/validation/index.js
@@ -30,4 +30,3 @@ const validation = [
     enum_1.default,
 ];
 exports.default = validation;
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/index.js.bak b/node_modules/ajv/dist/vocabularies/validation/index.js.bak
new file mode 100644
index 0000000..7b56b4e
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/index.js.bak
@@ -0,0 +1,33 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const limitNumber_1 = require("./limitNumber");
+const multipleOf_1 = require("./multipleOf");
+const limitLength_1 = require("./limitLength");
+const pattern_1 = require("./pattern");
+const limitProperties_1 = require("./limitProperties");
+const required_1 = require("./required");
+const limitItems_1 = require("./limitItems");
+const uniqueItems_1 = require("./uniqueItems");
+const const_1 = require("./const");
+const enum_1 = require("./enum");
+const validation = [
+    // number
+    limitNumber_1.default,
+    multipleOf_1.default,
+    // string
+    limitLength_1.default,
+    pattern_1.default,
+    // object
+    limitProperties_1.default,
+    required_1.default,
+    // array
+    limitItems_1.default,
+    uniqueItems_1.default,
+    // any
+    { keyword: "type", schemaType: ["string", "array"] },
+    { keyword: "nullable", schemaType: "boolean" },
+    const_1.default,
+    enum_1.default,
+];
+exports.default = validation;
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitContains.js b/node_modules/ajv/dist/vocabularies/validation/limitContains.js
index c884dae..27f7793 100644
--- a/node_modules/ajv/dist/vocabularies/validation/limitContains.js
+++ b/node_modules/ajv/dist/vocabularies/validation/limitContains.js
@@ -12,4 +12,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=limitContains.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitContains.js.bak b/node_modules/ajv/dist/vocabularies/validation/limitContains.js.bak
new file mode 100644
index 0000000..c884dae
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/limitContains.js.bak
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const util_1 = require("../../compile/util");
+const def = {
+    keyword: ["maxContains", "minContains"],
+    type: "array",
+    schemaType: "number",
+    code({ keyword, parentSchema, it }) {
+        if (parentSchema.contains === undefined) {
+            (0, util_1.checkStrictMode)(it, `"${keyword}" without "contains" is ignored`);
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=limitContains.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitItems.js b/node_modules/ajv/dist/vocabularies/validation/limitItems.js
index e1386f8..08ca795 100644
--- a/node_modules/ajv/dist/vocabularies/validation/limitItems.js
+++ b/node_modules/ajv/dist/vocabularies/validation/limitItems.js
@@ -21,4 +21,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=limitItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitItems.js.bak b/node_modules/ajv/dist/vocabularies/validation/limitItems.js.bak
new file mode 100644
index 0000000..e1386f8
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/limitItems.js.bak
@@ -0,0 +1,24 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const error = {
+    message({ keyword, schemaCode }) {
+        const comp = keyword === "maxItems" ? "more" : "fewer";
+        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
+    },
+    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
+};
+const def = {
+    keyword: ["maxItems", "minItems"],
+    type: "array",
+    schemaType: "number",
+    $data: true,
+    error,
+    code(cxt) {
+        const { keyword, data, schemaCode } = cxt;
+        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
+        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=limitItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitLength.js b/node_modules/ajv/dist/vocabularies/validation/limitLength.js
index 6ae5f92..6a5b8e4 100644
--- a/node_modules/ajv/dist/vocabularies/validation/limitLength.js
+++ b/node_modules/ajv/dist/vocabularies/validation/limitLength.js
@@ -24,4 +24,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=limitLength.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitLength.js.bak b/node_modules/ajv/dist/vocabularies/validation/limitLength.js.bak
new file mode 100644
index 0000000..6ae5f92
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/limitLength.js.bak
@@ -0,0 +1,27 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const ucs2length_1 = require("../../runtime/ucs2length");
+const error = {
+    message({ keyword, schemaCode }) {
+        const comp = keyword === "maxLength" ? "more" : "fewer";
+        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
+    },
+    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
+};
+const def = {
+    keyword: ["maxLength", "minLength"],
+    type: "string",
+    schemaType: "number",
+    $data: true,
+    error,
+    code(cxt) {
+        const { keyword, data, schemaCode, it } = cxt;
+        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
+        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
+        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=limitLength.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitNumber.js b/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
index a97c0eb..a0eb351 100644
--- a/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
+++ b/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
@@ -24,4 +24,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=limitNumber.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitNumber.js.bak b/node_modules/ajv/dist/vocabularies/validation/limitNumber.js.bak
new file mode 100644
index 0000000..a97c0eb
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/limitNumber.js.bak
@@ -0,0 +1,27 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const ops = codegen_1.operators;
+const KWDs = {
+    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
+    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
+    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
+    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
+};
+const error = {
+    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
+    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
+};
+const def = {
+    keyword: Object.keys(KWDs),
+    type: "number",
+    schemaType: "number",
+    $data: true,
+    error,
+    code(cxt) {
+        const { keyword, data, schemaCode } = cxt;
+        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=limitNumber.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitProperties.js b/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
index e6fc40c..a8664e5 100644
--- a/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
+++ b/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
@@ -21,4 +21,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=limitProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/limitProperties.js.bak b/node_modules/ajv/dist/vocabularies/validation/limitProperties.js.bak
new file mode 100644
index 0000000..e6fc40c
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/limitProperties.js.bak
@@ -0,0 +1,24 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const error = {
+    message({ keyword, schemaCode }) {
+        const comp = keyword === "maxProperties" ? "more" : "fewer";
+        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
+    },
+    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
+};
+const def = {
+    keyword: ["maxProperties", "minProperties"],
+    type: "object",
+    schemaType: "number",
+    $data: true,
+    error,
+    code(cxt) {
+        const { keyword, data, schemaCode } = cxt;
+        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
+        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=limitProperties.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/multipleOf.js b/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
index 43cf67b..e324e76 100644
--- a/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
+++ b/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
@@ -23,4 +23,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=multipleOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/multipleOf.js.bak b/node_modules/ajv/dist/vocabularies/validation/multipleOf.js.bak
new file mode 100644
index 0000000..43cf67b
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/multipleOf.js.bak
@@ -0,0 +1,26 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const codegen_1 = require("../../compile/codegen");
+const error = {
+    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
+    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
+};
+const def = {
+    keyword: "multipleOf",
+    type: "number",
+    schemaType: "number",
+    $data: true,
+    error,
+    code(cxt) {
+        const { gen, data, schemaCode, it } = cxt;
+        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
+        const prec = it.opts.multipleOfPrecision;
+        const res = gen.let("res");
+        const invalid = prec
+            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
+            : (0, codegen_1._) `${res} !== parseInt(${res})`;
+        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=multipleOf.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/pattern.js b/node_modules/ajv/dist/vocabularies/validation/pattern.js
index f8ccdf2..a3039f1 100644
--- a/node_modules/ajv/dist/vocabularies/validation/pattern.js
+++ b/node_modules/ajv/dist/vocabularies/validation/pattern.js
@@ -21,4 +21,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=pattern.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/pattern.js.bak b/node_modules/ajv/dist/vocabularies/validation/pattern.js.bak
new file mode 100644
index 0000000..f8ccdf2
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/pattern.js.bak
@@ -0,0 +1,24 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const code_1 = require("../code");
+const codegen_1 = require("../../compile/codegen");
+const error = {
+    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
+    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
+};
+const def = {
+    keyword: "pattern",
+    type: "string",
+    schemaType: "string",
+    $data: true,
+    error,
+    code(cxt) {
+        const { data, $data, schema, schemaCode, it } = cxt;
+        // TODO regexp should be wrapped in try/catchs
+        const u = it.opts.unicodeRegExp ? "u" : "";
+        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
+        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
+    },
+};
+exports.default = def;
+//# sourceMappingURL=pattern.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/required.js b/node_modules/ajv/dist/vocabularies/validation/required.js
index 1d8e292..9acfeb9 100644
--- a/node_modules/ajv/dist/vocabularies/validation/required.js
+++ b/node_modules/ajv/dist/vocabularies/validation/required.js
@@ -76,4 +76,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=required.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/required.js.bak b/node_modules/ajv/dist/vocabularies/validation/required.js.bak
new file mode 100644
index 0000000..1d8e292
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/required.js.bak
@@ -0,0 +1,79 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const code_1 = require("../code");
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const error = {
+    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
+    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
+};
+const def = {
+    keyword: "required",
+    type: "object",
+    schemaType: "array",
+    $data: true,
+    error,
+    code(cxt) {
+        const { gen, schema, schemaCode, data, $data, it } = cxt;
+        const { opts } = it;
+        if (!$data && schema.length === 0)
+            return;
+        const useLoop = schema.length >= opts.loopRequired;
+        if (it.allErrors)
+            allErrorsMode();
+        else
+            exitOnErrorMode();
+        if (opts.strictRequired) {
+            const props = cxt.parentSchema.properties;
+            const { definedProperties } = cxt.it;
+            for (const requiredKey of schema) {
+                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
+                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
+                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
+                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
+                }
+            }
+        }
+        function allErrorsMode() {
+            if (useLoop || $data) {
+                cxt.block$data(codegen_1.nil, loopAllRequired);
+            }
+            else {
+                for (const prop of schema) {
+                    (0, code_1.checkReportMissingProp)(cxt, prop);
+                }
+            }
+        }
+        function exitOnErrorMode() {
+            const missing = gen.let("missing");
+            if (useLoop || $data) {
+                const valid = gen.let("valid", true);
+                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
+                cxt.ok(valid);
+            }
+            else {
+                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
+                (0, code_1.reportMissingProp)(cxt, missing);
+                gen.else();
+            }
+        }
+        function loopAllRequired() {
+            gen.forOf("prop", schemaCode, (prop) => {
+                cxt.setParams({ missingProperty: prop });
+                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
+            });
+        }
+        function loopUntilMissing(missing, valid) {
+            cxt.setParams({ missingProperty: missing });
+            gen.forOf(missing, schemaCode, () => {
+                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
+                gen.if((0, codegen_1.not)(valid), () => {
+                    cxt.error();
+                    gen.break();
+                });
+            }, codegen_1.nil);
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=required.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js b/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
index cdbecea..51a7104 100644
--- a/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
+++ b/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
@@ -61,4 +61,3 @@ const def = {
     },
 };
 exports.default = def;
-//# sourceMappingURL=uniqueItems.js.map
\ No newline at end of file
diff --git a/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js.bak b/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js.bak
new file mode 100644
index 0000000..cdbecea
--- /dev/null
+++ b/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js.bak
@@ -0,0 +1,64 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const dataType_1 = require("../../compile/validate/dataType");
+const codegen_1 = require("../../compile/codegen");
+const util_1 = require("../../compile/util");
+const equal_1 = require("../../runtime/equal");
+const error = {
+    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
+    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
+};
+const def = {
+    keyword: "uniqueItems",
+    type: "array",
+    schemaType: "boolean",
+    $data: true,
+    error,
+    code(cxt) {
+        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
+        if (!$data && !schema)
+            return;
+        const valid = gen.let("valid");
+        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
+        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
+        cxt.ok(valid);
+        function validateUniqueItems() {
+            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
+            const j = gen.let("j");
+            cxt.setParams({ i, j });
+            gen.assign(valid, true);
+            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
+        }
+        function canOptimize() {
+            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
+        }
+        function loopN(i, j) {
+            const item = gen.name("item");
+            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
+            const indices = gen.const("indices", (0, codegen_1._) `{}`);
+            gen.for((0, codegen_1._) `;${i}--;`, () => {
+                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
+                gen.if(wrongType, (0, codegen_1._) `continue`);
+                if (itemTypes.length > 1)
+                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
+                gen
+                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
+                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
+                    cxt.error();
+                    gen.assign(valid, false).break();
+                })
+                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
+            });
+        }
+        function loopN2(i, j) {
+            const eql = (0, util_1.useFunc)(gen, equal_1.default);
+            const outer = gen.name("outer");
+            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
+                cxt.error();
+                gen.assign(valid, false).break(outer);
+            })));
+        }
+    },
+};
+exports.default = def;
+//# sourceMappingURL=uniqueItems.js.map
\ No newline at end of file
