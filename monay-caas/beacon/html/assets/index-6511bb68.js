function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
document.documentElement.dataset.mode = (() => {
  const persistentTheme = window.localStorage.getItem("theme");
  if (persistentTheme === "dark" || persistentTheme === "light") {
    return persistentTheme;
  }
  const mqTheme = window.matchMedia("(prefers-color-scheme: dark)");
  return mqTheme.matches ? "dark" : "light";
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$6 = Symbol.for("react.element"), n$7 = Symbol.for("react.portal"), p$7 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$a = Symbol.for("react.provider"), u$6 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$5 = Symbol.for("react.lazy"), z$4 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$4 && a2[z$4] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$4 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e2 || B$2;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$3() {
}
F$3.prototype = E$3.prototype;
function G$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e2 || B$2;
}
var H$4 = G$2.prototype = new F$3();
H$4.constructor = G$2;
C$2(H$4, E$3.prototype);
H$4.isPureReactComponent = true;
var I$5 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$9(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$2.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$6, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$4(a2, b2) {
  return { $$typeof: l$6, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$6;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$3 = /\/+/g;
function Q$3(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$2(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$6:
          case n$7:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$3(h2, 0) : d2, I$5(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$3, "$&/") + "/"), R$2(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$4(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$3, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$5(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$2(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$2(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$8(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$2(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$5(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$3 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$8, forEach: function(a2, b2, e2) {
  S$8(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$8(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$8(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$7;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$2.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$6, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$6, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$a, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$9;
react_production_min.createFactory = function(a2) {
  var b2 = M$9.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$5, _payload: { _status: -1, _result: a2 }, _init: T$5 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$3.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$3.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$3.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$3.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$3.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$3.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$3.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$3.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$3.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$3.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$3.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$3.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs$1(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$7 = reactExports, k$1 = Symbol.for("react.element"), l$5 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$6 = f$7.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$3.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$6.current };
}
reactJsxRuntime_production_min.Fragment = l$5;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C3 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C3, c2))
            n2 < e2 && 0 > g2(x2, C3) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C3, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F3 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N3 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N3 = false, O2 = null);
      }
    } else
      N3 = false;
  }
  var S2;
  if ("function" === typeof F3)
    S2 = function() {
      F3(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N3 || (N3 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$5(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$4(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$3[a2] = new v$4(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$3[b2] = new v$4(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$3[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$3[b2] = new v$4(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$3.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$3.hasOwnProperty(b2) ? z$3[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua$1 = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$5(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$5(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$5(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$5(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$5(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$5(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$5(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$5(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$5(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$5(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$5(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$5(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$5(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$5(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$5(190));
  }
  if (3 !== c2.tag)
    throw Error(p$5(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$1 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua$1.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$3 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce = ia && "TextEvent" in window && !be$1, de = ia && (!ae$3 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$2(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$4 = false;
function je$4(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$2(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$2(a2, b2) {
  if (ie$4)
    return "compositionend" === a2 || !ae$3 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$4 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$3 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$3[a2.type] : "textarea" === b2 ? true : false;
}
function ne$2(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$4(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$3 = null;
function re$2(a2) {
  se$2(a2, 0);
}
function te$1(a2) {
  var b2 = ue$2(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$4 = false;
if (ia) {
  var xe$2;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$3 = document.createElement("div");
      ze$3.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$3.oninput;
    }
    xe$2 = ye$1;
  } else
    xe$2 = false;
  we$4 = xe$2 && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$3 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$3)) {
    var b2 = [];
    ne$2(b2, qe$3, a2, xb(a2));
    Jb(re$2, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe$1 = b2, qe$3 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe$3);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe$2(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge$4(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$4 = "function" === typeof Object.is ? Object.is : Ge$4;
function Ie$2(a2, b2) {
  if (He$4(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$4(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$3(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$4(a2, b2) {
  var c2 = Je$3(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$3(c2);
  }
}
function Le$2(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$4(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$1(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$2(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$4(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke$4(c2, f2);
        var g2 = Ke$4(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$3 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$3 = null, Re$1 = null, Se$3 = null, Te = false;
function Ue$3(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe$3 || Qe$3 !== Xa(d2) || (d2 = Qe$3, "selectionStart" in d2 && Ne$4(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$3 && Ie$2(Se$3, d2) || (Se$3 = d2, d2 = oe$4(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$3)));
}
function Ve$2(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$3 = { animationend: Ve$2("Animation", "AnimationEnd"), animationiteration: Ve$2("Animation", "AnimationIteration"), animationstart: Ve$2("Animation", "AnimationStart"), transitionend: Ve$2("Transition", "TransitionEnd") }, Xe$4 = {}, Ye$3 = {};
ia && (Ye$3 = document.createElement("div").style, "AnimationEvent" in window || (delete We$3.animationend.animation, delete We$3.animationiteration.animation, delete We$3.animationstart.animation), "TransitionEvent" in window || delete We$3.transitionend.transition);
function Ze$3(a2) {
  if (Xe$4[a2])
    return Xe$4[a2];
  if (!We$3[a2])
    return a2;
  var b2 = We$3[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$3)
      return Xe$4[a2] = b2[c2];
  return a2;
}
var $e$3 = Ze$3("animationend"), af = Ze$3("animationiteration"), bf = Ze$3("animationstart"), cf = Ze$3("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$3, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$2(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$3(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$3:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F3 = u2.stateNode;
          5 === u2.tag && null !== F3 && (u2 = F3, null !== x2 && (F3 = Kb(w2, x2), null != F3 && t2.push(tf(w2, F3, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F3 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F3 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$2(k3);
            u2 = null == n2 ? h3 : ue$2(n2);
            h3 = new t2(F3, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F3 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F3 = t2);
            J2 = F3;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F3 = x2; F3; F3 = vf(F3))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$2(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me(h3))
          if (we$4)
            na = Fe$2;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a2, d3))) {
          ne$2(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$2(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe$3 = xa, Re$1 = d3, Se$3 = null;
          break;
        case "focusout":
          Se$3 = Re$1 = Qe$3 = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue$3(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$3)
            break;
        case "keydown":
        case "keyup":
          Ue$3(g3, c2, e3);
      }
      var $a;
      if (ae$3)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$4 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie$4 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$4 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$4 = true)), xa = oe$4(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je$4(a2, c2) : ke$2(a2, c2))
        d3 = oe$4(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$2(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$4(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$5(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$2(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$5(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$3 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$3);
}
function ag(a2, b2, c2) {
  if (H$3.current !== Vf)
    throw Error(p$5(168));
  G$1(H$3, b2);
  G$1(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$5(108, Ra(a2) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$3.current;
  G$1(H$3, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$5(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$3), G$1(H$3, a2)) : E$2(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$4 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$4) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$5(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$4 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$5(418));
      a2.flags = a2.flags & -4097 | 2;
      I$4 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$4)
    return Fg(a2), I$4 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$5(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$5(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$4 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua$1.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$5(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$5(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$2(c2, d2) || !Ie$2(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$3.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$3.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$5(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$5(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$5(284));
    if (!c2._owner)
      throw Error(p$5(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$5(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$4 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$4 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$4 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$5(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$5(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$4 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$4 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$4 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$5(174));
  return a2;
}
function Ih(a2, b2) {
  G$1(Gh, b2);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$8 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua$1.ReactCurrentDispatcher, Qh = ua$1.ReactCurrentBatchConfig, Rh = 0, N$3 = null, O$1 = null, P$2 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$5(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$4(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$3 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$5(301));
      f2 += 1;
      P$2 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$2 = O$1 = N$3 = null;
  Sh = false;
  if (b2)
    throw Error(p$5(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$2 ? N$3.memoizedState = P$2 = a2 : P$2 = P$2.next = a2;
  return P$2;
}
function di() {
  if (null === O$1) {
    var a2 = N$3.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b2 = null === P$2 ? N$3.memoizedState : P$2.next;
  if (null !== b2)
    P$2 = b2, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$5(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$2 ? N$3.memoizedState = P$2 = a2 : P$2 = P$2.next = a2;
  }
  return P$2;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$3.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$4(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$3.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$4(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$3, d2 = di(), e2 = b2(), f2 = !He$4(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$2 && P$2.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$1)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$3.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$4(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$3, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$3.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$3.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N$3.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$3.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$4(c2, b2) || (c2 = yc(), N$3.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$1 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$4(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$3 || null !== b2 && b2 === N$3;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$3, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$3, e2 = ci();
  if (I$4) {
    if (void 0 === c2)
      throw Error(p$5(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$1)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R$1.identifierPrefix;
  if (I$4) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$1 ? b2.memoizedState = a2 : Di(b2, O$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua$1.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$4 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$2;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$2(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$3.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$4 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$3.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$3.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$8.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$1(M$8, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$5(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$1;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$5(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$4 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$8.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$8, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$5(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$8, M$8.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$1(M$8, M$8.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$8, M$8.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$8, M$8.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$3("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$4)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$7(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$7(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$7(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$3);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$7(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$5(166));
          S$7(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$3("cancel", d2);
              D$3("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$3("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$3(lf[e2], d2);
              break;
            case "source":
              D$3("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$3(
                "error",
                d2
              );
              D$3("load", d2);
              break;
            case "details":
              D$3("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$3("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$3("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$3("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$3("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$3("cancel", a2);
                D$3("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$3("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$3(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$3("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$3(
                  "error",
                  a2
                );
                D$3("load", a2);
                e2 = d2;
                break;
              case "details":
                D$3("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$3("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D$3("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$3("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$3("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$7(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$5(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$7(b2);
      return null;
    case 13:
      E$2(M$8);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$4 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$5(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$5(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$7(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$8.current & 1) ? 0 === T$4 && (T$4 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$7(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$7(b2), null;
    case 10:
      return Rg(b2.type._context), S$7(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$7(b2), null;
    case 19:
      E$2(M$8);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$7(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$4 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$8, M$8.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$1() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$4)
              return S$7(b2), null;
          } else
            2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c2 = M$8.current, G$1(M$8, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$7(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$7(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$7(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$5(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$3), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$8);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$5(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$8), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$2 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$4(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F3) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$5(163));
            }
        } catch (F3) {
          W$1(b2, b2.return, F3);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$2 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$2 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e2 = Yj;
      X$2 = null;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e2;
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2;
      e2 = Yj;
      X$2 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$2 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$2 = (d2 = U$2) || null !== c2.memoizedState, Zj(a2, b2, c2), U$2 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$2)
          throw Error(p$5(160));
        ak(f2, g2, e2);
        X$2 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$5(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$1()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$2 = (l2 = U$2) || m2, dk(b2, a2), U$2 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$5(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$5(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$2;
        h2 = Kj;
        var l2 = U$2;
        Kj = g2;
        if ((U$2 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$2 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$2)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$5(163));
          }
        U$2 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua$1.ReactCurrentDispatcher, ok = ua$1.ReactCurrentOwner, pk = ua$1.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$2 = null, Z$3 = 0, gj = 0, fj = Uf(0), T$4 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K$1 & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$3)
    return Z$3 & -Z$3;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$1;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$5(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R$1)
    a2 === R$1 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$4 && Dk(a2, Z$3)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$3 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$3 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$1 !== a2 || Z$3 !== b2)
      vk = null, Hj = B$1() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e2;
    null !== Y$2 ? b2 = 0 : (R$1 = null, Z$3 = 0, b2 = T$4);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$1()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$5(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$1(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$1() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$5(329));
      }
    }
  }
  Ek(a2, B$1());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$4(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$1()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$1()), c2;
  if (6 === c2)
    throw Error(p$5(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$1());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a2)
      return a2();
  } finally {
    C$1 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$2)
    for (c2 = Y$2.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$3);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$8);
          break;
        case 19:
          E$2(M$8);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$1 = a2;
  Y$2 = a2 = wh(a2.current, null);
  Z$3 = gj = b2;
  T$4 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$2;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$3.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$2 = O$1 = N$3 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$4 = 1;
        qk = b2;
        Y$2 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$3;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$5(426));
          }
        } else if (I$4 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$4 && (T$4 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F3 = Ri(f2, h2, b2);
                fh(f2, F3);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$2 === c2 && null !== c2 && (Y$2 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$4 || 3 === T$4 || 2 === T$4)
    T$4 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$3);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$1 !== a2 || Z$3 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$2)
    throw Error(p$5(261));
  R$1 = null;
  Z$3 = 0;
  return T$4;
}
function Uk() {
  for (; null !== Y$2; )
    Vk(Y$2);
}
function Mk() {
  for (; null !== Y$2 && !cc(); )
    Vk(Y$2);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$2 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$2 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$2 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$4 = 6;
        Y$2 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$2 = b2;
      return;
    }
    Y$2 = b2 = a2;
  } while (null !== b2);
  0 === T$4 && (T$4 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$1, e2 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$1 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$5(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$5(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$1 && (Y$2 = R$1 = null, Z$3 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$1());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$5(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F3 = h2.sibling;
                if (null !== F3) {
                  F3.return = h2.return;
                  V$1 = F3;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$1 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$1 === a2 && (Z$3 & c2) === c2 && (4 === T$4 || 3 === T$4 && (Z$3 & 130023424) === Z$3 && 500 > B$1() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$5(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$4 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$3.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$4 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$5(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$5(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$5(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$5(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$4 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$4(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$5(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$5(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$5(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$5(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$5(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$5(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$1()), 0 === (K$1 & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a2, b2) {
  var c2 = C$1;
  try {
    return C$1 = a2, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$5(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$2, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$5(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$5(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$5(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$5(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$5(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$5(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$5(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$5(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m$2 = reactDomExports;
{
  client.createRoot = m$2.createRoot;
  client.hydrateRoot = m$2.hydrateRoot;
}
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /* @__PURE__ */ Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die("Proxy not available");
  }
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop$4 = function noop() {
};
function isFunction$2(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t2 = typeof value;
  switch (t2) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject$3(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject$4(value) {
  if (!isObject$3(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp$1(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name2, theClass) {
  var propName = "isMobX" + name2;
  theClass.prototype[propName] = true;
  return function(x2) {
    return isObject$3(x2) && x2[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys2 = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys2;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys2;
  }
  return [].concat(keys2, symbols.filter(function(s2) {
    return objectPrototype.propertyIsEnumerable.call(object2, s2);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop2) {
  return objectPrototype.hasOwnProperty.call(target, prop2);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3)
    return;
  if (typeof o3 === "string")
    return _arrayLikeToArray(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor)
    n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o3, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2)
    return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
    if (it2)
      o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o3[i2++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp$1(prototype, storedAnnotationsSymbol, _extends$3({}, prototype[storedAnnotationsSymbol]));
  }
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    addHiddenProp$1(target, storedAnnotationsSymbol, _extends$3({}, target[storedAnnotationsSymbol]));
  }
  return target[storedAnnotationsSymbol];
}
var $mobx = /* @__PURE__ */ Symbol("mobx administration");
var Atom = /* @__PURE__ */ function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = "Atom";
    }
    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    globalState.stateVersion = globalState.stateVersion < Number.MAX_SAFE_INTEGER ? globalState.stateVersion + 1 : Number.MIN_SAFE_INTEGER;
    endBatch();
  };
  _proto.toString = function toString2() {
    return this.name_;
  };
  return Atom2;
}();
var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
function createAtom(name2, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop$4;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop$4;
  }
  var atom = new Atom(name2);
  if (onBecomeObservedHandler !== noop$4) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop$4) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a2, b2) {
  return a2 === b2;
}
function structuralComparer(a2, b2) {
  return deepEqual$2(a2, b2);
}
function shallowComparer(a2, b2) {
  return deepEqual$2(a2, b2, 1);
}
function defaultComparer(a2, b2) {
  if (Object.is) {
    return Object.is(a2, b2);
  }
  return a2 === b2 ? a2 !== 0 || 1 / a2 === 1 / b2 : a2 !== a2 && b2 !== b2;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v2, _2, name2) {
  if (isObservable(v2)) {
    return v2;
  }
  if (Array.isArray(v2)) {
    return observable$1.array(v2, {
      name: name2
    });
  }
  if (isPlainObject$4(v2)) {
    return observable$1.object(v2, void 0, {
      name: name2
    });
  }
  if (isES6Map(v2)) {
    return observable$1.map(v2, {
      name: name2
    });
  }
  if (isES6Set(v2)) {
    return observable$1.set(v2, {
      name: name2
    });
  }
  if (typeof v2 === "function" && !isAction(v2) && !isFlow(v2)) {
    if (isGenerator(v2)) {
      return flow$1(v2);
    } else {
      return autoAction(name2, v2);
    }
  }
  return v2;
}
function shallowEnhancer(v2, _2, name2) {
  if (v2 === void 0 || v2 === null) {
    return v2;
  }
  if (isObservableObject(v2) || isObservableArray(v2) || isObservableMap(v2) || isObservableSet(v2)) {
    return v2;
  }
  if (Array.isArray(v2)) {
    return observable$1.array(v2, {
      name: name2,
      deep: false
    });
  }
  if (isPlainObject$4(v2)) {
    return observable$1.object(v2, void 0, {
      name: name2,
      deep: false
    });
  }
  if (isES6Map(v2)) {
    return observable$1.map(v2, {
      name: name2,
      deep: false
    });
  }
  if (isES6Set(v2)) {
    return observable$1.set(v2, {
      name: name2,
      deep: false
    });
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v2, oldValue) {
  if (deepEqual$2(v2, oldValue)) {
    return oldValue;
  }
  return v2;
}
var OVERRIDE = "override";
var override = /* @__PURE__ */ createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_,
  extend_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function make_(adm, key) {
  return 0;
}
function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function createActionAnnotation(name2, options) {
  return {
    annotationType_: name2,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.value;
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name2, options) {
  return {
    annotationType_: name2,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.value;
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow$1(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name2, options) {
  return {
    annotationType_: name2,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends$3({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  _ref.annotationType_;
  _ref2.get;
}
function createObservableAnnotation(name2, options) {
  return {
    annotationType_: name2,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  _ref.annotationType_;
}
var AUTO = "true";
var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set5 = createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set5
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set5
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow$1.bound : flow$1;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable$1.ref : observable$1;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable$1.ref : observable$1;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v2, arg2, arg3) {
  if (isStringish(arg2)) {
    storeAnnotation(v2, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v2)) {
    return v2;
  }
  if (isPlainObject$4(v2)) {
    return observable$1.object(v2, arg2, arg3);
  }
  if (Array.isArray(v2)) {
    return observable$1.array(v2, arg2);
  }
  if (isES6Map(v2)) {
    return observable$1.map(v2, arg2);
  }
  if (isES6Set(v2)) {
    return observable$1.set(v2, arg2);
  }
  if (typeof v2 === "object" && v2 !== null) {
    return v2;
  }
  return observable$1.box(v2, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o3 = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o3), o3.name, true, o3.equals);
  },
  array: function array(initialValues, options) {
    var o3 = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o3.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o3), o3.name);
  },
  map: function map(initialValues, options) {
    var o3 = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o3), o3.name);
  },
  set: function set(initialValues, options) {
    var o3 = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o3), o3.name);
  },
  object: function object(props, decorators, options) {
    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
  },
  ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
  shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
};
var observable$1 = /* @__PURE__ */ assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject$4(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  var opts = isPlainObject$4(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config, _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  function res() {
    return executeAction(actionName, autoAction2, fn, ref || this, arguments);
  }
  res.isMobxAction = true;
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation);
  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = false;
  var startTime_ = 0;
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges2) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var _Symbol$toPrimitive;
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /* @__PURE__ */ function(_Atom) {
  _inheritsLoose(ObservableValue2, _Atom);
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = "ObservableValue";
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    return _this;
  }
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set5(newValue) {
    this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      this.setNewValue_(newValue);
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get4() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON2() {
    return this.get();
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var isObservableValue = /* @__PURE__ */ createInstanceofPredicate("ObservableValue", ObservableValue);
var _Symbol$toPrimitive$1;
_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /* @__PURE__ */ function() {
  function ComputedValue2(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = /* @__PURE__ */ new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || "ComputedValue";
    if (options.set) {
      this.setter_ = createAction("ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get4() {
    if (this.isComputing_) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set5(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) {
        die(33, this.name_);
      }
      this.isRunningSetter_ = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    );
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e2) {
          res = new CaughtException(e2);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    {
      return;
    }
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[_Symbol$toPrimitive$1] = function() {
    return this.valueOf();
  };
  return ComputedValue2;
}();
var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e2) {
  return e2 instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l2 = obs.length;
      for (var i2 = 0; i2 < l2; i2++) {
        var obj = obs[i2];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e2) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null;
}
function checkIfStateModificationsAreAllowed(atom) {
  {
    return;
  }
}
function trackDerivedFunction(derivation, f2, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f2.call(context);
  } else {
    try {
      result = f2.call(context);
    } catch (e2) {
      result = new CaughtException(e2);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l2 = derivation.unboundDepsCount_;
  for (var i2 = 0; i2 < l2; i2++) {
    var dep = observing[i2];
    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i2) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l2 = prevObserving.length;
  while (l2--) {
    var _dep = prevObserving[l2];
    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue_ = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i2 = obs.length;
  while (i2--) {
    removeObserver(obs[i2], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i2 = obs.length;
  while (i2--) {
    obs[i2].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
  this.stateVersion = Number.MIN_SAFE_INTEGER;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /* @__PURE__ */ function() {
  var global2 = /* @__PURE__ */ getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
    die(36);
  }
  isolateCalled = true;
  if (canMergeGlobalState) {
    var global2 = getGlobal();
    if (--global2.__mobxInstanceCount === 0) {
      global2.__mobxGlobals = void 0;
    }
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();
  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) {
      globalState[key] = defaultGlobals[key];
    }
  }
  globalState.allowStateChanges = !globalState.enforceActions;
}
function hasObservers(observable2) {
  return observable2.observers_ && observable2.observers_.size > 0;
}
function getObservers(observable2) {
  return observable2.observers_;
}
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation_ === false) {
    observable2.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i2 = 0; i2 < list.length; i2++) {
      var observable2 = list[i2];
      observable2.isPendingUnobservation_ = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved_) {
          observable2.isBeingObserved_ = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved_ && globalState.trackingContext) {
        observable2.isBeingObserved_ = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved_;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.onBecomeStale_();
    }
    d2.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d2.dependenciesState_ = IDerivationState_.STALE_;
    } else if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d2.onBecomeStale_();
    }
  });
}
var Reaction = /* @__PURE__ */ function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending_ = true;
        try {
          this.onInvalidate_();
          if (false)
            ;
        } catch (e2) {
          this.reportExceptionInDerivation_(e2);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return;
    }
    startBatch();
    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;
    if (this.isDisposed_) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message = "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    }
    globalState.globalReactionErrorHandlers.forEach(function(f2) {
      return f2(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;
      if (!this.isRunning_) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null ? void 0 : abortSignal.removeEventListener == null ? void 0 : abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null ? void 0 : abortSignal.addEventListener == null ? void 0 : abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    return dispose;
  };
  _proto.toString = function toString2() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
  };
  return Reaction2;
}();
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function() {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) {
      globalState.globalReactionErrorHandlers.splice(idx, 1);
    }
  };
}
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f2) {
  return f2();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i2 = 0, l2 = remainingReactions.length; i2 < l2; i2++) {
      remainingReactions[i2].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;
  reactionScheduler = function reactionScheduler3(f2) {
    return fn(function() {
      return baseScheduler(f2);
    });
  };
}
function isSpyEnabled() {
  return false;
}
function spyReport(event) {
  {
    return;
  }
}
function spyReportStart(event) {
  {
    return;
  }
}
function spyReportEnd(change) {
  {
    return;
  }
}
function spy(listener) {
  {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction$2(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction$2(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
  };
  return res;
}
var action = /* @__PURE__ */ createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /* @__PURE__ */ createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
}
function isAction(thing) {
  return isFunction$2(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts2$signal, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name2 = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name2, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler2 = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction2 = new Reaction(name2, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler2(function() {
          isScheduled = false;
          if (!reaction2.isDisposed_) {
            reaction2.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  if (!((_opts2 = opts) != null && (_opts2$signal = _opts2.signal) != null && _opts2$signal.aborted)) {
    reaction2.schedule_();
  }
  return reaction2.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f2) {
  return f2();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f2) {
    return setTimeout(f2, opts.delay);
  } : run;
}
function reaction(expression, effect, opts) {
  var _opts$name2, _opts4, _opts4$signal, _opts5;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name2 = (_opts$name2 = opts.name) != null ? _opts$name2 : "Reaction";
  var effectAction = action(name2, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler2 = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r2 = new Reaction(name2, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler2(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r2.isDisposed_) {
      return;
    }
    var changed = false;
    r2.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r2);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) {
      effectAction(value, oldValue, r2);
    } else if (!firstTime && changed) {
      effectAction(value, oldValue, r2);
    }
    firstTime = false;
  }
  if (!((_opts4 = opts) != null && (_opts4$signal = _opts4.signal) != null && _opts4$signal.aborted)) {
    r2.schedule_();
  }
  return r2.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e2) {
      errorHandler.call(this, e2);
    }
  };
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb2 = isFunction$2(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb2);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb2]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb2);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
var NEVER$1 = "never";
var ALWAYS = "always";
var OBSERVED = "observed";
function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }
  var useProxies = options.useProxies, enforceActions = options.enforceActions;
  if (useProxies !== void 0) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER$1 ? false : typeof Proxy !== "undefined";
  }
  if (useProxies === "ifavailable") {
    globalState.verifyProxies = true;
  }
  if (enforceActions !== void 0) {
    var ea2 = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea2;
    globalState.allowStateChanges = ea2 === true || ea2 === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
    if (key in options) {
      globalState[key] = !!options[key];
    }
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;
  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}
function extendObservable(target, properties, annotations, options) {
  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();
  try {
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(
        key,
        descriptors[key],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  } finally {
    endBatch();
  }
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) {
    result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
  bound: true
});
var flow$1 = /* @__PURE__ */ Object.assign(function flow(arg1, arg2) {
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  var generator = arg1;
  var name2 = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name2 + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name2 + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e2) {
          return reject(e2);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name2 + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e2) {
          return reject(e2);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction$2(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name2 + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop$4, noop$4);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e2) {
        rejector(e2);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow$1.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction$2(promise.cancel)) {
    promise.cancel();
  }
}
function flowResult(result) {
  return result;
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}
function interceptReads(thing, propOrHandler, handler) {
  var target;
  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    target = getAdministration(thing, propOrHandler);
  } else
    ;
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function() {
    target.dehancer = void 0;
  };
}
function intercept(thing, propOrHandler, handler) {
  if (isFunction$2(handler)) {
    return interceptProperty(thing, propOrHandler, handler);
  } else {
    return interceptInterceptable(thing, propOrHandler);
  }
}
function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}
function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}
function _isComputed(value, property) {
  if (property === void 0) {
    return isComputedValue(value);
  }
  if (isObservableObject(value) === false) {
    return false;
  }
  if (!value[$mobx].values_.has(property)) {
    return false;
  }
  var atom = getAtom(value, property);
  return isComputedValue(atom);
}
function isComputed(value) {
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  return _isComputed(value, propName);
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  return _isObservable(value, propName);
}
function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }
  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(_2, index2) {
      return index2;
    });
  }
  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return obj[key];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return obj.get(key);
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }
  if (isObservableArray(obj)) {
    return obj.slice();
  }
  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj[key]];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj.get(key)];
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(key, index2) {
      return [index2, key];
    });
  }
  die(7);
}
function set$1(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;
    try {
      for (var _key in _values) {
        set$1(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") {
      key = parseInt(key, 10);
    }
    if (key < 0) {
      die("Invalid index: '" + key + "'");
    }
    startBatch();
    if (key >= obj.length) {
      obj.length = key + 1;
    }
    obj[key] = value;
    endBatch();
  } else {
    die(8);
  }
}
function remove$1(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") {
      key = parseInt(key, 10);
    }
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }
  die(10);
}
function get$2(obj, key) {
  if (!has(obj, key)) {
    return void 0;
  }
  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }
  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }
  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }
  die(38);
}
function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction$2(cbOrFire)) {
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  } else {
    return observeObservable(thing, propOrCb, cbOrFire);
  }
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}
function cache(map2, key, value) {
  map2.set(key, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) {
    return source;
  }
  if (isObservableValue(source) || isComputedValue(source)) {
    return toJSHelper(source.get(), __alreadySeen);
  }
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function(value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, /* @__PURE__ */ new Set());
    source.forEach(function(value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, /* @__PURE__ */ new Map());
    source.forEach(function(value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    var _res3 = cache(__alreadySeen, source, {});
    apiOwnKeys(source).forEach(function(key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
function toJS(source, options) {
  return toJSHelper(source, /* @__PURE__ */ new Map());
}
function trace() {
  {
    return;
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") {
    return whenPromise(predicate, arg1);
  }
  return _when(predicate, arg1, arg2 || {});
}
function _when(predicate, effect, opts) {
  var timeoutHandle;
  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function() {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        if (opts.onError) {
          opts.onError(error);
        } else {
          throw error;
        }
      }
    }, opts.timeout);
  }
  opts.name = "When";
  var effectAction = createAction("When-effect", effect);
  var disposer = autorun(function(r2) {
    var cond = allowStateChanges(false, predicate);
    if (cond) {
      r2.dispose();
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      effectAction();
    }
  }, opts);
  return disposer;
}
function whenPromise(predicate, opts) {
  var _opts$signal;
  if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {
    return Object.assign(Promise.reject(new Error("WHEN_ABORTED")), {
      cancel: function cancel2() {
        return null;
      }
    });
  }
  var cancel;
  var abort;
  var res = new Promise(function(resolve, reject) {
    var _opts$signal2;
    var disposer = _when(predicate, resolve, _extends$3({}, opts, {
      onError: reject
    }));
    cancel = function cancel2() {
      disposer();
      reject(new Error("WHEN_CANCELLED"));
    };
    abort = function abort2() {
      disposer();
      reject(new Error("WHEN_ABORTED"));
    };
    opts == null ? void 0 : (_opts$signal2 = opts.signal) == null ? void 0 : _opts$signal2.addEventListener == null ? void 0 : _opts$signal2.addEventListener("abort", abort);
  })["finally"](function() {
    var _opts$signal3;
    return opts == null ? void 0 : (_opts$signal3 = opts.signal) == null ? void 0 : _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener("abort", abort);
  });
  res.cancel = cancel;
  return res;
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has2(target, name2) {
    return getAdm(target).has_(name2);
  },
  get: function get(target, name2) {
    return getAdm(target).get_(name2);
  },
  set: function set2(target, name2, value) {
    var _getAdm$set_;
    if (!isStringish(name2)) {
      return false;
    }
    return (_getAdm$set_ = getAdm(target).set_(name2, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name2) {
    var _getAdm$delete_;
    if (!isStringish(name2)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name2, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name2, descriptor) {
    var _getAdm$definePropert;
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name2, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i2 = 0, l2 = interceptors.length; i2 < l2; i2++) {
      change = interceptors[i2](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i2 = 0, l2 = listeners.length; i2 < l2; i2++) {
    listeners[i2](change);
  }
  untrackedEnd(prevU);
}
function makeObservable(target, annotations, options) {
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();
  try {
    var _annotations;
    if (false)
      ;
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
    ownKeys(annotations).forEach(function(key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }
  return target;
}
var keysSymbol = /* @__PURE__ */ Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  if (isPlainObject$4(target)) {
    return extendObservable(target, target, overrides, options);
  }
  var adm = asObservableObject(target, options)[$mobx];
  if (!target[keysSymbol]) {
    var proto = Object.getPrototypeOf(target);
    var keys2 = new Set([].concat(ownKeys(target), ownKeys(proto)));
    keys2["delete"]("constructor");
    keys2["delete"]($mobx);
    addHiddenProp$1(proto, keysSymbol, keys2);
  }
  startBatch();
  try {
    target[keysSymbol].forEach(function(key) {
      return adm.make_(
        key,
        // must pass "undefined" for { key: undefined }
        !overrides ? true : key in overrides ? overrides[key] : true
      );
    });
  } finally {
    endBatch();
  }
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name2) {
    var adm = target[$mobx];
    if (name2 === $mobx) {
      return adm;
    }
    if (name2 === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name2 === "string" && !isNaN(name2)) {
      return adm.get_(parseInt(name2));
    }
    if (hasProp(arrayExtensions, name2)) {
      return arrayExtensions[name2];
    }
    return target[name2];
  },
  set: function set3(target, name2, value) {
    var adm = target[$mobx];
    if (name2 === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name2 === "symbol" || isNaN(name2)) {
      target[name2] = value;
    } else {
      adm.set_(parseInt(name2), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = /* @__PURE__ */ function() {
  function ObservableArrayAdministration2(name2, enhancer, owned_, legacyMode_) {
    if (name2 === void 0) {
      name2 = "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name2);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values2) {
    if (this.dehancer !== void 0 && values2.length > 0) {
      return values2.map(this.dehancer);
    }
    return values2;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i2 = 0; i2 < newLength - currentLength; i2++) {
        newItems[i2] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index2 === void 0) {
      index2 = 0;
    } else if (index2 > length) {
      index2 = length;
    } else if (index2 < 0) {
      index2 = Math.max(0, length + index2);
    }
    if (arguments.length === 1) {
      deleteCount = length - index2;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length - index2));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index2,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v2) {
      return _this.enhancer_(v2, void 0);
    });
    if (this.legacyMode_ || false) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index2, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index2, index2 + deleteCount);
      var oldItems = this.values_.slice(index2 + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i2 = 0; i2 < newItems.length; i2++) {
        this.values_[index2 + i2] = newItems[i2];
      }
      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index2 + newItems.length + _i] = oldItems[_i];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index2,
      newValue,
      oldValue
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index2,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get_ = function get_(index2) {
    if (this.legacyMode_ && index2 >= this.values_.length) {
      console.warn("[mobx] Out of bounds read: " + index2);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index2]);
  };
  _proto.set_ = function set_(index2, newValue) {
    var values2 = this.values_;
    if (this.legacyMode_ && index2 > values2.length) {
      die(17, index2, values2.length);
    }
    if (index2 < values2.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values2[index2];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index2,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values2[index2] = newValue;
        this.notifyArrayChildUpdate_(index2, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index2 + 1 - values2.length);
      for (var i2 = 0; i2 < newItems.length - 1; i2++) {
        newItems[i2] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values2.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name2, owned) {
  if (name2 === void 0) {
    name2 = "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  var adm = new ObservableArrayAdministration(name2, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;
  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }
  return proxy;
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index2, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index2);
      case 2:
        return adm.spliceWithArray_(index2, deleteCount);
    }
    return adm.spliceWithArray_(index2, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items2[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items2);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items2[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items2);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy2 = this.slice();
    copy2.sort.apply(copy2, arguments);
    this.replace(copy2);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index2) {
      return callback.call(thisArg, element, index2, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index2) {
      return callback(accumulator, currentValue, index2, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject$3(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /* @__PURE__ */ function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction$2(Map)) {
      die(18);
    }
    this.keysAtom_ = createAtom("ObservableMap.keys()");
    this.data_ = /* @__PURE__ */ new Map();
    this.hasMap_ = /* @__PURE__ */ new Map();
    allowStateChanges(true, function() {
      _this.merge(initialData);
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has3(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set5(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (notify) {
      notifyListeners(this, change);
    }
  };
  _proto.get = function get4(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys2() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values2() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries2() {
    var self2 = this;
    var keys2 = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[_Symbol$iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach2(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject$4(other)) {
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (other.constructor !== Map) {
          die(19, other);
        }
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear2() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values2) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values2);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString2() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _createClass(ObservableMap2, [{
    key: "size",
    get: function get4() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get4() {
      return "Map";
    }
  }]);
  return ObservableMap2;
}();
var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject$4(dataStructure)) {
    var map2 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map2.set(key, dataStructure[key]);
    }
    return map2;
  } else {
    return die(21, dataStructure);
  }
}
var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /* @__PURE__ */ function() {
  function ObservableSet2(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction$2(Set)) {
      die(22);
    }
    this.atom_ = createAtom(this.name_);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    if (initialData) {
      this.replace(initialData);
    }
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear2() {
    var _this = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach2(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this2 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
    }
    if (!this.has(value)) {
      transaction(function() {
        _this2.data_.add(_this2.enhancer_(value, void 0));
        _this2.atom_.reportChanged();
      });
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this3 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = false;
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      transaction(function() {
        _this3.atom_.reportChanged();
        _this3.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      return true;
    }
    return false;
  };
  _proto.has = function has3(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries2() {
    var nextIndex = 0;
    var keys2 = Array.from(this.keys());
    var values2 = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index2 = nextIndex;
        nextIndex += 1;
        return index2 < values2.length ? {
          value: [keys2[index2], values2[index2]],
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.keys = function keys2() {
    return this.values();
  };
  _proto.values = function values2() {
    this.atom_.reportObserved();
    var self2 = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self2.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };
  _proto.replace = function replace2(other) {
    var _this4 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();
        other.forEach(function(value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.toString = function toString2() {
    return "[object ObservableSet]";
  };
  _proto[_Symbol$iterator$1] = function() {
    return this.values();
  };
  _createClass(ObservableSet2, [{
    key: "size",
    get: function get4() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get4() {
      return "Set";
    }
  }]);
  return ObservableSet2;
}();
var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /* @__PURE__ */ function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom("ObservableObject.keys");
    this.isPlainObject_ = isPlainObject$4(this.target_);
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = false;
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_2(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_2(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends$3({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = false;
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (false)
        ;
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (false)
          ;
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (false)
          ;
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;
    var notify = hasListeners(this);
    var notifySpy = false;
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (notify) {
        notifyListeners(this, change);
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (hasProp(target, $mobx)) {
    return target;
  }
  var name2 = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name2), getAnnotationFromOptions(options));
  addHiddenProp$1(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get4() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set5(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject$3(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}
var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = /* @__PURE__ */ function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  function LegacyObservableArray2(initialValues, enhancer, name2, owned) {
    var _this;
    if (name2 === void 0) {
      name2 = "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name2, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true);
      _this.spliceWithArray(0, 0, initialValues);
      allowStateChangesEnd(prev);
    }
    {
      Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
    }
    return _this;
  }
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      arrays.map(function(a2) {
        return isObservableArray(a2) ? a2.slice() : a2;
      })
    );
  };
  _proto[_Symbol$iterator2] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get4() {
      return this[$mobx].getArrayLength_();
    },
    set: function set5(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get4() {
      return "Array";
    }
  }]);
  return LegacyObservableArray2;
}(StubArray, Symbol.toStringTag, Symbol.iterator);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop2 = _ref[0], fn = _ref[1];
  if (prop2 !== "concat") {
    addHiddenProp$1(LegacyObservableArray.prototype, prop2, fn);
  }
});
function createArrayEntryDescriptor(index2) {
  return {
    enumerable: false,
    configurable: true,
    get: function get4() {
      return this[$mobx].get_(index2);
    },
    set: function set5(value) {
      this[$mobx].set_(index2, value);
    }
  };
}
function createArrayBufferItem(index2) {
  defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
}
function reserveArrayBuffer(max2) {
  if (max2 > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max2 + 100; index2++) {
      createArrayBufferItem(index2);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max2;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name2) {
  return new LegacyObservableArray(initialValues, enhancer, name2);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction$2(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
var toString = objectPrototype.toString;
function deepEqual$2(a2, b2, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a2, b2, depth);
}
function eq(a2, b2, depth, aStack, bStack) {
  if (a2 === b2) {
    return a2 !== 0 || 1 / a2 === 1 / b2;
  }
  if (a2 == null || b2 == null) {
    return false;
  }
  if (a2 !== a2) {
    return b2 !== b2;
  }
  var type = typeof a2;
  if (type !== "function" && type !== "object" && typeof b2 != "object") {
    return false;
  }
  var className = toString.call(a2);
  if (className !== toString.call(b2)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a2 === "" + b2;
    case "[object Number]":
      if (+a2 !== +a2) {
        return +b2 !== +b2;
      }
      return +a2 === 0 ? 1 / +a2 === 1 / b2 : +a2 === +b2;
    case "[object Date]":
    case "[object Boolean]":
      return +a2 === +b2;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a2) === Symbol.valueOf.call(b2);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a2 = unwrap(a2);
  b2 = unwrap(b2);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a2 != "object" || typeof b2 != "object") {
      return false;
    }
    var aCtor = a2.constructor, bCtor = b2.constructor;
    if (aCtor !== bCtor && !(isFunction$2(aCtor) && aCtor instanceof aCtor && isFunction$2(bCtor) && bCtor instanceof bCtor) && "constructor" in a2 && "constructor" in b2) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a2) {
      return bStack[length] === b2;
    }
  }
  aStack.push(a2);
  bStack.push(b2);
  if (areArrays) {
    length = a2.length;
    if (length !== b2.length) {
      return false;
    }
    while (length--) {
      if (!eq(a2[length], b2[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys2 = Object.keys(a2);
    var key;
    length = keys2.length;
    if (Object.keys(b2).length !== length) {
      return false;
    }
    while (length--) {
      key = keys2[length];
      if (!(hasProp(b2, key) && eq(a2[key], b2[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a2) {
  if (isObservableArray(a2)) {
    return a2.slice();
  }
  if (isES6Map(a2) || isObservableMap(a2)) {
    return Array.from(a2.entries());
  }
  if (isES6Set(a2) || isObservableSet(a2)) {
    return Array.from(a2.entries());
  }
  return a2;
}
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}
function getSelf() {
  return this;
}
["Symbol", "Map", "Set"].forEach(function(m2) {
  var g2 = getGlobal();
  if (typeof g2[m2] === "undefined") {
    die("MobX requires global '" + m2 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}
const mobx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $mobx,
  FlowCancellationError,
  ObservableMap,
  ObservableSet,
  Reaction,
  _allowStateChanges: allowStateChanges,
  _allowStateChangesInsideComputed: runInAction,
  _allowStateReadsEnd: allowStateReadsEnd,
  _allowStateReadsStart: allowStateReadsStart,
  _autoAction: autoAction,
  _endAction,
  _getAdministration: getAdministration,
  _getGlobalState: getGlobalState,
  _interceptReads: interceptReads,
  _isComputingDerivation: isComputingDerivation,
  _resetGlobalState: resetGlobalState,
  _startAction,
  action,
  autorun,
  comparer,
  computed,
  configure,
  createAtom,
  defineProperty: apiDefineProperty,
  entries,
  extendObservable,
  flow: flow$1,
  flowResult,
  get: get$2,
  getAtom,
  getDebugName,
  getDependencyTree,
  getObserverTree,
  has,
  intercept,
  isAction,
  isBoxedObservable: isObservableValue,
  isComputed,
  isComputedProp,
  isFlow,
  isFlowCancellationError,
  isObservable,
  isObservableArray,
  isObservableMap,
  isObservableObject,
  isObservableProp,
  isObservableSet,
  keys,
  makeAutoObservable,
  makeObservable,
  observable: observable$1,
  observe,
  onBecomeObserved,
  onBecomeUnobserved,
  onReactionError,
  override,
  ownKeys: apiOwnKeys,
  reaction,
  remove: remove$1,
  runInAction,
  set: set$1,
  spy,
  toJS,
  trace,
  transaction,
  untracked,
  values,
  when
}, Symbol.toStringTag, { value: "Module" }));
if (!reactExports.useState) {
  throw new Error("mobx-react-lite requires React with Hooks support");
}
if (!makeObservable) {
  throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
}
function defaultNoopBatch(callback) {
  callback();
}
function observerBatching(reactionScheduler3) {
  if (!reactionScheduler3) {
    reactionScheduler3 = defaultNoopBatch;
  }
  configure({ reactionScheduler: reactionScheduler3 });
}
function printDebugValue(v2) {
  return getDependencyTree(v2);
}
var REGISTRY_FINALIZE_AFTER = 1e4;
var REGISTRY_SWEEP_INTERVAL = 1e4;
var TimerBasedFinalizationRegistry = (
  /** @class */
  function() {
    function TimerBasedFinalizationRegistry2(finalize) {
      var _this = this;
      Object.defineProperty(this, "finalize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: finalize
      });
      Object.defineProperty(this, "registrations", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "sweepTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "sweep", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function(maxAge) {
          if (maxAge === void 0) {
            maxAge = REGISTRY_FINALIZE_AFTER;
          }
          clearTimeout(_this.sweepTimeout);
          _this.sweepTimeout = void 0;
          var now = Date.now();
          _this.registrations.forEach(function(registration, token) {
            if (now - registration.registeredAt >= maxAge) {
              _this.finalize(registration.value);
              _this.registrations.delete(token);
            }
          });
          if (_this.registrations.size > 0) {
            _this.scheduleSweep();
          }
        }
      });
      Object.defineProperty(this, "finalizeAllImmediately", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: function() {
          _this.sweep(0);
        }
      });
    }
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "register", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(target, value, token) {
        this.registrations.set(token, {
          value,
          registeredAt: Date.now()
        });
        this.scheduleSweep();
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "unregister", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function(token) {
        this.registrations.delete(token);
      }
    });
    Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "scheduleSweep", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: function() {
        if (this.sweepTimeout === void 0) {
          this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
        }
      }
    });
    return TimerBasedFinalizationRegistry2;
  }()
);
var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : TimerBasedFinalizationRegistry;
var observerFinalizationRegistry = new UniversalFinalizationRegistry(function(adm) {
  var _a2;
  (_a2 = adm.reaction) === null || _a2 === void 0 ? void 0 : _a2.dispose();
  adm.reaction = null;
});
var __read$4 = globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
function observerComponentNameFor(baseComponentName) {
  return "observer".concat(baseComponentName);
}
var ObjectToBeRetainedByReact = (
  /** @class */
  function() {
    function ObjectToBeRetainedByReact2() {
    }
    return ObjectToBeRetainedByReact2;
  }()
);
function objectToBeRetainedByReactFactory() {
  return new ObjectToBeRetainedByReact();
}
function useObserver(fn, baseComponentName) {
  if (baseComponentName === void 0) {
    baseComponentName = "observed";
  }
  var _a2 = __read$4(React.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a2[0];
  var _b2 = __read$4(React.useState(), 2), setState = _b2[1];
  var forceUpdate = function() {
    return setState([]);
  };
  var admRef = React.useRef(null);
  if (!admRef.current) {
    admRef.current = {
      reaction: null,
      mounted: false,
      changedBeforeMount: false
    };
  }
  var adm = admRef.current;
  if (!adm.reaction) {
    adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
      if (adm.mounted) {
        forceUpdate();
      } else {
        adm.changedBeforeMount = true;
      }
    });
    observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);
  }
  React.useDebugValue(adm.reaction, printDebugValue);
  React.useEffect(function() {
    observerFinalizationRegistry.unregister(adm);
    adm.mounted = true;
    if (adm.reaction) {
      if (adm.changedBeforeMount) {
        adm.changedBeforeMount = false;
        forceUpdate();
      }
    } else {
      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
        forceUpdate();
      });
      forceUpdate();
    }
    return function() {
      adm.reaction.dispose();
      adm.reaction = null;
      adm.mounted = false;
      adm.changedBeforeMount = false;
    };
  }, []);
  var rendering;
  var exception;
  adm.reaction.track(function() {
    try {
      rendering = fn();
    } catch (e2) {
      exception = e2;
    }
  });
  if (exception) {
    throw exception;
  }
  return rendering;
}
var hasSymbol = typeof Symbol === "function" && Symbol.for;
var ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof reactExports.forwardRef === "function" && reactExports.forwardRef(function(props) {
  return null;
})["$$typeof"];
var ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof reactExports.memo === "function" && reactExports.memo(function(props) {
  return null;
})["$$typeof"];
function observer(baseComponent, options) {
  var _a2;
  if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
    throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
  }
  var useForwardRef = (_a2 = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a2 !== void 0 ? _a2 : false;
  var render = baseComponent;
  var baseComponentName = baseComponent.displayName || baseComponent.name;
  if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
    useForwardRef = true;
    render = baseComponent["render"];
    if (typeof render !== "function") {
      throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
    }
  }
  var observerComponent = function(props, ref) {
    return useObserver(function() {
      return render(props, ref);
    }, baseComponentName);
  };
  if (baseComponentName !== "") {
    observerComponent.displayName = baseComponentName;
  }
  if (baseComponent.contextTypes) {
    observerComponent.contextTypes = baseComponent.contextTypes;
  }
  if (useForwardRef) {
    observerComponent = reactExports.forwardRef(observerComponent);
  }
  observerComponent = reactExports.memo(observerComponent);
  copyStaticProperties(baseComponent, observerComponent);
  return observerComponent;
}
var hoistBlackList = {
  $$typeof: true,
  render: true,
  compare: true,
  type: true,
  // Don't redefine `displayName`,
  // it's defined as getter-setter pair on `memo` (see #3192).
  displayName: true
};
function copyStaticProperties(base, target) {
  Object.keys(base).forEach(function(key) {
    if (!hoistBlackList[key]) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
    }
  });
}
globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var _a$1;
observerBatching(reactDomExports.unstable_batchedUpdates);
(_a$1 = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a$1 !== void 0 ? _a$1 : function() {
};
function identity(x2) {
  return x2;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function observable(subscribe) {
  const self2 = {
    subscribe(observer2) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer2.next?.(value);
        },
        error(err) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer2.error?.(err);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer2.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self2);
    }
  };
  return self2;
}
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer2 of observers) {
            observer2.next?.(value);
          }
        },
        error(error) {
          for (const observer2 of observers) {
            observer2.error?.(error);
          }
        },
        complete() {
          for (const observer2 of observers) {
            observer2.complete?.();
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer2) {
        refCount++;
        observers.push(observer2);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index2 = observers.findIndex((v2) => v2 === observer2);
            if (index2 > -1) {
              observers.splice(index2, 1);
            }
          }
        };
      }
    };
  };
}
function tap(observer2) {
  return (originalObserver) => {
    return {
      subscribe(observer22) {
        return originalObserver.subscribe({
          next(v2) {
            observer2.next?.(v2);
            observer22.next?.(v2);
          },
          error(v2) {
            observer2.error?.(v2);
            observer22.error?.(v2);
          },
          complete() {
            observer2.complete?.();
            observer22.complete?.();
          }
        });
      }
    };
  };
}
class ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, ObservableAbortError.prototype);
  }
}
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}
function createChain(opts) {
  return observable((observer2) => {
    function execute(index2 = 0, op = opts.op) {
      const next = opts.links[index2];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index2 + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer2);
  });
}
function asArray(value) {
  return Array.isArray(value) ? value : [
    value
  ];
}
function splitLink(opts) {
  return (runtime) => {
    const yes = asArray(opts.true).map((link) => link(runtime));
    const no2 = asArray(opts.false).map((link) => link(runtime));
    return (props) => {
      return observable((observer2) => {
        const links = opts.condition(props.op) ? yes : no2;
        return createChain({
          op: props.op,
          links
        }).subscribe(observer2);
      });
    };
  };
}
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause.name === "TRPCClientError";
}
class TRPCClientError extends Error {
  static from(cause, opts = {}) {
    if (!(cause instanceof Error)) {
      return new TRPCClientError(cause.error.message ?? "", {
        ...opts,
        cause: void 0,
        result: cause
      });
    }
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    return new TRPCClientError(cause.message, {
      ...opts,
      cause,
      result: null
    });
  }
  constructor(message, opts) {
    const cause = opts?.cause;
    super(message, {
      cause
    });
    this.meta = opts?.meta;
    this.cause = cause;
    this.shape = opts?.result?.error;
    this.data = opts?.result?.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, TRPCClientError.prototype);
  }
}
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v2 = obj[key];
    newObj[v2] = key;
  }
  return newObj;
}
const TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
invert(TRPC_ERROR_CODES_BY_KEY);
invert(TRPC_ERROR_CODES_BY_KEY);
const noop$3 = () => {
};
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop$3, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path[path.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path.slice(0, -1) : path
      });
    }
  });
  return proxy;
}
const createRecursiveProxy = (callback) => createInnerProxy(callback, []);
const createFlatProxy = (callback) => {
  return new Proxy(noop$3, {
    get(_obj, name2) {
      if (typeof name2 !== "string" || name2 === "then") {
        return void 0;
      }
      return callback(name2);
    }
  });
};
const isFunction$1 = (fn) => typeof fn === "function";
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction$1(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction$1(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url,
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
function arrayToDict(array2) {
  const dict = {};
  for (let index2 = 0; index2 < array2.length; index2++) {
    const element = array2[index2];
    dict[index2] = element;
  }
  return dict;
}
const METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
const getUrl = (opts) => {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
};
const getBody = (opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
};
const jsonHttpRequester = (opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
};
async function fetchHTTPResponse(opts, ac2) {
  const url = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type } = opts;
  const resolvedHeaders = await opts.headers();
  /* istanbul ignore if -- @preserve */
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers2 = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url, {
    method: METHOD[type],
    signal: ac2?.signal,
    body,
    headers: headers2
  });
}
function httpRequest(opts) {
  const ac2 = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  const promise = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts, ac2).then((_res) => {
      meta.response = _res;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = () => {
    ac2?.abort();
  };
  return {
    promise,
    cancel
  };
}
function isObject$2(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
class TransformResultError extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
}
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject$2(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject$2(result.result)) {
    throw new TransformResultError();
  }
  return result;
}
const throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items2) {
    const groupedItems = [
      []
    ];
    let index2 = 0;
    while (true) {
      const item = items2[index2];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index2++;
        continue;
      }
      const isValid2 = batchLoader.validate(lastGroup.concat(item).map((it2) => it2.key));
      if (isValid2) {
        lastGroup.push(item);
        index2++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index2++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items2 of groupedItems) {
      if (!items2.length) {
        continue;
      }
      const batch = {
        items: items2,
        cancel: throwFatalError
      };
      for (const item of items2) {
        item.batch = batch;
      }
      const unitResolver = (index2, value) => {
        const item = batch.items[index2];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      };
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise.then((result) => {
        for (let i2 = 0; i2 < result.length; i2++) {
          const value = result[i2];
          unitResolver(i2, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  function load2(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise,
      cancel
    };
  }
  return {
    load: load2
  };
}
function createHTTPBatchLink(requester) {
  return function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = (type) => {
        const validate = (batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path,
            inputs
          });
          return url.length <= maxURLLength;
        };
        const fetch2 = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts
        });
        return {
          validate,
          fetch: fetch2
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer2) => {
          const loader2 = loaders[op.type];
          const { promise, cancel } = loader2.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer2.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer2.next({
              context: res.meta,
              result: transformed.result
            });
            observer2.complete();
          }).catch((err) => {
            observer2.error(TRPCClientError.from(err, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  };
}
const batchRequester = (requesterOpts) => {
  return (batchOps) => {
    const path = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
};
const httpBatchLink = createHTTPBatchLink(batchRequester);
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer2) => {
      const { path, input, type } = op;
      const { promise, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type,
        path,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer2.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer2.next({
          context: res.meta,
          result: transformed.result
        });
        observer2.complete();
      }).catch((cause) => {
        observer2.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
const httpLink = httpLinkFactory({
  requester: jsonHttpRequester
});
function isFormData(value) {
  if (typeof FormData === "undefined") {
    return false;
  }
  return value instanceof FormData;
}
const palettes = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function constructPartsAndArgs(opts) {
  const { direction, type, path, id: id2, input } = opts;
  const parts = [];
  const args = [];
  if (opts.colorMode === "ansi") {
    const [lightRegular, darkRegular] = palettes.ansi.regular[type];
    const [lightBold, darkBold] = palettes.ansi.bold[type];
    const reset = "\x1B[0m";
    parts.push(direction === "up" ? lightRegular : darkRegular, direction === "up" ? ">>" : "<<", type, direction === "up" ? lightBold : darkBold, `#${id2}`, path, reset);
    if (direction === "up") {
      args.push({
        input: opts.input
      });
    } else {
      args.push({
        input: opts.input,
        // strip context from result cause it's too noisy in terminal wihtout collapse mode
        result: "result" in opts.result ? opts.result.result : opts.result,
        elapsedMs: opts.elapsedMs
      });
    }
    return {
      parts,
      args
    };
  }
  const [light, dark] = palettes.css[type];
  const css = `
    background-color: #${direction === "up" ? light : dark}; 
    color: ${direction === "up" ? "black" : "white"};
    padding: 2px;
  `;
  parts.push("%c", direction === "up" ? ">>" : "<<", type, `#${id2}`, `%c${path}%c`, "%O");
  args.push(css, `${css}; font-weight: bold;`, `${css}; font-weight: normal;`);
  if (direction === "up") {
    args.push({
      input,
      context: opts.context
    });
  } else {
    args.push({
      input,
      result: opts.result,
      elapsedMs: opts.elapsedMs,
      context: opts.context
    });
  }
  return {
    parts,
    args
  };
}
const defaultLogger = ({ c: c2 = console, colorMode = "css" }) => (props) => {
  const rawInput = props.input;
  const input = isFormData(rawInput) ? Object.fromEntries(rawInput) : rawInput;
  const { parts, args } = constructPartsAndArgs({
    ...props,
    colorMode,
    input
  });
  const fn = props.direction === "down" && props.result && (props.result instanceof Error || "error" in props.result.result) ? "error" : "log";
  c2[fn].apply(null, [
    parts.join(" ")
  ].concat(args));
};
function loggerLink(opts = {}) {
  const { enabled = () => true } = opts;
  const colorMode = opts.colorMode ?? (typeof window === "undefined" ? "ansi" : "css");
  const { logger = defaultLogger({
    c: opts.console,
    colorMode
  }) } = opts;
  return () => {
    return ({ op, next }) => {
      return observable((observer2) => {
        enabled({
          ...op,
          direction: "up"
        }) && logger({
          ...op,
          direction: "up"
        });
        const requestStartTime = Date.now();
        function logResult(result) {
          const elapsedMs = Date.now() - requestStartTime;
          enabled({
            ...op,
            direction: "down",
            result
          }) && logger({
            ...op,
            direction: "down",
            elapsedMs,
            result
          });
        }
        return next(op).pipe(tap({
          next(result) {
            logResult(result);
          },
          error(result) {
            logResult(result);
          }
        })).subscribe(observer2);
      });
    };
  };
}
class TRPCUntypedClient {
  $request({ type, input, path, context = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path,
        input,
        context
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      opts.signal?.addEventListener("abort", abort);
      promise.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  mutation(path, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  subscription(path, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path,
      input,
      context: opts?.context
    });
    return observable$.subscribe({
      next(envelope) {
        if (envelope.result.type === "started") {
          opts.onStarted?.();
        } else if (envelope.result.type === "stopped") {
          opts.onStopped?.();
        } else {
          opts.onData?.(envelope.result.data);
        }
      },
      error(err) {
        opts.onError?.(err);
      },
      complete() {
        opts.onComplete?.();
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: (data) => data,
            deserialize: (data) => data
          },
          output: {
            serialize: (data) => data,
            deserialize: (data) => data
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (data) => combinedTransformer.input.serialize(data),
        deserialize: (data) => combinedTransformer.output.deserialize(data)
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
}
const clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
const clientCallTypeToProcedureType = (clientCallType) => {
  return clientCallTypeMap[clientCallType];
};
function createTRPCClientProxy(client2) {
  return createFlatProxy((key) => {
    if (client2.hasOwnProperty(key)) {
      return client2[key];
    }
    if (key === "__untypedClient") {
      return client2;
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client2[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts) {
  const client2 = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client2);
  return proxy;
}
var __defProp$b = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a, _b, _c, _d, _e$4, _f;
const dataModelActionRegistry = /* @__PURE__ */ new Map();
function getDataModelAction(fullActionName) {
  return dataModelActionRegistry.get(fullActionName);
}
function setDataModelAction(fullActionName, modelClass2, fnName) {
  dataModelActionRegistry.set(fullActionName, {
    modelClass: modelClass2,
    fnName
  });
}
var BuiltInAction;
(function(BuiltInAction2) {
  BuiltInAction2["ApplyPatches"] = "$$applyPatches";
  BuiltInAction2["ApplySnapshot"] = "$$applySnapshot";
  BuiltInAction2["Detach"] = "$$detach";
  BuiltInAction2["ApplySet"] = "$$applySet";
  BuiltInAction2["ApplyDelete"] = "$$applyDelete";
  BuiltInAction2["ApplyMethodCall"] = "$$applyMethodCall";
})(BuiltInAction || (BuiltInAction = {}));
const builtInActionValues = new Set(Object.values(BuiltInAction));
function isBuiltInAction(actionName) {
  return builtInActionValues.has(actionName);
}
var ActionContextActionType;
(function(ActionContextActionType2) {
  ActionContextActionType2["Sync"] = "sync";
  ActionContextActionType2["Async"] = "async";
})(ActionContextActionType || (ActionContextActionType = {}));
var ActionContextAsyncStepType;
(function(ActionContextAsyncStepType2) {
  ActionContextAsyncStepType2["Spawn"] = "spawn";
  ActionContextAsyncStepType2["Return"] = "return";
  ActionContextAsyncStepType2["Resume"] = "resume";
  ActionContextAsyncStepType2["ResumeError"] = "resumeError";
  ActionContextAsyncStepType2["Throw"] = "throw";
})(ActionContextAsyncStepType || (ActionContextAsyncStepType = {}));
let currentActionContext;
function getCurrentActionContext() {
  return currentActionContext;
}
function setCurrentActionContext(ctx) {
  currentActionContext = ctx;
}
const modelActionSymbol = Symbol("modelAction");
function isModelAction(fn) {
  return typeof fn === "function" && modelActionSymbol in fn;
}
const modelTypeKey = "$modelType";
const modelIdKey = "$modelId";
function isReservedModelKey(key) {
  return key === modelTypeKey;
}
class MobxKeystoneError extends Error {
  constructor(msg) {
    super(msg);
    Object.setPrototypeOf(this, MobxKeystoneError.prototype);
  }
}
function failure(msg) {
  return new MobxKeystoneError(msg);
}
const writableHiddenPropDescriptor = {
  enumerable: false,
  writable: true,
  configurable: false,
  value: void 0
};
function addHiddenProp(object2, propName, value, writable = true) {
  if (writable) {
    Object.defineProperty(object2, propName, writableHiddenPropDescriptor);
    object2[propName] = value;
  } else {
    Object.defineProperty(object2, propName, {
      enumerable: false,
      writable,
      configurable: true,
      value
    });
  }
}
function isPlainObject$3(value) {
  if (!isObject$1(value))
    return false;
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function isObject$1(value) {
  return value !== null && typeof value === "object";
}
function isPrimitive$2(value) {
  switch (typeof value) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
    case "bigint":
      return true;
  }
  return value === null;
}
function isJSONPrimitive(value) {
  switch (typeof value) {
    case "number":
      return isFinite(value);
    case "string":
    case "boolean":
      return true;
  }
  return value === null;
}
function isMap$1(val) {
  return val instanceof Map || isObservableMap(val);
}
function isSet$1(val) {
  return val instanceof Set || isObservableSet(val);
}
function isArray$2(val) {
  return Array.isArray(val) || isObservableArray(val);
}
const inDevMode = false;
function assertIsObject(value, argName) {
  if (!isObject$1(value)) {
    throw failure(`${argName} must be an object`);
  }
}
function assertIsFunction(value, argName) {
  if (typeof value !== "function") {
    throw failure(`${argName} must be a function`);
  }
}
function assertIsPrimitive(value, argName) {
  if (!isPrimitive$2(value)) {
    throw failure(`${argName} must be a primitive`);
  }
}
const runAfterNewSymbol = Symbol("runAfterNew");
const runBeforeOnInitSymbol = Symbol("runBeforeOnInit");
function addLateInitializationFunction(target, symbol, fn) {
  let array2 = target[symbol];
  if (!array2 || !Object.prototype.hasOwnProperty.call(target, symbol)) {
    array2 = array2 ? array2.slice() : [];
    addHiddenProp(target, symbol, array2);
  }
  array2.push(fn);
}
const unboundMethodSymbol = Symbol("unboundMethod");
function decorateWrapMethodOrField(decoratorName, data, wrap) {
  const { target, propertyKey, baseDescriptor } = data;
  const addFieldDecorator = () => {
    addLateInitializationFunction(target, runAfterNewSymbol, (instance) => {
      const method = wrap(data, instance[propertyKey]);
      const unboundMethod = unboundMethodSymbol in method ? method[unboundMethodSymbol] : method;
      const boundMethod = unboundMethod.bind(instance);
      Object.getOwnPropertySymbols(unboundMethod).forEach((s2) => {
        boundMethod[s2] = unboundMethod[s2];
      });
      boundMethod[unboundMethodSymbol] = unboundMethod;
      instance[propertyKey] = boundMethod;
    });
  };
  if (baseDescriptor) {
    if (baseDescriptor.get !== void 0) {
      throw failure(`@${decoratorName} cannot be used with getters`);
    }
    if (baseDescriptor.value) {
      return {
        enumerable: false,
        writable: true,
        configurable: true,
        value: wrap(data, baseDescriptor.value)
      };
    } else {
      addFieldDecorator();
    }
  } else {
    addFieldDecorator();
  }
}
function runLateInitializationFunctions(target, symbol) {
  const fns = target[symbol];
  if (fns) {
    for (const fn of fns) {
      fn(target);
    }
  }
}
const warningsAlreadyDisplayed = /* @__PURE__ */ new Set();
function logWarning(type, msg, uniqueKey) {
  if (uniqueKey) {
    if (warningsAlreadyDisplayed.has(uniqueKey)) {
      return;
    }
    warningsAlreadyDisplayed.add(uniqueKey);
  }
  msg = "[mobx-keystone] " + msg;
  switch (type) {
    case "warn":
      console.warn(msg);
      break;
    case "error":
      console.error(msg);
      break;
    default:
      throw failure(`unknown log type - ${type}`);
  }
}
function lazy(getter) {
  let memoizedValue;
  let memoized = false;
  return (...args) => {
    if (!memoized) {
      memoizedValue = getter(...args);
      memoized = true;
    }
    return memoizedValue;
  };
}
const identityFn = (x2) => x2;
const mobx6 = {
  // eslint-disable-next-line no-useless-concat
  makeObservable: mobx[
    // just to ensure import * is kept properly
    String.fromCharCode("l".charCodeAt(0) + 1) + "akeObservable"
  ]
};
function propNameToSetterName(propName) {
  return `set${propName[0].toUpperCase()}${propName.slice(1)}`;
}
function getMobxVersion() {
  if (mobx6.makeObservable) {
    return 6;
  } else {
    return 5;
  }
}
const namespace$2 = "mobx-keystone";
const propsTypeSymbol = Symbol("propsType");
const fromSnapshotOverrideTypeSymbol = Symbol("fromSnapshotOverrideType");
const toSnapshotOverrideTypeSymbol = Symbol("toSnapshotOverrideType");
const modelInitializedSymbol = Symbol("modelInitialized");
const modelInfoByName = {};
const modelInfoByClass = /* @__PURE__ */ new WeakMap();
function getModelInfoForName(name2) {
  return modelInfoByName[name2];
}
function getOrCreate(map2, key, create) {
  let value = map2.get(key);
  if (value === void 0) {
    value = create();
    map2.set(key, value);
  }
  return value;
}
const objectParents = /* @__PURE__ */ new WeakMap();
const objectParentsAtoms = /* @__PURE__ */ new WeakMap();
function parentPathEquals(parentPath1, parentPath2, comparePath = true) {
  if (!parentPath1 && !parentPath2)
    return true;
  if (!parentPath1 || !parentPath2)
    return false;
  const parentEquals = parentPath1.parent === parentPath2.parent;
  if (!parentEquals)
    return false;
  return comparePath ? parentPath1.path === parentPath2.path : true;
}
function createParentPathAtom(obj) {
  return getOrCreate(objectParentsAtoms, obj, () => createAtom("parentAtom"));
}
function reportParentPathObserved(node) {
  createParentPathAtom(node).reportObserved();
}
function reportParentPathChanged(node) {
  createParentPathAtom(node).reportChanged();
}
const dataObjectParent = /* @__PURE__ */ new WeakMap();
function dataToModelNode(node) {
  const modelNode = dataObjectParent.get(node);
  return modelNode != null ? modelNode : node;
}
function modelToDataNode(node) {
  return isModel(node) ? node.$ : node;
}
const tweakedObjects = /* @__PURE__ */ new WeakMap();
function isTweakedObject(value, canBeDataObject) {
  if (!canBeDataObject && dataObjectParent.has(value)) {
    return false;
  }
  return tweakedObjects.has(value);
}
function isTreeNode(value) {
  return !isPrimitive$2(value) && isTweakedObject(value, false);
}
function assertTweakedObject(treeNode, argName, canBeDataObject = false) {
  if (!canBeDataObject && dataObjectParent.has(treeNode)) {
    throw failure(`${argName} must be the model object instance instead of the '$' sub-object`);
  }
  if (isPrimitive$2(treeNode) || !isTweakedObject(treeNode, true)) {
    throw failure(`${argName} must be a tree node (usually a model or a shallow / deep child part of a model 'data' object)`);
  }
}
function assertIsTreeNode(value, argName = "argument") {
  assertTweakedObject(value, argName, false);
}
let runningWithoutSnapshotOrPatches = false;
function runWithoutSnapshotOrPatches(fn) {
  const old = runningWithoutSnapshotOrPatches;
  runningWithoutSnapshotOrPatches = true;
  try {
    runInAction(() => {
      fn();
    });
  } finally {
    runningWithoutSnapshotOrPatches = old;
  }
}
const modelMetadataSymbol = Symbol("modelMetadata");
const modelUnwrappedClassSymbol = Symbol("modelUnwrappedClass");
const runAfterModelDecoratorSymbol = Symbol("runAfterModelDecorator");
function getModelMetadata(modelClassOrInstance) {
  if (isModel(modelClassOrInstance)) {
    return modelClassOrInstance.constructor[modelMetadataSymbol];
  } else if (isModelClass(modelClassOrInstance)) {
    return modelClassOrInstance[modelMetadataSymbol];
  } else {
    throw failure(`modelClassOrInstance must be a model class or instance`);
  }
}
const modelIdPropertyNameCache = /* @__PURE__ */ new WeakMap();
function getModelIdPropertyName(modelClass2) {
  return getOrCreate(modelIdPropertyNameCache, modelClass2, () => getModelMetadata(modelClass2).modelIdProperty);
}
const modelPropertiesSymbol = Symbol("modelProperties");
function getInternalModelClassPropsInfo(modelClass2) {
  return modelClass2[modelPropertiesSymbol];
}
function setInternalModelClassPropsInfo(modelClass2, props) {
  modelClass2[modelPropertiesSymbol] = props;
}
const noDefaultValue = Symbol("noDefaultValue");
const idProp = {
  _setter: false,
  _isId: true,
  withSetter(mode) {
    const obj = Object.create(this);
    obj._setter = mode != null ? mode : true;
    return obj;
  },
  typedAs() {
    return idProp;
  }
};
const baseProp = {
  ...{},
  _defaultFn: noDefaultValue,
  _defaultValue: noDefaultValue,
  _typeChecker: void 0,
  _setter: false,
  _isId: false,
  _transform: void 0,
  _fromSnapshotProcessor: void 0,
  _toSnapshotProcessor: void 0,
  withSetter(mode) {
    const obj = Object.create(this);
    obj._setter = mode != null ? mode : true;
    return obj;
  },
  withTransform(transform) {
    const obj = Object.create(this);
    obj._transform = toFullTransform(transform);
    return obj;
  },
  withSnapshotProcessor({ fromSnapshot: fromSnapshot2, toSnapshot }) {
    let newFromSnapshot;
    if (this._fromSnapshotProcessor && fromSnapshot2) {
      const oldFn = this._fromSnapshotProcessor;
      const newFn = fromSnapshot2;
      newFromSnapshot = (sn) => oldFn(newFn(sn));
    } else if (fromSnapshot2) {
      newFromSnapshot = fromSnapshot2;
    } else {
      newFromSnapshot = this._fromSnapshotProcessor;
    }
    let newToSnapshot;
    if (this._toSnapshotProcessor && toSnapshot) {
      const oldFn = this._toSnapshotProcessor;
      const newFn = toSnapshot;
      newToSnapshot = (sn) => newFn(oldFn(sn));
    } else if (toSnapshot) {
      newToSnapshot = toSnapshot;
    } else {
      newToSnapshot = this._toSnapshotProcessor;
    }
    const obj = Object.create(this);
    obj._fromSnapshotProcessor = newFromSnapshot;
    obj._toSnapshotProcessor = newToSnapshot;
    return obj;
  }
};
function prop(def) {
  const hasDefaultValue = arguments.length >= 1;
  if (!hasDefaultValue) {
    return baseProp;
  }
  let p2 = propCache.get(def);
  if (!p2) {
    p2 = Object.create(baseProp);
    if (typeof def === "function") {
      p2._defaultFn = def;
    } else {
      p2._defaultValue = def;
    }
    propCache.set(def, p2);
  }
  return p2;
}
const propCache = /* @__PURE__ */ new Map();
let cacheTransformResult = false;
const cacheTransformedValueFn = () => {
  cacheTransformResult = true;
};
function toFullTransform(transformObject) {
  const cache2 = /* @__PURE__ */ new WeakMap();
  const transform = (params) => params.originalValue == null ? params.originalValue : transformObject.transform(params);
  const untransform = (params) => params.transformedValue == null ? params.transformedValue : transformObject.untransform(params);
  return {
    transform(originalValue, model2, propName, setOriginalValue) {
      const modelCache = getOrCreate(cache2, model2, () => /* @__PURE__ */ new Map());
      let propCache2 = modelCache.get(propName);
      if ((propCache2 == null ? void 0 : propCache2.originalValue) !== originalValue) {
        modelCache.delete(propName);
        propCache2 = void 0;
      }
      const transformedValue = transform({
        originalValue,
        cachedTransformedValue: propCache2 == null ? void 0 : propCache2.transformedValue,
        setOriginalValue
      });
      modelCache.set(propName, {
        originalValue,
        transformedValue
      });
      return transformedValue;
    },
    untransform(transformedValue, model2, propName) {
      const modelCache = getOrCreate(cache2, model2, () => /* @__PURE__ */ new Map());
      cacheTransformResult = false;
      const originalValue = untransform({
        transformedValue,
        cacheTransformedValue: cacheTransformedValueFn
      });
      if (cacheTransformResult) {
        modelCache.set(propName, { originalValue, transformedValue });
      } else {
        modelCache.delete(propName);
      }
      return originalValue;
    }
  };
}
function getModelPropDefaultValue(propData) {
  if (propData._defaultFn !== noDefaultValue) {
    return propData._defaultFn();
  }
  if (propData._defaultValue !== noDefaultValue) {
    return propData._defaultValue;
  }
  return noDefaultValue;
}
class TypeCheckError {
  /**
   * Creates an instance of TypeError.
   * @param path Sub-path (where the root is the value being type checked) where the error occured.
   * @param expectedTypeName Name of the expected type.
   * @param actualValue Actual value.
   * @param typeCheckedValue The value where the type check was invoked.
   */
  constructor(path, expectedTypeName, actualValue, typeCheckedValue) {
    __publicField(this, "path");
    __publicField(this, "expectedTypeName");
    __publicField(this, "actualValue");
    __publicField(this, "typeCheckedValue");
    __publicField(this, "message");
    this.path = path;
    this.expectedTypeName = expectedTypeName;
    this.actualValue = actualValue;
    this.typeCheckedValue = typeCheckedValue;
    let rootPath = [];
    if (this.typeCheckedValue && isTweakedObject(this.typeCheckedValue, true)) {
      rootPath = fastGetRootPath(this.typeCheckedValue).path;
    }
    const actualValueSnapshot = isTweakedObject(this.actualValue, true) ? getSnapshot(this.actualValue) : this.actualValue;
    this.message = `TypeCheckError: [/${[...rootPath, ...this.path].join("/")}] Expected a value of type <${this.expectedTypeName}> but got the value <${JSON.stringify(actualValueSnapshot)}> instead`;
  }
  /**
   * Throws the type check error as an actual error.
   */
  throw() {
    throw failure(this.message);
  }
}
const emptyPath = [];
const typeCheckersWithCachedResultsOfObject = /* @__PURE__ */ new WeakMap();
var TypeCheckerBaseType;
(function(TypeCheckerBaseType2) {
  TypeCheckerBaseType2["Object"] = "object";
  TypeCheckerBaseType2["Array"] = "array";
  TypeCheckerBaseType2["Primitive"] = "primitive";
  TypeCheckerBaseType2["Any"] = "any";
})(TypeCheckerBaseType || (TypeCheckerBaseType = {}));
function getTypeCheckerBaseTypeFromValue(value) {
  if (isArray$2(value))
    return TypeCheckerBaseType.Array;
  if (isObject$1(value))
    return TypeCheckerBaseType.Object;
  if (isPrimitive$2(value))
    return TypeCheckerBaseType.Primitive;
  return TypeCheckerBaseType.Any;
}
function invalidateCachedTypeCheckerResult(obj) {
  let current = obj;
  while (current) {
    const set22 = typeCheckersWithCachedResultsOfObject.get(current);
    if (set22) {
      typeCheckersWithCachedResultsOfObject.delete(current);
      set22.forEach((typeChecker) => typeChecker.invalidateCachedResult(current));
    }
    current = fastGetParentIncludingDataObjects(current);
  }
}
const typeCheckersWithCachedSnapshotProcessorResultsOfObject = /* @__PURE__ */ new WeakMap();
function invalidateCachedToSnapshotProcessorResult(obj) {
  const set22 = typeCheckersWithCachedSnapshotProcessorResultsOfObject.get(obj);
  if (set22) {
    set22.forEach((typeChecker) => typeChecker.invalidateSnapshotProcessorCachedResult(obj));
    typeCheckersWithCachedSnapshotProcessorResultsOfObject.delete(obj);
  }
}
class TypeChecker {
  constructor(baseType, _check, getTypeName, typeInfoGen, snapshotType, _fromSnapshotProcessor, _toSnapshotProcessor) {
    __publicField(this, "baseType");
    __publicField(this, "_check");
    __publicField(this, "getTypeName");
    __publicField(this, "typeInfoGen");
    __publicField(this, "snapshotType");
    __publicField(this, "_fromSnapshotProcessor");
    __publicField(this, "_toSnapshotProcessor");
    __publicField(this, "checkResultCache");
    __publicField(this, "unchecked");
    __publicField(this, "_cachedTypeInfoGen");
    __publicField(this, "fromSnapshotProcessor", (sn) => {
      return this._fromSnapshotProcessor(sn);
    });
    __publicField(this, "_toSnapshotProcessorCache", /* @__PURE__ */ new WeakMap());
    __publicField(this, "toSnapshotProcessor", (sn) => {
      if (typeof sn !== "object" || sn === null) {
        return this._toSnapshotProcessor(sn);
      }
      if (this._toSnapshotProcessorCache.has(sn)) {
        return this._toSnapshotProcessorCache.get(sn);
      }
      const val = this._toSnapshotProcessor(sn);
      this._toSnapshotProcessorCache.set(sn, val);
      const typeCheckerSet = getOrCreate(typeCheckersWithCachedSnapshotProcessorResultsOfObject, sn, () => /* @__PURE__ */ new Set());
      typeCheckerSet.add(this);
      return val;
    });
    this.baseType = baseType;
    this._check = _check;
    this.getTypeName = getTypeName;
    this.typeInfoGen = typeInfoGen;
    this.snapshotType = snapshotType;
    this._fromSnapshotProcessor = _fromSnapshotProcessor;
    this._toSnapshotProcessor = _toSnapshotProcessor;
    this.unchecked = !_check;
    this._cachedTypeInfoGen = lazy(typeInfoGen);
  }
  createCacheIfNeeded() {
    if (!this.checkResultCache) {
      this.checkResultCache = /* @__PURE__ */ new WeakMap();
    }
    return this.checkResultCache;
  }
  setCachedResult(obj, newCacheValue) {
    this.createCacheIfNeeded().set(obj, newCacheValue);
    const typeCheckerSet = getOrCreate(typeCheckersWithCachedResultsOfObject, obj, () => /* @__PURE__ */ new Set());
    typeCheckerSet.add(this);
  }
  invalidateCachedResult(obj) {
    var _a2;
    (_a2 = this.checkResultCache) == null ? void 0 : _a2.delete(obj);
  }
  getCachedResult(obj) {
    var _a2;
    return (_a2 = this.checkResultCache) == null ? void 0 : _a2.get(obj);
  }
  check(value, path, typeCheckedValue) {
    if (this.unchecked) {
      return null;
    }
    if (!isTweakedObject(value, true)) {
      return this._check(value, path, typeCheckedValue);
    }
    let cachedResult = this.getCachedResult(value);
    if (cachedResult === void 0) {
      cachedResult = this._check(value, emptyPath, void 0);
      this.setCachedResult(value, cachedResult);
    }
    if (cachedResult) {
      return new TypeCheckError([...path, ...cachedResult.path], cachedResult.expectedTypeName, cachedResult.actualValue, typeCheckedValue);
    } else {
      return null;
    }
  }
  get typeInfo() {
    return this._cachedTypeInfoGen(this);
  }
  invalidateSnapshotProcessorCachedResult(obj) {
    this._toSnapshotProcessorCache.delete(obj);
  }
}
const lateTypeCheckerSymbol = Symbol("lateTypeCheker");
function lateTypeChecker(fn, typeInfoGen) {
  let cached;
  const ltc = function() {
    if (cached) {
      return cached;
    }
    cached = fn();
    return cached;
  };
  ltc[lateTypeCheckerSymbol] = true;
  const cachedTypeInfoGen = lazy(typeInfoGen);
  Object.defineProperty(ltc, "typeInfo", {
    enumerable: true,
    configurable: true,
    get() {
      return cachedTypeInfoGen(ltc);
    }
  });
  return ltc;
}
function isLateTypeChecker(ltc) {
  return typeof ltc === "function" && lateTypeCheckerSymbol in ltc;
}
class TypeInfo {
  constructor(thisType) {
    __publicField(this, "thisType");
    this.thisType = thisType;
  }
}
function getTypeInfo(type) {
  const stdType = resolveStandardType(type);
  const typeInfo = stdType.typeInfo;
  if (!typeInfo) {
    throw failure(`type info not found for ${type}`);
  }
  return typeInfo;
}
const cachedModelTypeChecker = /* @__PURE__ */ new WeakMap();
function typesModel(modelClass2) {
  if (!isModelClass(modelClass2) && typeof modelClass2 === "function") {
    const modelClassFn = modelClass2;
    const typeInfoGen = (t2) => new ModelTypeInfo(t2, modelClassFn());
    return lateTypeChecker(() => typesModel(modelClassFn()), typeInfoGen);
  } else {
    const modelClazz = modelClass2;
    const cachedTypeChecker = cachedModelTypeChecker.get(modelClazz);
    if (cachedTypeChecker) {
      return cachedTypeChecker;
    }
    const typeInfoGen = (t2) => new ModelTypeInfo(t2, modelClazz);
    const tc2 = lateTypeChecker(() => {
      const modelInfo = modelInfoByClass.get(modelClazz);
      const typeName = `Model(${modelInfo.name})`;
      const dataTypeChecker = getModelMetadata(modelClazz).dataType;
      const resolvedDataTypeChecker = dataTypeChecker ? resolveTypeChecker(dataTypeChecker) : void 0;
      const thisTc = new TypeChecker(TypeCheckerBaseType.Object, (value, path, typeCheckedValue) => {
        if (!(value instanceof modelClazz)) {
          return new TypeCheckError(path, typeName, value, typeCheckedValue);
        }
        if (resolvedDataTypeChecker) {
          return resolvedDataTypeChecker.check(value.$, path, typeCheckedValue);
        }
        return null;
      }, () => typeName, typeInfoGen, (value) => {
        if (!isObject$1(value)) {
          return null;
        }
        if (value[modelTypeKey] !== void 0) {
          return value[modelTypeKey] === modelInfo.name ? thisTc : null;
        }
        if (resolvedDataTypeChecker) {
          return resolvedDataTypeChecker.snapshotType(value) ? thisTc : null;
        }
        return null;
      }, (sn) => {
        if (sn[modelTypeKey]) {
          return sn;
        } else {
          return {
            ...sn,
            [modelTypeKey]: modelInfo.name
          };
        }
      }, (sn) => sn);
      return thisTc;
    }, typeInfoGen);
    cachedModelTypeChecker.set(modelClazz, tc2);
    return tc2;
  }
}
class ModelTypeInfo extends TypeInfo {
  constructor(thisType, modelClass2) {
    super(thisType);
    __publicField(this, "modelClass");
    __publicField(this, "_props", lazy(() => {
      const objSchema = getInternalModelClassPropsInfo(this.modelClass);
      const propTypes = {};
      Object.keys(objSchema).forEach((propName) => {
        const propData = objSchema[propName];
        const type = propData._typeChecker;
        let typeInfo;
        if (type) {
          typeInfo = getTypeInfo(type);
        }
        let hasDefault = false;
        let defaultValue;
        if (propData._defaultFn !== noDefaultValue) {
          defaultValue = propData._defaultFn;
          hasDefault = true;
        } else if (propData._defaultValue !== noDefaultValue) {
          defaultValue = propData._defaultValue;
          hasDefault = true;
        }
        propTypes[propName] = {
          type,
          typeInfo,
          hasDefault,
          default: defaultValue
        };
      });
      return propTypes;
    }));
    this.modelClass = modelClass2;
  }
  get props() {
    return this._props();
  }
  get modelType() {
    const modelInfo = modelInfoByClass.get(this.modelClass);
    return modelInfo.name;
  }
}
function registerModelStandardTypeResolver() {
  registerStandardTypeResolver((v2) => isModelClass(v2) ? typesModel(v2) : void 0);
}
const standardTypeResolvers$1 = [];
function typesLiteral(literal) {
  assertIsPrimitive(literal, "literal");
  let typeName;
  switch (literal) {
    case void 0:
      typeName = "undefined";
      break;
    case null:
      typeName = "null";
      break;
    default:
      typeName = JSON.stringify(literal);
      break;
  }
  const typeInfoGen = (t2) => new LiteralTypeInfo(t2, literal);
  const thisTc = new TypeChecker(TypeCheckerBaseType.Primitive, (value, path, typeCheckedValue) => value === literal ? null : new TypeCheckError(path, typeName, value, typeCheckedValue), () => typeName, typeInfoGen, (value) => value === literal ? thisTc : null, identityFn, identityFn);
  return thisTc;
}
class LiteralTypeInfo extends TypeInfo {
  constructor(thisType, literal) {
    super(thisType);
    __publicField(this, "literal");
    this.literal = literal;
  }
}
const typesUndefined = typesLiteral(void 0);
standardTypeResolvers$1.push((v2) => v2 === void 0 ? typesUndefined : void 0);
const typesNull = typesLiteral(null);
standardTypeResolvers$1.push((v2) => v2 === null ? typesNull : void 0);
const typesBoolean = new TypeChecker(TypeCheckerBaseType.Primitive, (value, path, typeCheckedValue) => typeof value === "boolean" ? null : new TypeCheckError(path, "boolean", value, typeCheckedValue), () => "boolean", (t2) => new BooleanTypeInfo(t2), (value) => typeof value === "boolean" ? typesBoolean : null, identityFn, identityFn);
standardTypeResolvers$1.push((v2) => v2 === Boolean ? typesBoolean : void 0);
class BooleanTypeInfo extends TypeInfo {
}
const typesNumber = new TypeChecker(TypeCheckerBaseType.Primitive, (value, path, typeCheckedValue) => typeof value === "number" ? null : new TypeCheckError(path, "number", value, typeCheckedValue), () => "number", (t2) => new NumberTypeInfo(t2), (value) => typeof value === "number" ? typesNumber : null, identityFn, identityFn);
standardTypeResolvers$1.push((v2) => v2 === Number ? typesNumber : void 0);
class NumberTypeInfo extends TypeInfo {
}
const typesString = new TypeChecker(TypeCheckerBaseType.Primitive, (value, path, typeCheckedValue) => typeof value === "string" ? null : new TypeCheckError(path, "string", value, typeCheckedValue), () => "string", (t2) => new StringTypeInfo(t2), (value) => typeof value === "string" ? typesString : null, identityFn, identityFn);
standardTypeResolvers$1.push((v2) => v2 === String ? typesString : void 0);
class StringTypeInfo extends TypeInfo {
}
function registerPrimitiveStandardTypeResolvers() {
  standardTypeResolvers$1.forEach((str) => {
    registerStandardTypeResolver(str);
  });
}
let defaultStandardTypeResolversRegistered = false;
function registerDefaultStandardTypeResolvers() {
  if (defaultStandardTypeResolversRegistered) {
    return;
  }
  defaultStandardTypeResolversRegistered = true;
  registerModelStandardTypeResolver();
  registerPrimitiveStandardTypeResolvers();
}
const standardTypeResolvers = [];
function registerStandardTypeResolver(resolverFn) {
  standardTypeResolvers.push(resolverFn);
}
function findStandardType(value) {
  registerDefaultStandardTypeResolvers();
  for (const resolverFn of standardTypeResolvers) {
    const tc2 = resolverFn(value);
    if (tc2)
      return tc2;
  }
  return void 0;
}
function resolveTypeChecker(v2) {
  let next = v2;
  while (true) {
    if (next instanceof TypeChecker) {
      return next;
    } else if (isLateTypeChecker(next)) {
      next = next();
    } else {
      const tc2 = findStandardType(v2);
      if (tc2) {
        return resolveTypeChecker(tc2);
      }
      throw failure("type checker could not be resolved");
    }
  }
}
function resolveStandardTypeNoThrow(v2) {
  if (v2 instanceof TypeChecker || isLateTypeChecker(v2)) {
    return v2;
  } else {
    const tc2 = findStandardType(v2);
    if (tc2) {
      return tc2;
    }
    return void 0;
  }
}
function resolveStandardType(v2) {
  const tc2 = resolveStandardTypeNoThrow(v2);
  if (tc2) {
    return tc2;
  }
  throw failure("standard type could not be resolved");
}
const snapshots = /* @__PURE__ */ new WeakMap();
const frozenState = /* @__PURE__ */ new WeakMap();
function getInternalSnapshot(value) {
  return snapshots.get(value);
}
function getInternalSnapshotParent(sn, parentPath) {
  if (!parentPath || !sn) {
    return void 0;
  }
  const parentSn = getInternalSnapshot(parentPath.parent);
  if (!parentSn) {
    return void 0;
  }
  return {
    parentSnapshot: parentSn,
    parentPath
  };
}
const unsetInternalSnapshot = action("unsetInternalSnapshot", (value) => {
  const oldSn = getInternalSnapshot(value);
  if (oldSn) {
    snapshots.delete(value);
    oldSn.atom.reportChanged();
  }
});
const setNewInternalSnapshot = action("setNewInternalSnapshot", (value, untransformed, transformFn, markAsFrozen = false) => {
  const sn = {
    untransformed,
    transformFn,
    transformed: transformFn ? transformFn(untransformed) : untransformed,
    atom: createAtom("snapshot")
  };
  frozenState.set(sn.untransformed, markAsFrozen);
  if (sn.transformed !== void 0) {
    frozenState.set(sn.transformed, markAsFrozen);
  }
  snapshots.set(value, sn);
  sn.atom.reportChanged();
});
const updateInternalSnapshot = action("updateInternalSnapshot", (value, mutate) => {
  const sn = getInternalSnapshot(value);
  let untransformed = sn.untransformed;
  const snFrozen = frozenState.get(untransformed);
  if (snFrozen) {
    if (Array.isArray(untransformed)) {
      untransformed = untransformed.slice();
    } else {
      untransformed = Object.assign({}, untransformed);
    }
  } else {
    invalidateCachedToSnapshotProcessorResult(untransformed);
  }
  mutate(untransformed);
  sn.untransformed = untransformed;
  sn.transformed = sn.transformFn ? sn.transformFn(untransformed) : untransformed;
  frozenState.set(sn.untransformed, false);
  if (sn.transformed !== void 0) {
    frozenState.set(sn.transformed, false);
  }
  sn.atom.reportChanged();
  const parent = getInternalSnapshotParent(sn, fastGetParentPath(value));
  if (parent) {
    const { parentSnapshot, parentPath } = parent;
    if (parentSnapshot) {
      const path = parentPath.path;
      updateInternalSnapshot(parentPath.parent, (objOrArray) => {
        objOrArray[path] = sn.transformed;
      });
    }
  }
});
function reportInternalSnapshotObserved(sn) {
  sn.atom.reportObserved();
}
function freezeInternalSnapshot(data) {
  if (isPrimitive$2(data)) {
    return data;
  }
  const isFrozen = frozenState.get(data);
  if (isFrozen === void 0 || isFrozen === true) {
    return data;
  }
  if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      freezeInternalSnapshot(data[i2]);
    }
  } else {
    const keys2 = Object.keys(data);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      freezeInternalSnapshot(data[keys2[i2]]);
    }
  }
  frozenState.set(data, true);
  return data;
}
function getSnapshot(arg1, arg2) {
  let toSnapshotProcessor = identityFn;
  let nodeOrPrimitive;
  if (arguments.length >= 2) {
    toSnapshotProcessor = resolveTypeChecker(arg1).toSnapshotProcessor;
    nodeOrPrimitive = arg2;
  } else {
    nodeOrPrimitive = arg1;
  }
  if (isPrimitive$2(nodeOrPrimitive)) {
    return toSnapshotProcessor(nodeOrPrimitive);
  }
  assertTweakedObject(nodeOrPrimitive, "nodeOrPrimitive");
  const snapshot = getInternalSnapshot(nodeOrPrimitive);
  if (!snapshot) {
    throw failure("getSnapshot is not supported for this kind of object");
  }
  freezeInternalSnapshot(snapshot.transformed);
  reportInternalSnapshotObserved(snapshot);
  return toSnapshotProcessor(snapshot.transformed);
}
function typeCheck(type, value) {
  const typeChecker = resolveTypeChecker(type);
  if (typeChecker.unchecked) {
    return null;
  } else {
    return typeChecker.check(value, [], value);
  }
}
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nanoid = (size = 21) => {
  let id2 = "";
  let i2 = size;
  while (i2--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var ModelAutoTypeCheckingMode;
(function(ModelAutoTypeCheckingMode2) {
  ModelAutoTypeCheckingMode2["DevModeOnly"] = "devModeOnly";
  ModelAutoTypeCheckingMode2["AlwaysOn"] = "alwaysOn";
  ModelAutoTypeCheckingMode2["AlwaysOff"] = "alwaysOff";
})(ModelAutoTypeCheckingMode || (ModelAutoTypeCheckingMode = {}));
let localId = 0;
const localBaseId = nanoid();
function defaultModelIdGenerator() {
  const id2 = localId.toString(36) + "-" + localBaseId;
  localId++;
  return id2;
}
let globalConfig = {
  modelAutoTypeChecking: ModelAutoTypeCheckingMode.DevModeOnly,
  modelIdGenerator: defaultModelIdGenerator,
  allowUndefinedArrayElements: false,
  showDuplicateModelNameWarnings: true
};
function setGlobalConfig(config2) {
  globalConfig = Object.freeze({
    ...globalConfig,
    ...config2
  });
}
function getGlobalConfig() {
  return globalConfig;
}
function isModelAutoTypeCheckingEnabled() {
  switch (getGlobalConfig().modelAutoTypeChecking) {
    case ModelAutoTypeCheckingMode.DevModeOnly:
      return inDevMode;
    case ModelAutoTypeCheckingMode.AlwaysOff:
      return false;
    case ModelAutoTypeCheckingMode.AlwaysOn:
      return true;
    default:
      throw failure(`invalid 'modelAutoTypeChecking' config value - ${globalConfig.modelAutoTypeChecking}`);
  }
}
const modelInitializersSymbol = Symbol("modelInitializers");
function getModelClassInitializers(modelClass2) {
  return modelClass2[modelInitializersSymbol];
}
function applyModelInitializers(modelClass2, modelObj) {
  const initializers = getModelClassInitializers(modelClass2);
  if (initializers) {
    const len = initializers.length;
    for (let i2 = 0; i2 < len; i2++) {
      initializers[i2](modelObj);
    }
  }
}
function canWrite() {
  return !!getCurrentActionContext();
}
function assertCanWrite() {
  if (!canWrite()) {
    throw failure("data changes must be performed inside model actions");
  }
}
const pendingActions = [];
function isActionRunning() {
  return !!getCurrentActionContext();
}
function enqueuePendingAction(action2) {
  if (isActionRunning()) {
    pendingActions.push(action2);
  } else {
    action2();
  }
}
let pendingActionsRunning = false;
function tryRunPendingActions() {
  if (isActionRunning() || pendingActionsRunning) {
    return;
  }
  pendingActionsRunning = true;
  try {
    while (pendingActions.length > 0) {
      const nextAction = pendingActions.shift();
      nextAction();
    }
  } finally {
    pendingActionsRunning = false;
  }
}
var HookAction;
(function(HookAction2) {
  HookAction2["OnInit"] = "$$onInit";
  HookAction2["OnLazyInit"] = "$$onLazyInit";
  HookAction2["OnAttachedToRootStore"] = "$$onAttachedToRootStore";
  HookAction2["OnAttachedToRootStoreDisposer"] = "$$onAttachedToRootStoreDisposer";
})(HookAction || (HookAction = {}));
const hookActionValues = new Set(Object.values(HookAction));
function isHookAction(actionName) {
  return hookActionValues.has(actionName);
}
const objectChildren = /* @__PURE__ */ new WeakMap();
function getObjectChildrenObject(node) {
  let obj = objectChildren.get(node);
  if (!obj) {
    obj = {
      shallow: /* @__PURE__ */ new Set(),
      shallowAtom: createAtom("shallowChildrenAtom"),
      deep: /* @__PURE__ */ new Set(),
      deepDirty: true,
      deepAtom: createAtom("deepChildrenAtom"),
      extensionsData: initExtensionsData()
    };
    objectChildren.set(node, obj);
  }
  return obj;
}
function getObjectChildren(node) {
  const obj = getObjectChildrenObject(node);
  obj.shallowAtom.reportObserved();
  return obj.shallow;
}
function getDeepObjectChildren(node) {
  const obj = getObjectChildrenObject(node);
  if (obj.deepDirty) {
    updateDeepObjectChildren(node);
  }
  obj.deepAtom.reportObserved();
  return obj;
}
function addNodeToDeepLists(node, data) {
  data.deep.add(node);
  extensions.forEach((extension, dataSymbol) => {
    extension.addNode(node, data.extensionsData.get(dataSymbol));
  });
}
const updateDeepObjectChildren = action((node) => {
  const obj = getObjectChildrenObject(node);
  if (!obj.deepDirty) {
    return obj;
  }
  obj.deep = /* @__PURE__ */ new Set();
  obj.extensionsData = initExtensionsData();
  const childrenIterator = obj.shallow.values();
  let childrenIteratorResult = childrenIterator.next();
  while (!childrenIteratorResult.done) {
    addNodeToDeepLists(childrenIteratorResult.value, obj);
    const childDeepChildren = updateDeepObjectChildren(childrenIteratorResult.value).deep;
    const childDeepChildrenIterator = childDeepChildren.values();
    let childDeepChildrenIteratorResult = childDeepChildrenIterator.next();
    while (!childDeepChildrenIteratorResult.done) {
      addNodeToDeepLists(childDeepChildrenIteratorResult.value, obj);
      childDeepChildrenIteratorResult = childDeepChildrenIterator.next();
    }
    childrenIteratorResult = childrenIterator.next();
  }
  obj.deepDirty = false;
  obj.deepAtom.reportChanged();
  return obj;
});
const addObjectChild = action((node, child) => {
  const obj = getObjectChildrenObject(node);
  obj.shallow.add(child);
  obj.shallowAtom.reportChanged();
  invalidateDeepChildren(node, obj);
});
const removeObjectChild = action((node, child) => {
  const obj = getObjectChildrenObject(node);
  obj.shallow.delete(child);
  obj.shallowAtom.reportChanged();
  invalidateDeepChildren(node, obj);
});
function invalidateDeepChildren(node, obj) {
  let currentNode = node;
  let currentObj = obj;
  while (currentNode) {
    currentObj.deepDirty = true;
    currentObj.deepAtom.reportChanged();
    currentNode = fastGetParent(currentNode);
    if (currentNode) {
      currentObj = getObjectChildrenObject(currentNode);
    }
  }
}
const extensions = /* @__PURE__ */ new Map();
function registerDeepObjectChildrenExtension(extension) {
  const dataSymbol = {};
  extensions.set(dataSymbol, extension);
  return (data) => {
    return data.extensionsData.get(dataSymbol);
  };
}
function initExtensionsData() {
  const extensionsData = /* @__PURE__ */ new WeakMap();
  extensions.forEach((extension, dataSymbol) => {
    extensionsData.set(dataSymbol, extension.initData());
  });
  return extensionsData;
}
var WalkTreeMode;
(function(WalkTreeMode2) {
  WalkTreeMode2["ParentFirst"] = "parentFirst";
  WalkTreeMode2["ChildrenFirst"] = "childrenFirst";
})(WalkTreeMode || (WalkTreeMode = {}));
function walkTree(root, visit, mode) {
  assertTweakedObject(root, "root");
  if (mode === WalkTreeMode.ParentFirst) {
    return walkTreeParentFirst(root, visit);
  } else {
    return walkTreeChildrenFirst(root, visit);
  }
}
function walkTreeParentFirst(root, visit) {
  const stack = [root];
  while (stack.length > 0) {
    const node = stack.pop();
    const ret = visit(node);
    if (ret !== void 0) {
      return ret;
    }
    const children = getObjectChildren(node);
    stack.length += children.size;
    let i2 = stack.length - 1;
    const childrenIter = children.values();
    let ch2 = childrenIter.next();
    while (!ch2.done) {
      stack[i2--] = ch2.value;
      ch2 = childrenIter.next();
    }
  }
  return void 0;
}
function walkTreeChildrenFirst(root, visit) {
  const childrenIter = getObjectChildren(root).values();
  let ch2 = childrenIter.next();
  while (!ch2.done) {
    const ret2 = walkTreeChildrenFirst(ch2.value, visit);
    if (ret2 !== void 0) {
      return ret2;
    }
    ch2 = childrenIter.next();
  }
  const ret = visit(root);
  if (ret !== void 0) {
    return ret;
  }
  return void 0;
}
function getComputedTreeResult(computedFns, visit, tree) {
  let cmpted = computedFns.get(tree);
  if (!cmpted) {
    cmpted = computed(() => {
      return walkTreeAggregate(tree, visit, (ch2) => getComputedTreeResult(computedFns, visit, ch2));
    });
    computedFns.set(tree, cmpted);
  }
  return cmpted.get();
}
function computedWalkTreeAggregate(visit) {
  const computedFns = /* @__PURE__ */ new WeakMap();
  return {
    walk: (n2) => getComputedTreeResult(computedFns, visit, n2)
  };
}
function walkTreeAggregate(target, visit, recurse) {
  let map2;
  const rootVal = visit(target);
  const childrenMap = getObjectChildren(target);
  const childrenIter = childrenMap.values();
  let ch2 = childrenIter.next();
  if (rootVal === void 0 && childrenMap.size === 1) {
    return recurse(ch2.value);
  }
  while (!ch2.done) {
    const childMap = recurse(ch2.value);
    if (childMap) {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
      }
      const mapIter = childMap.keys();
      let mapCur = mapIter.next();
      while (!mapCur.done) {
        const key = mapCur.value;
        const val = childMap.get(key);
        map2.set(key, val);
        mapCur = mapIter.next();
      }
    }
    ch2 = childrenIter.next();
  }
  if (rootVal !== void 0) {
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
    }
    map2.set(rootVal, target);
  }
  return map2;
}
const onAttachedDisposers = /* @__PURE__ */ new WeakMap();
const attachedToRootStore = /* @__PURE__ */ new WeakSet();
const attachToRootStore = action("attachToRootStore", (rootStore, child) => {
  const childrenToCall = [];
  walkTree(child, (ch2) => {
    if (attachedToRootStore.has(ch2)) {
      return;
    }
    attachedToRootStore.add(ch2);
    if (ch2 instanceof BaseModel && ch2.onAttachedToRootStore) {
      wrapModelMethodInActionIfNeeded(ch2, "onAttachedToRootStore", HookAction.OnAttachedToRootStore);
      childrenToCall.push(ch2);
    }
  }, WalkTreeMode.ParentFirst);
  const childrenToCallLen = childrenToCall.length;
  for (let i2 = 0; i2 < childrenToCallLen; i2++) {
    const ch2 = childrenToCall[i2];
    const disposer = ch2.onAttachedToRootStore(rootStore);
    if (disposer) {
      onAttachedDisposers.set(ch2, disposer);
    }
  }
});
const detachFromRootStore = action("detachFromRootStore", (child) => {
  const disposersToCall = [];
  walkTree(child, (ch2) => {
    if (!attachedToRootStore.delete(ch2)) {
      return;
    }
    const disposer = onAttachedDisposers.get(ch2);
    if (disposer) {
      const disposerAction = wrapInAction({
        nameOrNameFn: HookAction.OnAttachedToRootStoreDisposer,
        fn: disposer,
        actionType: ActionContextActionType.Sync
      }).bind(ch2);
      onAttachedDisposers.delete(ch2);
      disposersToCall.push(disposerAction);
    }
  }, WalkTreeMode.ChildrenFirst);
  const disposersToCallLen = disposersToCall.length;
  for (let i2 = 0; i2 < disposersToCallLen; i2++) {
    disposersToCall[i2]();
  }
});
const rootStoreRegistry = /* @__PURE__ */ new WeakMap();
const getOrCreateRootStoreEntry = (node) => getOrCreate(rootStoreRegistry, node, () => ({
  atom: createAtom("rootStore"),
  is: false
}));
const registerRootStore = action("registerRootStore", (node) => {
  assertTweakedObject(node, "node");
  const entry = getOrCreateRootStoreEntry(node);
  if (entry.is) {
    throw failure("object already registered as root store");
  }
  if (!isRoot(node)) {
    throw failure("a root store must not have a parent");
  }
  entry.is = true;
  attachToRootStore(node, node);
  entry.atom.reportChanged();
  return node;
});
action("unregisterRootStore", (node) => {
  if (!isRootStore(node)) {
    throw failure("not a root store");
  }
  const entry = getOrCreateRootStoreEntry(node);
  entry.is = false;
  detachFromRootStore(node);
  entry.atom.reportChanged();
});
function isRootStore(node) {
  assertTweakedObject(node, "node");
  return fastIsRootStore(node);
}
function fastIsRootStore(node) {
  const entry = getOrCreateRootStoreEntry(node);
  entry.atom.reportObserved();
  return entry.is;
}
function getRootStore(node) {
  assertTweakedObject(node, "node");
  return fastGetRootStore(node);
}
function fastGetRootStore(node) {
  const root = fastGetRoot(node);
  return fastIsRootStore(root) ? root : void 0;
}
const emptyPatchArray = [];
class InternalPatchRecorder {
  constructor() {
    __publicField(this, "patches", emptyPatchArray);
    __publicField(this, "invPatches", emptyPatchArray);
  }
  reset() {
    this.patches = emptyPatchArray;
    this.invPatches = emptyPatchArray;
  }
  record(patches, invPatches) {
    this.patches = patches;
    this.invPatches = invPatches;
  }
  emit(obj) {
    emitPatch(obj, this.patches, this.invPatches, true);
    this.reset();
  }
}
const patchListeners = /* @__PURE__ */ new WeakMap();
const globalPatchListeners = [];
function emitPatch(obj, patches, inversePatches, emitGlobally) {
  if (patches.length <= 0 && inversePatches.length <= 0) {
    return;
  }
  if (emitGlobally) {
    for (let i2 = 0; i2 < globalPatchListeners.length; i2++) {
      const listener = globalPatchListeners[i2];
      listener(obj, patches, inversePatches);
    }
  }
  const listenersForObject = patchListeners.get(obj);
  if (listenersForObject) {
    for (let i2 = 0; i2 < listenersForObject.length; i2++) {
      const listener = listenersForObject[i2];
      listener(patches, inversePatches);
    }
  }
  const parentPath = fastGetParentPath(obj);
  if (parentPath) {
    const childPath = parentPath.path;
    const newPatches = patches.map((p2) => addPathToPatch(p2, childPath));
    const newInversePatches = inversePatches.map((p2) => addPathToPatch(p2, childPath));
    emitPatch(parentPath.parent, newPatches, newInversePatches, false);
  }
}
function addPathToPatch(patch, path) {
  return {
    ...patch,
    path: [path, ...patch.path]
  };
}
function setIfDifferent(target, key, value) {
  const oldValue = target[key];
  if (oldValue !== value || value === void 0 && !(key in target)) {
    set$1(target, key, value);
  }
}
function getDataModelMetadata(modelClassOrInstance) {
  if (isDataModel(modelClassOrInstance)) {
    return modelClassOrInstance.constructor[modelMetadataSymbol];
  } else if (isDataModelClass(modelClassOrInstance)) {
    return modelClassOrInstance[modelMetadataSymbol];
  } else {
    throw failure(`modelClassOrInstance must be a model class or instance`);
  }
}
const cachedDataModelTypeChecker = /* @__PURE__ */ new WeakMap();
function typesDataModelData(modelClass2) {
  if (!isDataModelClass(modelClass2) && typeof modelClass2 === "function") {
    const modelClassFn = modelClass2;
    const typeInfoGen = (t2) => new DataModelDataTypeInfo(t2, modelClassFn());
    return lateTypeChecker(() => typesDataModelData(modelClassFn()), typeInfoGen);
  } else {
    const modelClazz = modelClass2;
    const cachedTypeChecker = cachedDataModelTypeChecker.get(modelClazz);
    if (cachedTypeChecker) {
      return cachedTypeChecker;
    }
    const typeInfoGen = (t2) => new DataModelDataTypeInfo(t2, modelClazz);
    const tc2 = lateTypeChecker(() => {
      const modelInfo = modelInfoByClass.get(modelClazz);
      const typeName = `DataModelData(${modelInfo.name})`;
      const dataTypeChecker = getDataModelMetadata(modelClazz).dataType;
      if (!dataTypeChecker) {
        throw failure(`type checking cannot be performed over data model data of type '${modelInfo.name}' since that model type has no data type declared, consider adding a data type or using types.unchecked() instead`);
      }
      const resolvedDataTypeChecker = resolveTypeChecker(dataTypeChecker);
      const thisTc = new TypeChecker(TypeCheckerBaseType.Object, (value, path, typeCheckedValue) => {
        return resolvedDataTypeChecker.check(value, path, typeCheckedValue);
      }, () => typeName, typeInfoGen, (value) => {
        return resolvedDataTypeChecker.snapshotType(value) ? thisTc : null;
      }, (sn) => {
        return resolvedDataTypeChecker.fromSnapshotProcessor(sn);
      }, (sn) => {
        return resolvedDataTypeChecker.toSnapshotProcessor(sn);
      });
      return thisTc;
    }, typeInfoGen);
    cachedDataModelTypeChecker.set(modelClazz, tc2);
    return tc2;
  }
}
class DataModelDataTypeInfo extends TypeInfo {
  constructor(thisType, modelClass2) {
    super(thisType);
    __publicField(this, "modelClass");
    __publicField(this, "_props", lazy(() => {
      const objSchema = getInternalModelClassPropsInfo(this.modelClass);
      const propTypes = {};
      Object.keys(objSchema).forEach((propName) => {
        const propData = objSchema[propName];
        const type = propData._typeChecker;
        let typeInfo;
        if (type) {
          typeInfo = getTypeInfo(type);
        }
        let hasDefault = false;
        let defaultValue;
        if (propData._defaultFn !== noDefaultValue) {
          defaultValue = propData._defaultFn;
          hasDefault = true;
        } else if (propData._defaultValue !== noDefaultValue) {
          defaultValue = propData._defaultValue;
          hasDefault = true;
        }
        propTypes[propName] = {
          type,
          typeInfo,
          hasDefault,
          default: defaultValue
        };
      });
      return propTypes;
    }));
    this.modelClass = modelClass2;
  }
  get props() {
    return this._props();
  }
  get modelType() {
    const modelInfo = modelInfoByClass.get(this.modelClass);
    return modelInfo.name;
  }
}
const internalNewDataModel = action("newModel", (origModelObj, tweakedData, options) => {
  const { modelClass: _modelClass } = options;
  const modelClass2 = _modelClass;
  const modelObj = origModelObj;
  const modelInfo = modelInfoByClass.get(modelClass2);
  if (!modelInfo) {
    throw failure(`no model info for class ${modelClass2.name} could be found - did you forget to add the @model decorator?`);
  }
  modelObj.$ = tweakedData;
  applyModelInitializers(modelClass2, modelObj);
  if (isModelAutoTypeCheckingEnabled() && getDataModelMetadata(modelClass2).dataType) {
    const err = modelObj.typeCheck();
    if (err) {
      err.throw();
    }
  }
  return modelObj;
});
const dataModelInstanceCache = /* @__PURE__ */ new WeakMap();
class BaseDataModel {
  /**
   * Creates an instance of a data model.
   */
  constructor(data) {
    __publicField(this, _a);
    __publicField(this, "$");
    if (!isObject$1(data)) {
      throw failure("data models can only work over data objects");
    }
    const { modelClass: _modelClass } = arguments[1];
    const modelClass2 = _modelClass;
    let tweakedData;
    if (isTreeNode(data)) {
      tweakedData = data;
    } else {
      const modelInfo = modelInfoByClass.get(modelClass2);
      if (!modelInfo) {
        throw failure(`no model info for class ${modelClass2.name} could be found - did you forget to add the @model decorator?`);
      }
      const modelProps = getInternalModelClassPropsInfo(modelClass2);
      const initialData = Object.assign({}, data);
      const modelPropsKeys = Object.keys(modelProps);
      for (let i2 = 0; i2 < modelPropsKeys.length; i2++) {
        const k2 = modelPropsKeys[i2];
        const propData = modelProps[k2];
        let newValue = initialData[k2];
        let changed = false;
        if (propData._transform) {
          changed = true;
          newValue = propData._transform.untransform(newValue, this, k2);
        }
        if (newValue == null) {
          if (propData._defaultFn !== noDefaultValue) {
            changed = true;
            newValue = propData._defaultFn();
          } else if (propData._defaultValue !== noDefaultValue) {
            changed = true;
            newValue = propData._defaultValue;
          }
        }
        if (changed) {
          initialData[k2] = newValue;
        }
      }
      tweakedData = toTreeNode(initialData);
    }
    const instancesForModelClass = getOrCreate(dataModelInstanceCache, modelClass2, () => /* @__PURE__ */ new WeakMap());
    const instance = instancesForModelClass.get(tweakedData);
    if (instance) {
      return instance;
    }
    instancesForModelClass.set(tweakedData, this);
    Object.setPrototypeOf(this, modelClass2.prototype);
    const self2 = this;
    delete self2[propsTypeSymbol];
    internalNewDataModel(this, tweakedData, {
      modelClass: modelClass2
    });
  }
  /**
   * Performs a type check over the model instance.
   * For this to work a data type has to be declared as part of the model properties.
   *
   * @returns A `TypeCheckError` or `null` if there is no error.
   */
  typeCheck() {
    const type = typesDataModelData(this.constructor);
    return typeCheck(type, this.$);
  }
  toString(options) {
    const finalOptions = {
      withData: true,
      ...options
    };
    const modelInfo = modelInfoByClass.get(this.constructor);
    const firstPart = `${this.constructor.name}#${modelInfo.name}`;
    return finalOptions.withData ? `[${firstPart} ${JSON.stringify(getSnapshot(this))}]` : `[${firstPart}]`;
  }
}
_a = propsTypeSymbol;
const baseDataModelPropNames = /* @__PURE__ */ new Set(["onLazyInit", "$", "typeCheck"]);
function isDataModel(model2) {
  return model2 instanceof BaseDataModel;
}
function isDataModelClass(modelClass2) {
  if (typeof modelClass2 !== "function") {
    return false;
  }
  if (modelClass2 !== BaseDataModel && !(modelClass2.prototype instanceof BaseDataModel)) {
    return false;
  }
  return true;
}
var FrozenCheckMode;
(function(FrozenCheckMode2) {
  FrozenCheckMode2["DevModeOnly"] = "devModeOnly";
  FrozenCheckMode2["On"] = "on";
  FrozenCheckMode2["Off"] = "off";
})(FrozenCheckMode || (FrozenCheckMode = {}));
const frozenKey = "$frozen";
class Frozen {
  /**
   * Creates an instance of Frozen.
   * Do not use directly, use `frozen` instead.
   *
   * @param dataToFreeze
   * @param checkMode
   */
  constructor(dataToFreeze, checkMode = FrozenCheckMode.DevModeOnly) {
    __publicField(this, "data");
    const check = checkMode === FrozenCheckMode.On || inDevMode;
    if (check) {
      checkDataIsSerializableAndFreeze(dataToFreeze);
    }
    this.data = dataToFreeze;
    if (check) {
      Object.freeze(this.data);
    }
    tweak(this, void 0);
  }
}
function frozen(data, checkMode = FrozenCheckMode.DevModeOnly) {
  return new Frozen(data, checkMode);
}
function checkDataIsSerializableAndFreeze(data) {
  if (isPrimitive$2(data)) {
    return;
  }
  if (Array.isArray(data)) {
    const arrLen = data.length;
    for (let i2 = 0; i2 < arrLen; i2++) {
      const v2 = data[i2];
      if (v2 === void 0 && !getGlobalConfig().allowUndefinedArrayElements) {
        throw failure("undefined is not supported inside arrays since it is not serializable in JSON, consider using null instead");
      }
      checkDataIsSerializableAndFreeze(v2);
    }
    Object.freeze(data);
    return;
  }
  if (isPlainObject$3(data)) {
    const dataKeys = Object.keys(data);
    const dataKeysLen = dataKeys.length;
    for (let i2 = 0; i2 < dataKeysLen; i2++) {
      const k2 = dataKeys[i2];
      const v2 = data[k2];
      checkDataIsSerializableAndFreeze(k2);
      checkDataIsSerializableAndFreeze(v2);
    }
    Object.freeze(data);
    return;
  }
  throw failure(`frozen data must be plainly serializable to JSON, but ${data} is not`);
}
function isFrozenSnapshot(snapshot) {
  return isPlainObject$3(snapshot) && frozenKey in snapshot;
}
var TweakerPriority;
(function(TweakerPriority2) {
  TweakerPriority2[TweakerPriority2["Model"] = 0] = "Model";
  TweakerPriority2[TweakerPriority2["Array"] = 1] = "Array";
  TweakerPriority2[TweakerPriority2["PlainObject"] = 2] = "PlainObject";
  TweakerPriority2[TweakerPriority2["Frozen"] = 3] = "Frozen";
})(TweakerPriority || (TweakerPriority = {}));
function tweakFrozen(frozenObj, parentPath) {
  tweakedObjects.set(frozenObj, void 0);
  setParent({
    value: frozenObj,
    parentPath,
    indexChangeAllowed: false,
    isDataObject: false,
    // a frozen is not a value-type
    cloneIfApplicable: false
  });
  setNewInternalSnapshot(frozenObj, { [frozenKey]: true, data: frozenObj.data }, void 0, true);
  return frozenObj;
}
function registerFrozenTweaker() {
  registerTweaker(TweakerPriority.Frozen, (value, parentPath) => {
    if (value instanceof Frozen) {
      return tweakFrozen(value, parentPath);
    }
    return void 0;
  });
}
function findParent(child, predicate, maxDepth = 0) {
  const foundParentPath = findParentPath(child, predicate, maxDepth);
  return foundParentPath ? foundParentPath.parent : void 0;
}
function findParentPath(child, predicate, maxDepth = 0) {
  assertTweakedObject(child, "child");
  const path = [];
  let current = child;
  let depth = 0;
  let parentPath;
  while (parentPath = fastGetParentPath(current)) {
    path.unshift(parentPath.path);
    current = parentPath.parent;
    if (predicate(current)) {
      return {
        parent: current,
        path
      };
    }
    depth++;
    if (maxDepth > 0 && depth === maxDepth) {
      break;
    }
  }
  return void 0;
}
let typeCheckingAllowed = true;
function withoutTypeChecking(fn) {
  let oldTypeCheckingAllowed = typeCheckingAllowed;
  typeCheckingAllowed = false;
  try {
    fn();
  } finally {
    typeCheckingAllowed = oldTypeCheckingAllowed;
  }
}
function isTypeCheckingAllowed() {
  return typeCheckingAllowed;
}
var SnapshotterAndReconcilerPriority;
(function(SnapshotterAndReconcilerPriority2) {
  SnapshotterAndReconcilerPriority2[SnapshotterAndReconcilerPriority2["Array"] = 0] = "Array";
  SnapshotterAndReconcilerPriority2[SnapshotterAndReconcilerPriority2["Frozen"] = 1] = "Frozen";
  SnapshotterAndReconcilerPriority2[SnapshotterAndReconcilerPriority2["Model"] = 2] = "Model";
  SnapshotterAndReconcilerPriority2[SnapshotterAndReconcilerPriority2["PlainObject"] = 3] = "PlainObject";
})(SnapshotterAndReconcilerPriority || (SnapshotterAndReconcilerPriority = {}));
function reconcileArraySnapshot(value, sn, modelPool) {
  if (!isArray$2(value)) {
    return fromSnapshot(sn);
  }
  const snapshotBeforeChanges = getSnapshot(value);
  withoutTypeChecking(() => {
    if (value.length > sn.length) {
      value.splice(sn.length, value.length - sn.length);
    }
    for (let i2 = 0; i2 < value.length; i2++) {
      const oldValue = value[i2];
      const newValue = reconcileSnapshot(oldValue, sn[i2], modelPool, value);
      detachIfNeeded(newValue, oldValue, modelPool);
      setIfDifferent(value, i2, newValue);
    }
    for (let i2 = value.length; i2 < sn.length; i2++) {
      value.push(reconcileSnapshot(void 0, sn[i2], modelPool, value));
    }
  });
  runTypeCheckingAfterChange(value, void 0, snapshotBeforeChanges);
  return value;
}
function registerArraySnapshotReconciler() {
  registerReconciler(SnapshotterAndReconcilerPriority.Array, (value, sn, modelPool) => {
    if (isArray$2(sn)) {
      return reconcileArraySnapshot(value, sn, modelPool);
    }
    return void 0;
  });
}
function reconcileFrozenSnapshot(value, sn) {
  if (value instanceof Frozen && value.data === sn.data) {
    return value;
  }
  return frozen(sn.data);
}
function registerFrozenSnapshotReconciler() {
  registerReconciler(SnapshotterAndReconcilerPriority.Frozen, (value, sn) => {
    if (isFrozenSnapshot(sn)) {
      return reconcileFrozenSnapshot(value, sn);
    }
    return void 0;
  });
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var es6 = function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length, i2, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2 instanceof Map && b2 instanceof Map) {
      if (a2.size !== b2.size)
        return false;
      for (i2 of a2.entries())
        if (!b2.has(i2[0]))
          return false;
      for (i2 of a2.entries())
        if (!equal(i2[1], b2.get(i2[0])))
          return false;
      return true;
    }
    if (a2 instanceof Set && b2 instanceof Set) {
      if (a2.size !== b2.size)
        return false;
      for (i2 of a2.entries())
        if (!b2.has(i2[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (a2[i2] !== b2[i2])
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!equal(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
const fastDeepEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(es6);
function byModelTypeAndIdKey(modelType, modelId) {
  return modelType + " " + modelId;
}
class ModelPool {
  constructor(root) {
    __publicField(this, "pool");
    var _a2;
    root = (_a2 = dataObjectParent.get(root)) != null ? _a2 : root;
    this.pool = getDeepChildrenModels(getDeepObjectChildren(root));
  }
  findModelByTypeAndId(modelType, modelId) {
    return modelId ? this.pool.get(byModelTypeAndIdKey(modelType, modelId)) : void 0;
  }
  findModelForSnapshot(sn) {
    if (!isModelSnapshot(sn)) {
      return void 0;
    }
    const modelType = sn[modelTypeKey];
    const modelInfo = getModelInfoForName(modelType);
    const modelIdPropertyName = getModelIdPropertyName(modelInfo.class);
    return modelIdPropertyName ? this.findModelByTypeAndId(sn[modelTypeKey], sn[modelIdPropertyName]) : void 0;
  }
}
const getDeepChildrenModels = registerDeepObjectChildrenExtension({
  initData() {
    return /* @__PURE__ */ new Map();
  },
  addNode(node, data) {
    if (isModel(node)) {
      const id2 = node[modelIdKey];
      if (id2) {
        data.set(byModelTypeAndIdKey(node[modelTypeKey], id2), node);
      }
    }
  }
});
function applySnapshot(node, snapshot) {
  assertTweakedObject(node, "node");
  assertIsObject(snapshot, "snapshot");
  wrappedInternalApplySnapshot().call(node, snapshot);
}
function internalApplySnapshot(sn) {
  const obj = this;
  const reconcile = () => {
    const modelPool = new ModelPool(obj);
    reconcileSnapshot(obj, sn, modelPool, void 0);
  };
  if (isArray$2(sn)) {
    if (!isArray$2(obj)) {
      throw failure("if the snapshot is an array the target must be an array too");
    }
    return reconcile();
  }
  if (isFrozenSnapshot(sn)) {
    throw failure("applySnapshot cannot be used over frozen objects");
  }
  if (isPlainObject$3(sn) && sn[modelTypeKey] === void 0 && isModel(obj)) {
    const modelInfo = modelInfoByClass.get(obj.constructor);
    sn = { ...sn, [modelTypeKey]: modelInfo.name };
  }
  if (isModelSnapshot(sn)) {
    const type = sn[modelTypeKey];
    const modelInfo = getModelInfoForName(type);
    if (!modelInfo) {
      throw failure(`model with name "${type}" not found in the registry`);
    }
    if (!isModel(obj)) {
      throw failure(`the target for a model snapshot must be a model instance`);
    }
    if (obj[modelTypeKey] !== type) {
      throw failure(`snapshot model type '${type}' does not match target model type '${obj[modelTypeKey]}'`);
    }
    const modelIdPropertyName = getModelIdPropertyName(modelInfo.class);
    if (modelIdPropertyName) {
      const id2 = sn[modelIdPropertyName];
      if (obj[modelIdKey] !== id2) {
        throw failure(`snapshot model id '${id2}' does not match target model id '${obj[modelIdKey]}'`);
      }
    }
    return reconcile();
  }
  if (isPlainObject$3(sn)) {
    if (!isPlainObject$3(obj) && !isObservableObject(obj)) {
      throw failure("if the snapshot is an object the target must be an object too");
    }
    return reconcile();
  }
  if (isMap$1(sn)) {
    throw failure("a snapshot must not contain maps");
  }
  if (isSet$1(sn)) {
    throw failure("a snapshot must not contain sets");
  }
  throw failure(`unsupported snapshot - ${sn}`);
}
const wrappedInternalApplySnapshot = lazy(() => wrapInAction({
  nameOrNameFn: BuiltInAction.ApplySnapshot,
  fn: internalApplySnapshot,
  actionType: ActionContextActionType.Sync
}));
function deepEquals(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (isTreeNode(a2)) {
    a2 = getSnapshot(a2);
  } else if (isObservable(a2)) {
    a2 = toJS(a2);
  }
  if (isTreeNode(b2)) {
    b2 = getSnapshot(b2);
  } else if (isObservable(b2)) {
    b2 = toJS(b2);
  }
  return fastDeepEqual$1(a2, b2);
}
getMobxVersion() >= 6 ? void 0 : {
  exportMapsAsObjects: false,
  recurseEverything: false
};
function reconcileModelSnapshot(value, sn, modelPool, parent) {
  const type = sn[modelTypeKey];
  const modelInfo = getModelInfoForName(type);
  if (!modelInfo) {
    throw failure(`model with name "${type}" not found in the registry`);
  }
  const modelInPool = modelPool.findModelForSnapshot(sn);
  if (modelInPool) {
    value = modelInPool;
  }
  if (!isModel(value) || value[modelTypeKey] !== type) {
    return fromSnapshot(sn);
  }
  const modelClass2 = modelInfo.class;
  const modelProps = getInternalModelClassPropsInfo(modelClass2);
  const modelIdPropertyName = getModelIdPropertyName(modelClass2);
  if (modelIdPropertyName) {
    const id2 = sn[modelIdPropertyName];
    if (value[modelIdKey] !== id2) {
      return fromSnapshot(sn);
    }
  } else if (isArray$2(parent)) {
    if (!deepEquals(value, sn)) {
      return fromSnapshot(sn);
    }
  }
  const modelObj = value;
  const snapshotBeforeChanges = getSnapshot(modelObj);
  withoutTypeChecking(() => {
    const modelClass22 = modelObj.constructor;
    const processedSn = modelClass22.fromSnapshotProcessor ? modelClass22.fromSnapshotProcessor(sn) : sn;
    const data = modelObj.$;
    const dataKeys = Object.keys(data);
    const dataKeysLen = dataKeys.length;
    for (let i2 = 0; i2 < dataKeysLen; i2++) {
      const k2 = dataKeys[i2];
      if (!(k2 in processedSn)) {
        const modelProp = modelProps[k2];
        const defaultValue = modelProp ? getModelPropDefaultValue(modelProp) : noDefaultValue;
        if (defaultValue === noDefaultValue) {
          remove$1(data, k2);
        } else {
          setIfDifferent(data, k2, defaultValue);
        }
      }
    }
    const processedSnKeys = Object.keys(processedSn);
    const processedSnKeysLen = processedSnKeys.length;
    for (let i2 = 0; i2 < processedSnKeysLen; i2++) {
      const k2 = processedSnKeys[i2];
      if (!isReservedModelKey(k2)) {
        const v2 = processedSn[k2];
        const oldValue = data[k2];
        let newValue = reconcileSnapshot(oldValue, v2, modelPool, modelObj);
        if (newValue == null) {
          const modelProp = modelProps[k2];
          const defaultValue = modelProp ? getModelPropDefaultValue(modelProp) : noDefaultValue;
          if (defaultValue !== noDefaultValue) {
            newValue = defaultValue;
          }
        }
        detachIfNeeded(newValue, oldValue, modelPool);
        setIfDifferent(data, k2, newValue);
      }
    }
  });
  runTypeCheckingAfterChange(modelObj, void 0, snapshotBeforeChanges);
  return modelObj;
}
function registerModelSnapshotReconciler() {
  registerReconciler(SnapshotterAndReconcilerPriority.Model, (value, sn, modelPool, parent) => {
    if (isModelSnapshot(sn)) {
      return reconcileModelSnapshot(value, sn, modelPool, parent);
    }
    return void 0;
  });
}
function reconcilePlainObjectSnapshot(value, sn, modelPool) {
  if (!isPlainObject$3(value) && !isObservableObject(value)) {
    return fromSnapshot(sn);
  }
  const plainObj = value;
  const snapshotBeforeChanges = getSnapshot(plainObj);
  withoutTypeChecking(() => {
    const plainObjKeys = Object.keys(plainObj);
    const plainObjKeysLen = plainObjKeys.length;
    for (let i2 = 0; i2 < plainObjKeysLen; i2++) {
      const k2 = plainObjKeys[i2];
      if (!(k2 in sn)) {
        remove$1(plainObj, k2);
      }
    }
    const snKeys = Object.keys(sn);
    const snKeysLen = snKeys.length;
    for (let i2 = 0; i2 < snKeysLen; i2++) {
      const k2 = snKeys[i2];
      const v2 = sn[k2];
      const oldValue = plainObj[k2];
      const newValue = reconcileSnapshot(oldValue, v2, modelPool, plainObj);
      detachIfNeeded(newValue, oldValue, modelPool);
      setIfDifferent(plainObj, k2, newValue);
    }
  });
  runTypeCheckingAfterChange(plainObj, void 0, snapshotBeforeChanges);
  return plainObj;
}
function registerPlainObjectSnapshotReconciler() {
  registerReconciler(SnapshotterAndReconcilerPriority.PlainObject, (value, sn, modelPool) => {
    if (isPlainObject$3(sn)) {
      return reconcilePlainObjectSnapshot(value, sn, modelPool);
    }
    return void 0;
  });
}
let defaultReconcilersRegistered = false;
function registerDefaultReconcilers() {
  if (defaultReconcilersRegistered) {
    return;
  }
  defaultReconcilersRegistered = true;
  registerArraySnapshotReconciler();
  registerFrozenSnapshotReconciler();
  registerModelSnapshotReconciler();
  registerPlainObjectSnapshotReconciler();
}
const reconcilers = [];
function registerReconciler(priority, reconciler) {
  reconcilers.push({ priority, reconciler });
  reconcilers.sort((a2, b2) => a2.priority - b2.priority);
}
function reconcileSnapshot(value, sn, modelPool, parent) {
  if (isPrimitive$2(sn)) {
    return sn;
  }
  if (getSnapshot(value) === sn) {
    return value;
  }
  registerDefaultReconcilers();
  const reconcilersLen = reconcilers.length;
  for (let i2 = 0; i2 < reconcilersLen; i2++) {
    const { reconciler } = reconcilers[i2];
    const ret = reconciler(value, sn, modelPool, parent);
    if (ret !== void 0) {
      return ret;
    }
  }
  if (isMap$1(sn)) {
    throw failure("a snapshot must not contain maps");
  }
  if (isSet$1(sn)) {
    throw failure("a snapshot must not contain sets");
  }
  throw failure(`unsupported snapshot - ${sn}`);
}
function detachIfNeeded(newValue, oldValue, modelPool) {
  if (newValue === oldValue) {
    return;
  }
  if (isModel(newValue) && modelPool.findModelByTypeAndId(newValue[modelTypeKey], newValue[modelIdKey])) {
    const parentPath = fastGetParentPathIncludingDataObjects(newValue);
    if (parentPath) {
      set$1(parentPath.parent, parentPath.path, null);
    }
  }
}
function applyPatches(node, patches, reverse2 = false) {
  assertTweakedObject(node, "node");
  if (patches.length <= 0) {
    return;
  }
  wrappedInternalApplyPatches().call(node, patches, reverse2);
}
function internalApplyPatches(patches, reverse2 = false) {
  const obj = this;
  const modelPool = new ModelPool(obj);
  if (reverse2) {
    let i2 = patches.length;
    while (i2--) {
      const p2 = patches[i2];
      if (!isArray$2(p2)) {
        applySinglePatch(obj, p2, modelPool);
      } else {
        let j2 = p2.length;
        while (j2--) {
          applySinglePatch(obj, p2[j2], modelPool);
        }
      }
    }
  } else {
    const len = patches.length;
    for (let i2 = 0; i2 < len; i2++) {
      const p2 = patches[i2];
      if (!isArray$2(p2)) {
        applySinglePatch(obj, p2, modelPool);
      } else {
        const len2 = p2.length;
        for (let j2 = 0; j2 < len2; j2++) {
          applySinglePatch(obj, p2[j2], modelPool);
        }
      }
    }
  }
}
const wrappedInternalApplyPatches = lazy(() => wrapInAction({
  nameOrNameFn: BuiltInAction.ApplyPatches,
  fn: internalApplyPatches,
  actionType: ActionContextActionType.Sync
}));
function applySinglePatch(obj, patch, modelPool) {
  const { target, prop: prop2 } = pathArrayToObjectAndProp(obj, patch.path);
  if (isArray$2(target)) {
    switch (patch.op) {
      case "add": {
        const index2 = +prop2;
        const newValue = reconcileSnapshot(void 0, patch.value, modelPool, target);
        target.splice(index2, 0, newValue);
        break;
      }
      case "remove": {
        const index2 = +prop2;
        target.splice(index2, 1);
        break;
      }
      case "replace": {
        if (prop2 === "length") {
          target.length = patch.value;
        } else {
          const index2 = +prop2;
          const newValue = reconcileSnapshot(target[index2], patch.value, modelPool, target);
          setIfDifferent(target, index2, newValue);
        }
        break;
      }
      default:
        throw failure(`unsupported patch operation: ${patch.op}`);
    }
  } else {
    switch (patch.op) {
      case "add": {
        const newValue = reconcileSnapshot(void 0, patch.value, modelPool, target);
        setIfDifferent(target, prop2, newValue);
        break;
      }
      case "remove": {
        remove$1(target, prop2);
        break;
      }
      case "replace": {
        const newValue = reconcileSnapshot(target[prop2], patch.value, modelPool, target);
        setIfDifferent(target, prop2, newValue);
        break;
      }
      default:
        throw failure(`unsupported patch operation: ${patch.op}`);
    }
  }
}
function pathArrayToObjectAndProp(obj, path) {
  let target = modelToDataNode(obj);
  if (path.length === 0) {
    return {
      target
    };
  }
  for (let i2 = 0; i2 <= path.length - 2; i2++) {
    target = modelToDataNode(target[path[i2]]);
  }
  return {
    target,
    prop: path[path.length - 1]
  };
}
function runTypeCheckingAfterChange(obj, patchRecorder2, snapshotBeforeChanges) {
  if (!isTypeCheckingAllowed()) {
    return;
  }
  invalidateCachedTypeCheckerResult(obj);
  if (isModelAutoTypeCheckingEnabled()) {
    const parentModelWithTypeChecker = findNearestParentModelWithTypeChecker(obj);
    if (parentModelWithTypeChecker) {
      const err = parentModelWithTypeChecker.typeCheck();
      if (err) {
        runWithoutSnapshotOrPatches(() => {
          if (patchRecorder2) {
            internalApplyPatches.call(obj, patchRecorder2.invPatches, true);
          } else if (snapshotBeforeChanges) {
            internalApplySnapshot.call(obj, snapshotBeforeChanges);
          }
        });
        err.throw();
      }
    }
  }
}
function findNearestParentModelWithTypeChecker(child) {
  const actualChild = dataToModelNode(child);
  if (child !== actualChild) {
    child = actualChild;
    if (isModel(child) && !!getModelMetadata(child).dataType) {
      return child;
    }
  }
  return findParent(child, (parent) => {
    return isModel(parent) && !!getModelMetadata(parent).dataType;
  });
}
function tweakPlainObject(value, parentPath, snapshotModelType, doNotTweakChildren, isDataObject) {
  const originalObj = value;
  const tweakedObj = isObservableObject(originalObj) ? originalObj : observable$1.object({}, void 0, observableOptions$2);
  let interceptDisposer;
  let observeDisposer;
  const untweak = () => {
    interceptDisposer();
    observeDisposer();
  };
  tweakedObjects.set(tweakedObj, untweak);
  setParent({
    value: tweakedObj,
    parentPath,
    indexChangeAllowed: false,
    isDataObject,
    // an object shouldn't be cloned
    cloneIfApplicable: false
  });
  let untransformedSn = {};
  const originalObjKeys = Object.keys(originalObj);
  const originalObjKeysLen = originalObjKeys.length;
  for (let i2 = 0; i2 < originalObjKeysLen; i2++) {
    const k2 = originalObjKeys[i2];
    const v2 = originalObj[k2];
    if (isPrimitive$2(v2)) {
      if (!doNotTweakChildren) {
        setIfDifferent(tweakedObj, k2, v2);
      }
      untransformedSn[k2] = v2;
    } else {
      const path = { parent: tweakedObj, path: k2 };
      let tweakedValue;
      if (doNotTweakChildren) {
        tweakedValue = v2;
        setParent({
          value: tweakedValue,
          parentPath: path,
          indexChangeAllowed: false,
          isDataObject: false,
          // the value is already a new value (the result of a fromSnapshot)
          cloneIfApplicable: false
        });
      } else {
        tweakedValue = tweak(v2, path);
        setIfDifferent(tweakedObj, k2, tweakedValue);
      }
      const valueSn = getInternalSnapshot(tweakedValue);
      untransformedSn[k2] = valueSn.transformed;
    }
  }
  let transformFn;
  if (snapshotModelType) {
    untransformedSn[modelTypeKey] = snapshotModelType;
    const modelInfo = getModelInfoForName(snapshotModelType);
    if (!modelInfo) {
      throw failure(`model with name "${snapshotModelType}" not found in the registry`);
    }
    const originalTransformFn = modelInfo.class.toSnapshotProcessor;
    if (originalTransformFn) {
      transformFn = (sn) => originalTransformFn(sn, dataToModelNode(tweakedObj));
    }
  }
  setNewInternalSnapshot(isDataObject ? dataToModelNode(tweakedObj) : tweakedObj, untransformedSn, transformFn);
  interceptDisposer = intercept(tweakedObj, interceptObjectMutation);
  observeDisposer = observe(tweakedObj, objectDidChange);
  return tweakedObj;
}
const observableOptions$2 = {
  deep: false
};
function mutateSet$1(k2, v2, sn) {
  sn[k2] = v2;
}
function mutateDelete(k2, sn) {
  delete sn[k2];
}
const patchRecorder$2 = new InternalPatchRecorder();
function objectDidChange(change) {
  const obj = change.object;
  const actualNode = dataToModelNode(obj);
  let oldUntransformedSn = getInternalSnapshot(actualNode).untransformed;
  patchRecorder$2.reset();
  let mutate;
  switch (change.type) {
    case "add":
    case "update":
      mutate = objectDidChangeAddOrUpdate(change, oldUntransformedSn);
      break;
    case "remove":
      mutate = objectDidChangeRemove(change, oldUntransformedSn);
      break;
  }
  runTypeCheckingAfterChange(obj, patchRecorder$2);
  if (!runningWithoutSnapshotOrPatches && mutate) {
    updateInternalSnapshot(actualNode, mutate);
    patchRecorder$2.emit(actualNode);
  }
}
function objectDidChangeRemove(change, oldUntransformedSn) {
  const k2 = change.name;
  const oldVal = oldUntransformedSn[k2];
  const mutate = mutateDelete.bind(void 0, k2);
  const path = [k2];
  patchRecorder$2.record([
    {
      op: "remove",
      path
    }
  ], [
    {
      op: "add",
      path,
      value: freezeInternalSnapshot(oldVal)
    }
  ]);
  return mutate;
}
function objectDidChangeAddOrUpdate(change, oldUntransformedSn) {
  const k2 = change.name;
  const val = change.newValue;
  const oldVal = oldUntransformedSn[k2];
  let newVal;
  if (isPrimitive$2(val)) {
    newVal = val;
  } else {
    const valueSn = getInternalSnapshot(val);
    newVal = valueSn.transformed;
  }
  const mutate = mutateSet$1.bind(void 0, k2, newVal);
  const path = [k2];
  if (change.type === "add") {
    patchRecorder$2.record([
      {
        op: "add",
        path,
        value: freezeInternalSnapshot(newVal)
      }
    ], [
      {
        op: "remove",
        path
      }
    ]);
  } else {
    patchRecorder$2.record([
      {
        op: "replace",
        path,
        value: freezeInternalSnapshot(newVal)
      }
    ], [
      {
        op: "replace",
        path,
        value: freezeInternalSnapshot(oldVal)
      }
    ]);
  }
  return mutate;
}
function interceptObjectMutation(change) {
  assertCanWrite();
  if (typeof change.name === "symbol") {
    throw failure("symbol properties are not supported");
  }
  switch (change.type) {
    case "add":
      change.newValue = tweak(change.newValue, {
        parent: change.object,
        path: "" + change.name
      });
      break;
    case "remove": {
      const oldVal = change.object[change.name];
      tweak(oldVal, void 0);
      break;
    }
    case "update": {
      const oldVal = change.object[change.name];
      const newVal = change.newValue;
      if (newVal !== oldVal) {
        tweak(oldVal, void 0);
        change.newValue = tweak(change.newValue, {
          parent: change.object,
          path: "" + change.name
        });
      }
      break;
    }
  }
  return change;
}
function registerPlainObjectTweaker() {
  registerTweaker(TweakerPriority.PlainObject, (value, parentPath) => {
    if (isObservableObject(value) || isPlainObject$3(value)) {
      return tweakPlainObject(value, parentPath, void 0, false, false);
    }
    return void 0;
  });
}
let defaultTweakersRegistered = false;
function registerDefaultTweakers() {
  if (defaultTweakersRegistered) {
    return;
  }
  defaultTweakersRegistered = true;
  registerArrayTweaker();
  registerFrozenTweaker();
  registerModelTweaker();
  registerPlainObjectTweaker();
}
function toTreeNode(arg1, arg2) {
  let value, type;
  let hasType;
  if (arguments.length === 1) {
    hasType = false;
    value = arg1;
  } else {
    type = arg1;
    hasType = true;
    value = arg2;
  }
  if (!isObject$1(value)) {
    throw failure("only objects can be turned into tree nodes");
  }
  if (hasType && isModelAutoTypeCheckingEnabled()) {
    const errors = typeCheck(type, value);
    if (errors) {
      errors.throw();
    }
  }
  if (!isTweakedObject(value, true)) {
    return tweak(value, void 0);
  }
  return value;
}
const tweakers = [];
function registerTweaker(priority, tweaker) {
  tweakers.push({ priority, tweaker });
  tweakers.sort((a2, b2) => a2.priority - b2.priority);
}
function internalTweak(value, parentPath) {
  if (isPrimitive$2(value)) {
    return value;
  }
  if (isTweakedObject(value, true)) {
    value = setParent({
      value,
      parentPath,
      indexChangeAllowed: false,
      isDataObject: false,
      cloneIfApplicable: true
    });
    return value;
  }
  if (isDataModel(value)) {
    throw failure("data models are not directly supported. you may insert the data in the tree instead ('$' property).");
  }
  registerDefaultTweakers();
  const tweakersLen = tweakers.length;
  for (let i2 = 0; i2 < tweakersLen; i2++) {
    const { tweaker } = tweakers[i2];
    const tweakedVal = tweaker(value, parentPath);
    if (tweakedVal !== void 0) {
      return tweakedVal;
    }
  }
  if (isMap$1(value)) {
    throw failure("maps are not directly supported. consider using 'ObjectMap' / 'asMap' instead.");
  }
  if (isSet$1(value)) {
    throw failure("sets are not directly supported. consider using 'ArraySet' / 'asSet' instead.");
  }
  throw failure(`tweak can only work over models, observable objects/arrays, or primitives, but got ${value} instead`);
}
const tweak = action("tweak", internalTweak);
function tryUntweak(value) {
  if (isPrimitive$2(value)) {
    return void 0;
  }
  const untweaker = tweakedObjects.get(value);
  if (!untweaker) {
    return void 0;
  }
  const children = Array.from(getObjectChildren(value).values());
  for (let i2 = 0; i2 < children.length; i2++) {
    setParent({
      value: children[i2],
      parentPath: void 0,
      indexChangeAllowed: false,
      isDataObject: false,
      // no need to clone if unsetting the parent
      cloneIfApplicable: false
    });
  }
  return () => {
    untweaker();
    tweakedObjects.delete(value);
    unsetInternalSnapshot(value);
  };
}
function tweakArray(value, parentPath, doNotTweakChildren) {
  const originalArr = value;
  const arrLn = originalArr.length;
  const tweakedArr = isObservableArray(originalArr) ? originalArr : observable$1.array(void 0, observableOptions$1);
  if (tweakedArr !== originalArr) {
    tweakedArr.length = originalArr.length;
  }
  let interceptDisposer;
  let observeDisposer;
  const untweak = () => {
    interceptDisposer();
    observeDisposer();
  };
  tweakedObjects.set(tweakedArr, untweak);
  setParent({
    value: tweakedArr,
    parentPath,
    indexChangeAllowed: false,
    isDataObject: false,
    // arrays shouldn't be cloned anyway
    cloneIfApplicable: false
  });
  const untransformedSn = [];
  untransformedSn.length = arrLn;
  for (let i2 = 0; i2 < arrLn; i2++) {
    const v2 = originalArr[i2];
    if (isPrimitive$2(v2)) {
      if (!doNotTweakChildren) {
        setIfDifferent(tweakedArr, i2, v2);
      }
      untransformedSn[i2] = v2;
    } else {
      const path = { parent: tweakedArr, path: i2 };
      let tweakedValue;
      if (doNotTweakChildren) {
        tweakedValue = v2;
        setParent({
          value: tweakedValue,
          parentPath: path,
          indexChangeAllowed: false,
          isDataObject: false,
          // the value is already a new value (the result of a fromSnapshot)
          cloneIfApplicable: false
        });
      } else {
        tweakedValue = tweak(v2, path);
        setIfDifferent(tweakedArr, i2, tweakedValue);
      }
      const valueSn = getInternalSnapshot(tweakedValue);
      untransformedSn[i2] = valueSn.transformed;
    }
  }
  setNewInternalSnapshot(tweakedArr, untransformedSn, void 0);
  interceptDisposer = intercept(tweakedArr, interceptArrayMutation.bind(void 0, tweakedArr));
  observeDisposer = observe(tweakedArr, arrayDidChange);
  return tweakedArr;
}
function mutateSet(k2, v2, sn) {
  sn[k2] = v2;
}
function mutateSplice(index2, removedCount, addedItems, sn) {
  sn.splice(index2, removedCount, ...addedItems);
}
const patchRecorder$1 = new InternalPatchRecorder();
function arrayDidChange(change) {
  const arr = change.object;
  let oldSnapshot = getInternalSnapshot(arr).untransformed;
  patchRecorder$1.reset();
  let mutate;
  switch (change.type) {
    case "splice":
      mutate = arrayDidChangeSplice(change, oldSnapshot);
      break;
    case "update":
      mutate = arrayDidChangeUpdate(change, oldSnapshot);
      break;
  }
  runTypeCheckingAfterChange(arr, patchRecorder$1);
  if (!runningWithoutSnapshotOrPatches && mutate) {
    updateInternalSnapshot(arr, mutate);
    patchRecorder$1.emit(arr);
  }
}
function arrayDidChangeUpdate(change, oldSnapshot) {
  const k2 = change.index;
  const val = change.newValue;
  const oldVal = oldSnapshot[k2];
  let newVal;
  if (isPrimitive$2(val)) {
    newVal = val;
  } else {
    const valueSn = getInternalSnapshot(val);
    newVal = valueSn.transformed;
  }
  const mutate = mutateSet.bind(void 0, k2, newVal);
  const path = [k2];
  patchRecorder$1.record([
    {
      op: "replace",
      path,
      value: freezeInternalSnapshot(newVal)
    }
  ], [
    {
      op: "replace",
      path,
      value: freezeInternalSnapshot(oldVal)
    }
  ]);
  return mutate;
}
function arrayDidChangeSplice(change, oldSnapshot) {
  const index2 = change.index;
  const addedCount = change.addedCount;
  const removedCount = change.removedCount;
  let addedItems = [];
  addedItems.length = addedCount;
  for (let i2 = 0; i2 < addedCount; i2++) {
    const v2 = change.added[i2];
    if (isPrimitive$2(v2)) {
      addedItems[i2] = v2;
    } else {
      addedItems[i2] = getInternalSnapshot(v2).transformed;
    }
  }
  const oldLen = oldSnapshot.length;
  const mutate = mutateSplice.bind(void 0, index2, removedCount, addedItems);
  const patches = [];
  const invPatches = [];
  if (addedCount === removedCount) {
    const readdPatches = [];
    const readdInvPatches = [];
    let removed = 0;
    for (let i2 = 0; i2 < addedCount; i2++) {
      const realIndex = index2 + i2;
      const newVal = getValueAfterSplice(oldSnapshot, realIndex, index2, removedCount, addedItems);
      const oldVal = oldSnapshot[realIndex];
      if (newVal !== oldVal) {
        const removePath = [realIndex - removed];
        patches.push({
          op: "remove",
          path: removePath
        });
        invPatches.push({
          op: "remove",
          path: removePath
        });
        removed++;
        const readdPath = [realIndex];
        readdPatches.push({
          op: "add",
          path: readdPath,
          value: freezeInternalSnapshot(newVal)
        });
        readdInvPatches.push({
          op: "add",
          path: readdPath,
          value: freezeInternalSnapshot(oldVal)
        });
      }
    }
    patches.push(...readdPatches);
    invPatches.push(...readdInvPatches);
    invPatches.reverse();
  } else {
    const interimLen = oldLen - removedCount;
    if (removedCount > 0) {
      const removeUsingSetLength = index2 >= interimLen;
      if (removeUsingSetLength) {
        patches.push({
          op: "replace",
          path: ["length"],
          value: interimLen
        });
      }
      for (let i2 = removedCount - 1; i2 >= 0; i2--) {
        const realIndex = index2 + i2;
        const path = [realIndex];
        if (!removeUsingSetLength) {
          patches.push({
            op: "remove",
            path
          });
        }
        invPatches.push({
          op: "add",
          path,
          value: freezeInternalSnapshot(oldSnapshot[realIndex])
        });
      }
    }
    if (addedCount > 0) {
      const restoreUsingSetLength = index2 >= interimLen;
      if (restoreUsingSetLength) {
        invPatches.push({
          op: "replace",
          path: ["length"],
          value: interimLen
        });
      }
      for (let i2 = 0; i2 < addedCount; i2++) {
        const realIndex = index2 + i2;
        const path = [realIndex];
        patches.push({
          op: "add",
          path,
          value: freezeInternalSnapshot(getValueAfterSplice(oldSnapshot, realIndex, index2, removedCount, addedItems))
        });
        if (!restoreUsingSetLength) {
          invPatches.push({
            op: "remove",
            path
          });
        }
      }
    }
  }
  patchRecorder$1.record(patches, invPatches);
  return mutate;
}
function interceptArrayMutation(array2, change) {
  assertCanWrite();
  switch (change.type) {
    case "splice":
      interceptArrayMutationSplice(change);
      break;
    case "update":
      interceptArrayMutationUpdate(change, array2);
      break;
  }
  return change;
}
function interceptArrayMutationUpdate(change, array2) {
  const oldVal = array2[change.index];
  tweak(oldVal, void 0);
  change.newValue = tweak(change.newValue, { parent: array2, path: change.index });
}
function interceptArrayMutationSplice(change) {
  for (let i2 = 0; i2 < change.removedCount; i2++) {
    const removedValue = change.object[change.index + i2];
    tweak(removedValue, void 0);
  }
  for (let i2 = 0; i2 < change.added.length; i2++) {
    change.added[i2] = tweak(change.added[i2], {
      parent: change.object,
      path: change.index + i2
    });
  }
  const oldNextIndex = change.index + change.removedCount;
  const newNextIndex = change.index + change.added.length;
  if (oldNextIndex !== newNextIndex) {
    for (let i2 = oldNextIndex, j2 = newNextIndex; i2 < change.object.length; i2++, j2++) {
      setParent({
        value: change.object[i2],
        parentPath: {
          parent: change.object,
          path: j2
        },
        indexChangeAllowed: true,
        isDataObject: false,
        // just re-indexing
        cloneIfApplicable: false
      });
    }
  }
}
function registerArrayTweaker() {
  registerTweaker(TweakerPriority.Array, (value, parentPath) => {
    if (isArray$2(value)) {
      return tweakArray(value, parentPath, false);
    }
    return void 0;
  });
}
const observableOptions$1 = {
  deep: false
};
function getValueAfterSplice(array2, i2, index2, remove22, addedItems) {
  const base = i2 - index2;
  if (base < 0) {
    return array2[i2];
  }
  if (base < addedItems.length) {
    return addedItems[base];
  }
  return array2[i2 - addedItems.length + remove22];
}
function fromArraySnapshot(sn, ctx) {
  const arr = observable$1.array([], observableOptions);
  const ln = sn.length;
  for (let i2 = 0; i2 < ln; i2++) {
    arr.push(internalFromSnapshot(sn[i2], ctx));
  }
  return tweakArray(arr, void 0, true);
}
function registerFromArraySnapshotter() {
  registerSnapshotter(SnapshotterAndReconcilerPriority.Array, (sn, ctx) => {
    if (isArray$2(sn)) {
      return fromArraySnapshot(sn, ctx);
    }
    return void 0;
  });
}
function registerFromFrozenSnapshotter() {
  registerSnapshotter(SnapshotterAndReconcilerPriority.Frozen, (sn) => {
    if (isFrozenSnapshot(sn)) {
      return frozen(sn.data);
    }
    return void 0;
  });
}
function fromModelSnapshot(sn, ctx) {
  const type = sn[modelTypeKey];
  if (!type) {
    throw failure(`a model snapshot must contain a type key (${modelTypeKey}), but none was found`);
  }
  const modelInfo = getModelInfoForName(type);
  if (!modelInfo) {
    throw failure(`model with name "${type}" not found in the registry`);
  }
  const modelIdPropertyName = getModelIdPropertyName(modelInfo.class);
  if (modelIdPropertyName && sn[modelIdPropertyName] === void 0) {
    throw failure(`a model snapshot of type '${type}' must contain an id key (${modelIdPropertyName}), but none was found`);
  }
  return new modelInfo.class(void 0, {
    snapshotInitialData: {
      unprocessedSnapshot: sn,
      snapshotToInitialData: ctx.snapshotToInitialData
    },
    generateNewIds: ctx.options.generateNewIds
  });
}
function registerFromModelSnapshotter() {
  registerSnapshotter(SnapshotterAndReconcilerPriority.Model, (sn, ctx) => {
    if (isModelSnapshot(sn)) {
      return fromModelSnapshot(sn, ctx);
    }
    return void 0;
  });
}
function fromPlainObjectSnapshot(sn, ctx) {
  const plainObj = observable$1.object({}, void 0, observableOptions);
  const snKeys = Object.keys(sn);
  const snKeysLen = snKeys.length;
  for (let i2 = 0; i2 < snKeysLen; i2++) {
    const k2 = snKeys[i2];
    const v2 = sn[k2];
    set$1(plainObj, k2, internalFromSnapshot(v2, ctx));
  }
  return tweakPlainObject(plainObj, void 0, void 0, true, false);
}
function registerFromPlainObjectSnapshotter() {
  registerSnapshotter(SnapshotterAndReconcilerPriority.PlainObject, (sn, ctx) => {
    if (isPlainObject$3(sn)) {
      return fromPlainObjectSnapshot(sn, ctx);
    }
    return void 0;
  });
}
let defaultSnapshottersRegistered = false;
function registerDefaultSnapshotters() {
  if (defaultSnapshottersRegistered) {
    return;
  }
  defaultSnapshottersRegistered = true;
  registerFromArraySnapshotter();
  registerFromFrozenSnapshotter();
  registerFromModelSnapshotter();
  registerFromPlainObjectSnapshotter();
}
const snapshotters = [];
function registerSnapshotter(priority, snapshotter) {
  snapshotters.push({ priority, snapshotter });
  snapshotters.sort((a2, b2) => a2.priority - b2.priority);
}
function fromSnapshot(arg1, arg2, arg3) {
  let snapshot;
  let options;
  if (isLateTypeChecker(arg1) || arg1 instanceof TypeChecker || isModelClass(arg1)) {
    const typeChecker = resolveTypeChecker(arg1);
    snapshot = typeChecker.fromSnapshotProcessor ? typeChecker.fromSnapshotProcessor(arg2) : arg2;
    options = arg3;
  } else {
    snapshot = arg1;
    options = arg2;
  }
  return fromSnapshotAction(snapshot, options);
}
const fromSnapshotAction = action("fromSnapshot", (snapshot, options) => {
  const opts = {
    generateNewIds: false,
    overrideRootModelId: void 0,
    ...options
  };
  const ctx = {
    options: opts
  };
  ctx.snapshotToInitialData = snapshotToInitialData.bind(void 0, ctx);
  return internalFromSnapshot(snapshot, ctx);
});
function internalFromSnapshot(sn, ctx) {
  if (isPrimitive$2(sn)) {
    return sn;
  }
  registerDefaultSnapshotters();
  const snapshotterLen = snapshotters.length;
  for (let i2 = 0; i2 < snapshotterLen; i2++) {
    const { snapshotter } = snapshotters[i2];
    const ret = snapshotter(sn, ctx);
    if (ret !== void 0) {
      return ret;
    }
  }
  if (isMap$1(sn)) {
    throw failure("a snapshot must not contain maps");
  }
  if (isSet$1(sn)) {
    throw failure("a snapshot must not contain sets");
  }
  throw failure(`unsupported snapshot - ${sn}`);
}
function snapshotToInitialData(ctx, processedSn) {
  const initialData = observable$1.object({}, void 0, observableOptions);
  const processedSnKeys = Object.keys(processedSn);
  const processedSnKeysLen = processedSnKeys.length;
  for (let i2 = 0; i2 < processedSnKeysLen; i2++) {
    const k2 = processedSnKeys[i2];
    if (!isReservedModelKey(k2)) {
      const v2 = processedSn[k2];
      set$1(initialData, k2, internalFromSnapshot(v2, ctx));
    }
  }
  return initialData;
}
const observableOptions = {
  deep: false
};
function clone(node, options) {
  assertTweakedObject(node, "node");
  const opts = {
    generateNewIds: true,
    ...options
  };
  const sn = getSnapshot(node);
  return fromSnapshot(sn, opts);
}
const setParent = action("setParent", ({ value, parentPath, indexChangeAllowed, isDataObject, cloneIfApplicable }) => {
  if (isPrimitive$2(value)) {
    return value;
  }
  let oldParentPath = fastGetParentPath(value);
  if (parentPathEquals(oldParentPath, parentPath)) {
    return value;
  }
  if (fastIsRootStore(value)) {
    throw failure("root stores cannot be attached to any parents");
  }
  if (isDataObject) {
    dataObjectParent.set(value, parentPath.parent);
    return value;
  }
  if (parentPath) {
    const actualParent = dataToModelNode(parentPath.parent);
    if (parentPath.parent !== actualParent) {
      parentPath = {
        parent: actualParent,
        path: parentPath.path
      };
    }
  }
  if (cloneIfApplicable && (parentPath == null ? void 0 : parentPath.parent) && (oldParentPath == null ? void 0 : oldParentPath.parent) && isModel(value) && getModelMetadata(value).valueType) {
    value = clone(value, { generateNewIds: true });
    oldParentPath = fastGetParentPath(value);
  }
  if (oldParentPath && parentPath) {
    if (oldParentPath.parent === parentPath.parent && indexChangeAllowed) {
      objectParents.set(value, parentPath);
      reportParentPathChanged(value);
      return value;
    } else {
      throw failure("an object cannot be assigned a new parent when it already has one");
    }
  }
  let postUntweaker;
  if (!parentPath) {
    postUntweaker = tryUntweak(value);
  }
  const attachToNewParent = () => {
    if (oldParentPath == null ? void 0 : oldParentPath.parent) {
      removeObjectChild(oldParentPath.parent, value);
    }
    objectParents.set(value, parentPath);
    if (parentPath == null ? void 0 : parentPath.parent) {
      addObjectChild(parentPath.parent, value);
    }
    reportParentPathChanged(value);
  };
  if (value instanceof BaseModel) {
    const oldRoot = fastGetRoot(value);
    const oldRootStore = fastIsRootStore(oldRoot) ? oldRoot : void 0;
    attachToNewParent();
    const newRoot = fastGetRoot(value);
    const newRootStore = fastIsRootStore(newRoot) ? newRoot : void 0;
    if (oldRootStore !== newRootStore && (oldRootStore || newRootStore)) {
      enqueuePendingAction(() => {
        if (oldRootStore) {
          detachFromRootStore(value);
        }
        if (newRootStore) {
          attachToRootStore(newRootStore, value);
        }
      });
    }
  } else {
    attachToNewParent();
  }
  postUntweaker == null ? void 0 : postUntweaker();
  return value;
});
function tweakModel(value, parentPath) {
  tweakedObjects.set(value, void 0);
  setParent({
    value,
    parentPath,
    indexChangeAllowed: false,
    isDataObject: false,
    cloneIfApplicable: true
  });
  return value;
}
function registerModelTweaker() {
  registerTweaker(TweakerPriority.Model, (value, parentPath) => {
    if (isModel(value)) {
      return tweakModel(value, parentPath);
    }
    return void 0;
  });
}
const internalNewModel = action("newModel", (origModelObj, initialData, options) => {
  const mode = initialData ? "new" : "fromSnapshot";
  const { modelClass: _modelClass, snapshotInitialData, generateNewIds } = options;
  const modelClass2 = _modelClass;
  const modelObj = origModelObj;
  const modelInfo = modelInfoByClass.get(modelClass2);
  if (!modelInfo) {
    throw failure(`no model info for class ${modelClass2.name} could be found - did you forget to add the @model decorator?`);
  }
  const modelIdPropertyName = getModelIdPropertyName(modelClass2);
  const modelProps = getInternalModelClassPropsInfo(modelClass2);
  const modelIdPropData = modelIdPropertyName ? modelProps[modelIdPropertyName] : void 0;
  let id2;
  if (snapshotInitialData) {
    let sn = snapshotInitialData.unprocessedSnapshot;
    if (modelIdPropData && modelIdPropertyName) {
      if (generateNewIds) {
        id2 = modelIdPropData._defaultFn();
      } else {
        id2 = sn[modelIdPropertyName];
      }
    }
    if (modelClass2.fromSnapshotProcessor) {
      sn = modelClass2.fromSnapshotProcessor(sn);
    }
    initialData = snapshotInitialData.snapshotToInitialData(sn);
  } else {
    if (modelIdPropData && modelIdPropertyName) {
      if (initialData[modelIdPropertyName]) {
        id2 = initialData[modelIdPropertyName];
      } else {
        id2 = modelIdPropData._defaultFn();
      }
    }
  }
  modelObj[modelTypeKey] = modelInfo.name;
  const modelPropsKeys = Object.keys(modelProps);
  for (let i2 = 0; i2 < modelPropsKeys.length; i2++) {
    const k2 = modelPropsKeys[i2];
    if (k2 === modelIdPropertyName) {
      continue;
    }
    const propData = modelProps[k2];
    let newValue = initialData[k2];
    let changed = false;
    if (mode === "new" && propData._transform) {
      changed = true;
      newValue = propData._transform.untransform(newValue, modelObj, k2);
    }
    if (newValue == null) {
      const defaultValue = getModelPropDefaultValue(propData);
      if (defaultValue !== noDefaultValue) {
        changed = true;
        newValue = defaultValue;
      } else if (!(k2 in initialData)) {
        changed = true;
      }
    }
    if (changed) {
      set$1(initialData, k2, newValue);
    }
  }
  if (modelIdPropertyName) {
    set$1(initialData, modelIdPropertyName, id2);
  }
  tweakModel(modelObj, void 0);
  modelObj.$ = tweakPlainObject(initialData, { parent: modelObj, path: "$" }, modelObj[modelTypeKey], false, true);
  applyModelInitializers(modelClass2, modelObj);
  if (isModelAutoTypeCheckingEnabled() && getModelMetadata(modelClass2).dataType) {
    const err = modelObj.typeCheck();
    if (err) {
      err.throw();
    }
  }
  return modelObj;
});
const modelIdPropertyNameSymbol = Symbol("modelIdPropertyName");
class BaseModel {
  /**
   * Creates an instance of a model.
   */
  constructor(data) {
    __publicField(this, _b);
    __publicField(this, _c);
    __publicField(this, _d);
    __publicField(this, _e$4);
    __publicField(this, _f);
    __publicField(this, "$");
    let initialData = data;
    const { snapshotInitialData, modelClass: modelClass2, generateNewIds } = arguments[1];
    Object.setPrototypeOf(this, modelClass2.prototype);
    const self2 = this;
    delete self2[propsTypeSymbol];
    delete self2[fromSnapshotOverrideTypeSymbol];
    delete self2[toSnapshotOverrideTypeSymbol];
    delete self2[modelIdPropertyNameSymbol];
    if (!snapshotInitialData) {
      assertIsObject(initialData, "initialData");
      internalNewModel(this, observable$1.object(initialData, void 0, { deep: false }), {
        modelClass: modelClass2,
        generateNewIds: true
      });
    } else {
      internalNewModel(this, void 0, { modelClass: modelClass2, snapshotInitialData, generateNewIds });
    }
  }
  /**
   * Model internal id. Can be modified inside a model action.
   * It will return `undefined` if there's no id prop set.
   */
  get [(_b = propsTypeSymbol, _c = fromSnapshotOverrideTypeSymbol, _d = toSnapshotOverrideTypeSymbol, _e$4 = modelIdPropertyNameSymbol, _f = modelTypeKey, modelIdKey)]() {
    const idProp2 = getModelIdPropertyName(this.constructor);
    return idProp2 ? this.$[idProp2] : void 0;
  }
  set [modelIdKey](newId) {
    const idProp2 = getModelIdPropertyName(this.constructor);
    if (!idProp2) {
      throw failure("$modelId cannot be set when there is no idProp set in the model");
    }
    this.$[idProp2] = newId;
  }
  /**
   * Can be overridden to offer a reference id to be used in reference resolution.
   * By default it will use the `idProp` if available or return `undefined` otherwise.
   */
  getRefId() {
    return this[modelIdKey];
  }
  /**
   * Performs a type check over the model instance.
   * For this to work a data type has to be declared as part of the model properties.
   *
   * @returns A `TypeCheckError` or `null` if there is no error.
   */
  typeCheck() {
    const type = typesModel(this.constructor);
    return typeCheck(type, this);
  }
  toString(options) {
    const finalOptions = {
      withData: true,
      ...options
    };
    const firstPart = `${this.constructor.name}#${this[modelTypeKey]}`;
    return finalOptions.withData ? `[${firstPart} ${JSON.stringify(getSnapshot(this))}]` : `[${firstPart}]`;
  }
}
const baseModelPropNames = /* @__PURE__ */ new Set([
  modelTypeKey,
  modelIdKey,
  "onInit",
  "$",
  "getRefId",
  "onAttachedToRootStore",
  "typeCheck"
]);
function isModel(model2) {
  return model2 instanceof BaseModel;
}
function isModelClass(modelClass2) {
  if (typeof modelClass2 !== "function") {
    return false;
  }
  if (modelClass2 !== BaseModel && !(modelClass2.prototype instanceof BaseModel)) {
    return false;
  }
  return true;
}
function isModelSnapshot(sn) {
  return isPlainObject$3(sn) && modelTypeKey in sn;
}
function fastGetParentPath(value) {
  reportParentPathObserved(value);
  return objectParents.get(value);
}
function fastGetParentPathIncludingDataObjects(value) {
  const parentModel = dataObjectParent.get(value);
  if (parentModel) {
    return { parent: parentModel, path: "$" };
  }
  const parentPath = fastGetParentPath(value);
  if (parentPath && isModel(parentPath.parent)) {
    return { parent: parentPath.parent.$, path: parentPath.path };
  }
  return parentPath;
}
function fastGetParent(value) {
  var _a2;
  return (_a2 = fastGetParentPath(value)) == null ? void 0 : _a2.parent;
}
function fastGetParentIncludingDataObjects(value) {
  var _a2;
  return (_a2 = fastGetParentPathIncludingDataObjects(value)) == null ? void 0 : _a2.parent;
}
function fastGetRootPath(value) {
  let root = value;
  let path = [];
  let pathObjects = [value];
  let parentPath;
  while (parentPath = fastGetParentPath(root)) {
    root = parentPath.parent;
    path.unshift(parentPath.path);
    pathObjects.unshift(parentPath.parent);
  }
  return { root, path, pathObjects };
}
function fastGetRoot(value) {
  let root = value;
  let parentPath;
  while (parentPath = fastGetParentPath(root)) {
    root = parentPath.parent;
  }
  return root;
}
function isRoot(value) {
  assertTweakedObject(value, "value");
  return !fastGetParent(value);
}
const unresolved = { resolved: false };
function resolvePath$1(pathRootObject, path) {
  let current = pathRootObject;
  let len = path.length;
  for (let i2 = 0; i2 < len; i2++) {
    if (!isObject$1(current)) {
      return unresolved;
    }
    const p2 = path[i2];
    if (isArray$2(current) && +p2 >= current.length) {
      return unresolved;
    }
    if (isModel(current)) {
      const dataNode = modelToDataNode(current);
      if (p2 in dataNode) {
        current = dataNode;
      } else if (!(p2 in current)) {
        return unresolved;
      }
    }
    current = current[p2];
  }
  return { resolved: true, value: current };
}
const skipIdChecking = Symbol("skipIdChecking");
function resolvePathCheckingIds(pathRootObject, path, pathIds) {
  var _a2;
  let current = modelToDataNode(pathRootObject);
  let len = path.length;
  for (let i2 = 0; i2 < len; i2++) {
    if (!isObject$1(current)) {
      return { resolved: false };
    }
    const p2 = path[i2];
    if (isArray$2(current) && +p2 >= current.length) {
      return { resolved: false };
    }
    const currentMaybeModel = current[p2];
    current = modelToDataNode(currentMaybeModel);
    const expectedId = pathIds[i2];
    if (expectedId !== skipIdChecking) {
      const currentId = isModel(currentMaybeModel) ? (_a2 = currentMaybeModel[modelIdKey]) != null ? _a2 : null : null;
      if (expectedId !== currentId) {
        return { resolved: false };
      }
    }
  }
  return { resolved: true, value: dataToModelNode(current) };
}
const perObjectActionMiddlewares = /* @__PURE__ */ new WeakMap();
const perObjectActionMiddlewaresIterator = /* @__PURE__ */ new WeakMap();
function getActionMiddlewares(obj) {
  let iterable = perObjectActionMiddlewaresIterator.get(obj);
  if (!iterable) {
    iterable = {
      [Symbol.iterator]() {
        let current = obj;
        function getCurrentIterator() {
          const objMwares = current ? perObjectActionMiddlewares.get(current) : void 0;
          if (!objMwares || objMwares.length <= 0) {
            return void 0;
          }
          return objMwares[Symbol.iterator]();
        }
        function findNextIterator() {
          let nextIter;
          while (current && !nextIter) {
            current = fastGetParent(current);
            nextIter = getCurrentIterator();
          }
          return nextIter;
        }
        let iter = getCurrentIterator();
        if (!iter) {
          iter = findNextIterator();
        }
        const iterator = {
          next() {
            if (!iter) {
              return { value: void 0, done: true };
            }
            let result = iter.next();
            if (!result.done) {
              return result;
            }
            iter = findNextIterator();
            return this.next();
          }
        };
        return iterator;
      }
    };
    perObjectActionMiddlewaresIterator.set(obj, iterable);
  }
  return iterable;
}
function wrapInAction({ nameOrNameFn, fn, actionType, overrideContext, isFlowFinisher = false }) {
  let fnInAction = false;
  const wrappedAction = function() {
    const name2 = typeof nameOrNameFn === "function" ? nameOrNameFn() : nameOrNameFn;
    if (!fnInAction) {
      fnInAction = true;
      fn = action(name2, fn);
    }
    const target = this;
    const parentContext = getCurrentActionContext();
    const context = {
      actionName: name2,
      type: actionType,
      target,
      args: Array.from(arguments),
      parentContext,
      data: {},
      rootContext: void 0
      // will be set after the override
    };
    if (overrideContext) {
      overrideContext(context, this);
    }
    if (!context.rootContext) {
      if (context.previousAsyncStepContext) {
        context.rootContext = context.previousAsyncStepContext.rootContext;
      } else if (context.parentContext) {
        context.rootContext = context.parentContext.rootContext;
      } else {
        context.rootContext = context;
      }
    }
    setCurrentActionContext(context);
    let mwareFn = fn.bind(target, ...arguments);
    const mwareIter = getActionMiddlewares(context.target)[Symbol.iterator]();
    let mwareCur = mwareIter.next();
    while (!mwareCur.done) {
      const mware = mwareCur.value;
      const filterPassed = mware.filter ? mware.filter(context) : true;
      if (filterPassed) {
        mwareFn = mware.middleware.bind(void 0, context, mwareFn);
      }
      mwareCur = mwareIter.next();
    }
    try {
      const ret = mwareFn();
      if (isFlowFinisher) {
        const flowFinisher = ret;
        const value = flowFinisher.value;
        if (flowFinisher.resolution === "accept") {
          flowFinisher.accepter(value);
        } else {
          flowFinisher.rejecter(value);
        }
        return value;
      } else {
        return ret;
      }
    } finally {
      setCurrentActionContext(context.parentContext);
      tryRunPendingActions();
    }
  };
  wrappedAction[modelActionSymbol] = true;
  return wrappedAction;
}
function wrapModelMethodInActionIfNeeded(model2, propertyKey, name2) {
  const fn = model2[propertyKey];
  if (isModelAction(fn)) {
    return;
  }
  const wrappedFn = wrapInAction({
    nameOrNameFn: name2,
    fn,
    actionType: ActionContextActionType.Sync
  });
  const proto = Object.getPrototypeOf(model2);
  const protoFn = proto[propertyKey];
  if (protoFn === fn) {
    proto[propertyKey] = wrappedFn;
  } else {
    model2[propertyKey] = wrappedFn;
  }
}
function detach(node) {
  assertTweakedObject(node, "node");
  wrappedInternalDetach().call(node);
}
const wrappedInternalDetach = lazy(() => wrapInAction({
  nameOrNameFn: BuiltInAction.Detach,
  fn: internalDetach,
  actionType: ActionContextActionType.Sync
}));
function internalDetach() {
  const node = this;
  const parentPath = fastGetParentPathIncludingDataObjects(node);
  if (!parentPath)
    return;
  const { parent, path } = parentPath;
  if (isObservableArray(parent)) {
    parent.splice(+path, 1);
  } else if (isObservableObject(parent)) {
    remove$1(parent, "" + path);
  } else {
    throw failure("parent must be an observable object or an observable array");
  }
}
function checkModelDecoratorArgs(fnName, target, propertyKey) {
  if (typeof propertyKey !== "string") {
    throw failure(`${fnName} cannot be used over symbol properties`);
  }
  const errMessage2 = `${fnName} must be used over model classes or instances`;
  if (!target) {
    throw failure(errMessage2);
  }
  const isModel2 = target instanceof BaseModel || target === BaseModel || target.prototype instanceof BaseModel;
  if (isModel2)
    return;
  const isDataModel2 = target instanceof BaseDataModel || target === BaseDataModel || target.prototype instanceof BaseDataModel;
  if (isDataModel2)
    return;
  throw failure(errMessage2);
}
function getActionNameAndContextOverride(target, propertyKey) {
  let actionName = propertyKey;
  let overrideContext;
  if (isDataModelClass(target) || isDataModel(target)) {
    overrideContext = (ctx, self2) => {
      ctx.target = self2.$;
    };
    let fullActionName;
    actionName = () => fullActionName;
    const modelClass2 = isDataModelClass(target) ? target : target.constructor;
    addLateInitializationFunction(modelClass2, runAfterModelDecoratorSymbol, (finalClass) => {
      const modelInfo = modelInfoByClass.get(finalClass);
      fullActionName = `fn::${modelInfo.name}::${propertyKey}`;
      setDataModelAction(fullActionName, modelInfo.class, propertyKey);
    });
  }
  return { actionName, overrideContext };
}
const modelFlowSymbol = Symbol("modelFlow");
function flow2({ nameOrNameFn, generator, overrideContext }) {
  const flowFn = function(...args) {
    const name2 = typeof nameOrNameFn === "function" ? nameOrNameFn() : nameOrNameFn;
    const target = this;
    let previousAsyncStepContext;
    const ctxOverride = (stepType) => {
      return (ctx, self2) => {
        if (overrideContext) {
          overrideContext(ctx, self2);
        }
        ctx.previousAsyncStepContext = previousAsyncStepContext;
        ctx.spawnAsyncStepContext = previousAsyncStepContext ? previousAsyncStepContext.spawnAsyncStepContext : ctx;
        ctx.asyncStepType = stepType;
        ctx.args = args;
        previousAsyncStepContext = ctx;
      };
    };
    let generatorRun = false;
    const gen = wrapInAction({
      nameOrNameFn: name2,
      fn: () => {
        generatorRun = true;
        return generator.apply(target, args);
      },
      actionType: ActionContextActionType.Async,
      overrideContext: ctxOverride(ActionContextAsyncStepType.Spawn)
    }).apply(target);
    if (!generatorRun) {
      return gen instanceof Promise ? gen : Promise.resolve(gen);
    }
    const genNext = gen.next.bind(gen);
    const genThrow = gen.throw.bind(gen);
    const promise = new Promise(function(resolve, reject) {
      function onFulfilled(res) {
        let ret;
        try {
          ret = wrapInAction({
            nameOrNameFn: name2,
            fn: genNext,
            actionType: ActionContextActionType.Async,
            overrideContext: ctxOverride(ActionContextAsyncStepType.Resume)
          }).call(target, res);
        } catch (e2) {
          wrapInAction({
            nameOrNameFn: name2,
            fn: (err) => {
              return {
                value: err,
                resolution: "reject",
                accepter: resolve,
                rejecter: reject
              };
            },
            actionType: ActionContextActionType.Async,
            overrideContext: ctxOverride(ActionContextAsyncStepType.Throw),
            isFlowFinisher: true
          }).call(target, e2);
          return;
        }
        next(ret);
      }
      function onRejected(err) {
        let ret;
        try {
          ret = wrapInAction({
            nameOrNameFn: name2,
            fn: genThrow,
            actionType: ActionContextActionType.Async,
            overrideContext: ctxOverride(ActionContextAsyncStepType.ResumeError)
          }).call(target, err);
        } catch (e2) {
          wrapInAction({
            nameOrNameFn: name2,
            fn: (err2) => {
              return {
                value: err2,
                resolution: "reject",
                accepter: resolve,
                rejecter: reject
              };
            },
            actionType: ActionContextActionType.Async,
            overrideContext: ctxOverride(ActionContextAsyncStepType.Throw),
            isFlowFinisher: true
          }).call(target, e2);
          return;
        }
        next(ret);
      }
      function next(ret) {
        if (ret && typeof ret.then === "function") {
          ret.then(next, reject);
        } else if (ret.done) {
          wrapInAction({
            nameOrNameFn: name2,
            fn: (val) => {
              return {
                value: val,
                resolution: "accept",
                accepter: resolve,
                rejecter: reject
              };
            },
            actionType: ActionContextActionType.Async,
            overrideContext: ctxOverride(ActionContextAsyncStepType.Return),
            isFlowFinisher: true
          }).call(target, ret.value);
        } else {
          Promise.resolve(ret.value).then(onFulfilled, onRejected);
        }
      }
      onFulfilled(void 0);
    });
    return promise;
  };
  flowFn[modelFlowSymbol] = true;
  return flowFn;
}
function isModelFlow(fn) {
  return typeof fn === "function" && modelFlowSymbol in fn;
}
function modelFlow(target, propertyKey, baseDescriptor) {
  const { actionName, overrideContext } = getActionNameAndContextOverride(target, propertyKey);
  return decorateWrapMethodOrField("modelFlow", {
    target,
    propertyKey,
    baseDescriptor
  }, (data, fn) => {
    if (isModelFlow(fn)) {
      return fn;
    } else {
      checkModelFlowArgs(data.target, data.propertyKey, fn);
      return flow2({ nameOrNameFn: actionName, generator: fn, overrideContext });
    }
  });
}
function checkModelFlowArgs(target, propertyKey, value) {
  if (typeof value !== "function") {
    throw failure("modelFlow has to be used over functions");
  }
  checkModelDecoratorArgs("modelFlow", target, propertyKey);
}
function _async(fn) {
  return fn;
}
function _await(promise) {
  return promiseGenerator.call(promise);
}
const __generator$1 = function(thisArg, body) {
  let _2 = {
    label: 0,
    sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y2, t2, g2;
  return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function promiseGenerator() {
  let ret;
  return __generator$1(this, function(_a2) {
    switch (_a2.label) {
      case 0:
        return [4, this];
      case 1:
        ret = _a2.sent();
        return [2, ret];
      default:
        return;
    }
  });
}
const standaloneActionRegistry = /* @__PURE__ */ new Map();
function getStandaloneAction(actionName) {
  return standaloneActionRegistry.get(actionName);
}
function addStandaloneAction(fullActionName, fn, isFlow2) {
  assertIsFunction(fn, fullActionName);
  if (standaloneActionRegistry.has(fullActionName)) {
    logWarning("warn", `an standalone action with name "${fullActionName}" already exists (if you are using hot-reloading you may safely ignore this warning)`, `duplicateActionName - ${fullActionName}`);
  }
  if (isModelAction(fn)) {
    throw failure("the standalone action must not be previously marked as an action");
  }
  if (isModelFlow(fn)) {
    throw failure("the standalone action must not be previously marked as a flow action");
  }
  const wrappedAction = isFlow2 ? flow2({ nameOrNameFn: fullActionName, generator: fn }) : wrapInAction({
    nameOrNameFn: fullActionName,
    fn,
    actionType: ActionContextActionType.Sync
  });
  const finalAction = (target, ...args) => {
    assertIsTreeNode(target, "target");
    return wrappedAction.call(target, target, ...args);
  };
  standaloneActionRegistry.set(fullActionName, finalAction);
  return finalAction;
}
function applyDelete(node, fieldName) {
  assertTweakedObject(node, "node", true);
  wrappedInternalApplyDelete().call(node, fieldName);
}
function internalApplyDelete(fieldName) {
  remove$1(this, "" + fieldName);
}
const wrappedInternalApplyDelete = lazy(() => wrapInAction({
  nameOrNameFn: BuiltInAction.ApplyDelete,
  fn: internalApplyDelete,
  actionType: ActionContextActionType.Sync
}));
function applyMethodCall(node, methodName, ...args) {
  assertTweakedObject(node, "node");
  return wrappedInternalApplyMethodCall().call(node, methodName, args);
}
function internalApplyMethodCall(methodName, args) {
  return this[methodName](...args);
}
const wrappedInternalApplyMethodCall = lazy(() => wrapInAction({
  nameOrNameFn: BuiltInAction.ApplyMethodCall,
  fn: internalApplyMethodCall,
  actionType: ActionContextActionType.Sync
}));
function applySet(node, fieldName, value) {
  assertTweakedObject(node, "node", true);
  wrappedInternalApplySet().call(node, fieldName, value);
}
function internalApplySet(fieldName, value) {
  if (!isModel(this) && isObservable(this)) {
    setIfDifferent(this, fieldName, value);
  } else {
    this[fieldName] = value;
  }
}
const wrappedInternalApplySet = lazy(() => wrapInAction({
  nameOrNameFn: BuiltInAction.ApplySet,
  fn: internalApplySet,
  actionType: ActionContextActionType.Sync
}));
const builtInActionToFunction = {
  [BuiltInAction.ApplySnapshot]: applySnapshot,
  [BuiltInAction.ApplyPatches]: applyPatches,
  [BuiltInAction.Detach]: detach,
  [BuiltInAction.ApplySet]: applySet,
  [BuiltInAction.ApplyDelete]: applyDelete,
  [BuiltInAction.ApplyMethodCall]: applyMethodCall
};
function applyAction(subtreeRoot, call) {
  if (call.serialized) {
    throw failure("cannot apply a serialized action call, use one of the 'applySerializedAction' methods instead");
  }
  assertTweakedObject(subtreeRoot, "subtreeRoot");
  const { value: current, resolved } = resolvePathCheckingIds(subtreeRoot, call.targetPath, call.targetPathIds);
  if (!resolved) {
    throw failure(`object at path ${JSON.stringify(call.targetPath)} with ids ${JSON.stringify(call.targetPathIds)} could not be resolved`);
  }
  assertTweakedObject(current, `resolved ${current}`, true);
  if (isBuiltInAction(call.actionName)) {
    const fnToCall = builtInActionToFunction[call.actionName];
    if (!fnToCall) {
      throw failure(`assertion failed: unknown built-in action - ${call.actionName}`);
    }
    return fnToCall.apply(current, [current, ...call.args]);
  }
  if (isHookAction(call.actionName)) {
    throw failure(`calls to hooks (${call.actionName}) cannot be applied`);
  }
  const dataModelAction = getDataModelAction(call.actionName);
  if (dataModelAction) {
    const instance = new dataModelAction.modelClass(current);
    return instance[dataModelAction.fnName].apply(instance, call.args);
  }
  const standaloneAction2 = getStandaloneAction(call.actionName);
  if (standaloneAction2) {
    return standaloneAction2.apply(current, call.args);
  }
  return current[call.actionName].apply(current, call.args);
}
function checkModelActionArgs(target, propertyKey, value) {
  if (typeof value !== "function") {
    throw failure("modelAction has to be used over functions");
  }
  checkModelDecoratorArgs("modelAction", target, propertyKey);
}
function modelAction(target, propertyKey, baseDescriptor) {
  const { actionName, overrideContext } = getActionNameAndContextOverride(target, propertyKey);
  return decorateWrapMethodOrField("modelAction", {
    target,
    propertyKey,
    baseDescriptor
  }, (data, fn) => {
    if (isModelAction(fn)) {
      return fn;
    } else {
      checkModelActionArgs(data.target, data.propertyKey, fn);
      return wrapInAction({
        nameOrNameFn: actionName,
        fn,
        actionType: ActionContextActionType.Sync,
        overrideContext
      });
    }
  });
}
const cannotSerialize = Symbol("cannotSerialize");
const arraySerializer = {
  id: `${namespace$2}/array`,
  serialize(value, serialize) {
    if (!isArray$2(value))
      return cannotSerialize;
    return value.map(serialize);
  },
  deserialize(arr, deserialize) {
    return arr.map(deserialize);
  }
};
const dateSerializer = {
  id: `${namespace$2}/dateAsTimestamp`,
  serialize(date) {
    if (!(date instanceof Date))
      return cannotSerialize;
    return +date;
  },
  deserialize(timestamp) {
    return new Date(timestamp);
  }
};
const mapSerializer = {
  id: `${namespace$2}/mapAsArray`,
  serialize(map2, serialize) {
    if (!(map2 instanceof Map) && !isObservableMap(map2))
      return cannotSerialize;
    const arr = [];
    const iter = map2.keys();
    let cur = iter.next();
    while (!cur.done) {
      const k2 = cur.value;
      const v2 = map2.get(k2);
      arr.push([serialize(k2), serialize(v2)]);
      cur = iter.next();
    }
    return arr;
  },
  deserialize(arr, deserialize) {
    const map2 = /* @__PURE__ */ new Map();
    const len = arr.length;
    for (let i2 = 0; i2 < len; i2++) {
      const k2 = arr[i2][0];
      const v2 = arr[i2][1];
      map2.set(deserialize(k2), deserialize(v2));
    }
    return map2;
  }
};
function rootPathToTargetPathIds(rootPath) {
  var _a2;
  const targetPathIds = [];
  for (let i2 = 0; i2 < rootPath.path.length; i2++) {
    const targetObj = rootPath.pathObjects[i2 + 1];
    const targetObjId = isModel(targetObj) ? (_a2 = targetObj[modelIdKey]) != null ? _a2 : null : null;
    targetPathIds.push(targetObjId);
  }
  return targetPathIds;
}
function pathToTargetPathIds(root, path) {
  var _a2;
  const targetPathIds = [];
  let current = root;
  for (let i2 = 0; i2 < path.length; i2++) {
    current = current[path[i2]];
    const targetObjId = isModel(current) ? (_a2 = current[modelIdKey]) != null ? _a2 : null : null;
    targetPathIds.push(targetObjId);
  }
  return targetPathIds;
}
const objectPathSerializer = {
  id: `${namespace$2}/objectPath`,
  serialize(value, _2, targetRoot) {
    if (typeof value !== "object" || value === null || !isTweakedObject(value, false))
      return cannotSerialize;
    if (targetRoot) {
      const rootPath = fastGetRootPath(value);
      if (rootPath.root === targetRoot) {
        return {
          targetPath: rootPath.path,
          targetPathIds: rootPathToTargetPathIds(rootPath)
        };
      }
    }
    return cannotSerialize;
  },
  deserialize(ref, _2, targetRoot) {
    if (targetRoot) {
      const result = resolvePathCheckingIds(targetRoot, ref.targetPath, ref.targetPathIds);
      if (result.resolved) {
        return result.value;
      }
    }
    throw failure(`object at path ${JSON.stringify(ref.targetPath)} with ids ${JSON.stringify(ref.targetPathIds)} could not be resolved`);
  }
};
const objectSnapshotSerializer = {
  id: `${namespace$2}/objectSnapshot`,
  serialize(value) {
    if (typeof value !== "object" || value === null || !isTweakedObject(value, false))
      return cannotSerialize;
    return getSnapshot(value);
  },
  deserialize(snapshot) {
    return fromSnapshot(snapshot);
  }
};
const plainObjectSerializer = {
  id: `${namespace$2}/plainObject`,
  serialize(value, serialize) {
    if (!isPlainObject$3(value) && !isObservableObject(value))
      return cannotSerialize;
    return mapObjectFields(value, serialize);
  },
  deserialize(obj, serialize) {
    return mapObjectFields(obj, serialize);
  }
};
function mapObjectFields(originalObj, mapFn) {
  const obj = {};
  const keys2 = Object.keys(originalObj);
  const len = keys2.length;
  for (let i2 = 0; i2 < len; i2++) {
    const k2 = keys2[i2];
    const v2 = originalObj[k2];
    obj[k2] = mapFn(v2);
  }
  return obj;
}
const primitiveSerializer = {
  id: `${namespace$2}/primitiveAsString`,
  serialize(value) {
    if (Number.isNaN(value)) {
      return "nan";
    }
    switch (value) {
      case Infinity:
        return "+inf";
      case -Infinity:
        return "-inf";
    }
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (value === void 0) {
      return "undefined";
    }
    return cannotSerialize;
  },
  deserialize(str) {
    switch (str) {
      case "nan":
        return NaN;
      case "+inf":
        return Infinity;
      case "-inf":
        return -Infinity;
      case "undefined":
        return void 0;
      default:
        return BigInt(str);
    }
  }
};
const setSerializer = {
  id: `${namespace$2}/setAsArray`,
  serialize(set22, serialize) {
    if (!(set22 instanceof Set))
      return cannotSerialize;
    const arr = [];
    const iter = set22.keys();
    let cur = iter.next();
    while (!cur.done) {
      const k2 = cur.value;
      arr.push(serialize(k2));
      cur = iter.next();
    }
    return arr;
  },
  deserialize(arr, deserialize) {
    const set22 = /* @__PURE__ */ new Set();
    const len = arr.length;
    for (let i2 = 0; i2 < len; i2++) {
      const k2 = arr[i2];
      set22.add(deserialize(k2));
    }
    return set22;
  }
};
const serializersArray = [];
const serializersMap = /* @__PURE__ */ new Map();
function registerActionCallArgumentSerializer(serializer) {
  registerDefaultActionCallArgumentSerializers();
  if (serializersArray.includes(serializer)) {
    throw failure("action call argument serializer already registered");
  }
  if (serializersMap.has(serializer.id)) {
    throw failure(`action call argument serializer with id '${serializer.id}' already registered`);
  }
  serializersArray.unshift(serializer);
  serializersMap.set(serializer.id, serializer);
  return () => {
    const index2 = serializersArray.indexOf(serializer);
    if (index2 >= 0) {
      serializersArray.splice(index2, 1);
    }
    serializersMap.delete(serializer.id);
  };
}
function deserializeActionCallArgument(argValue, targetRoot) {
  registerDefaultActionCallArgumentSerializers();
  if (isJSONPrimitive(argValue)) {
    return argValue;
  }
  if (!isPlainObject$3(argValue) || typeof argValue.$mobxKeystoneSerializer !== "string") {
    throw failure("invalid serialized action call argument");
  }
  const serializerId = argValue.$mobxKeystoneSerializer;
  const serializer = serializersMap.get(serializerId);
  if (!serializer) {
    throw failure(`a serializer with id '${serializerId}' could not be found`);
  }
  const serializedValue = argValue;
  const deserialize = (v2) => deserializeActionCallArgument(v2, targetRoot);
  return serializer.deserialize(serializedValue.value, deserialize, targetRoot);
}
function deserializeActionCall(actionCall, targetRoot) {
  if (!actionCall.serialized) {
    throw failure("cannot deserialize a non-serialized action call");
  }
  if (targetRoot !== void 0) {
    assertTweakedObject(targetRoot, "targetRoot");
  }
  const deserialize = (v2) => deserializeActionCallArgument(v2, targetRoot);
  const deserializedActionCall = {
    ...actionCall,
    serialized: void 0,
    args: actionCall.args.map(deserialize)
  };
  delete deserializedActionCall.serialized;
  return deserializedActionCall;
}
let defaultActionCallArgumentSerializersRegistered = false;
function registerDefaultActionCallArgumentSerializers() {
  if (defaultActionCallArgumentSerializersRegistered) {
    return;
  }
  defaultActionCallArgumentSerializersRegistered = true;
  registerActionCallArgumentSerializer(primitiveSerializer);
  registerActionCallArgumentSerializer(plainObjectSerializer);
  registerActionCallArgumentSerializer(setSerializer);
  registerActionCallArgumentSerializer(mapSerializer);
  registerActionCallArgumentSerializer(dateSerializer);
  registerActionCallArgumentSerializer(arraySerializer);
  registerActionCallArgumentSerializer(objectSnapshotSerializer);
  registerActionCallArgumentSerializer(objectPathSerializer);
}
function applySerializedActionAndSyncNewModelIds(subtreeRoot, call) {
  if (!call.serialized) {
    throw failure("cannot apply a non-serialized action call, use 'applyAction' instead");
  }
  assertTweakedObject(subtreeRoot, "subtreeRoot");
  const deserializedCall = deserializeActionCall(call, subtreeRoot);
  let returnValue;
  runInAction(() => {
    returnValue = applyAction(subtreeRoot, deserializedCall);
    applyPatches(subtreeRoot, call.modelIdOverrides);
  });
  return returnValue;
}
var ActionTrackingResult;
(function(ActionTrackingResult2) {
  ActionTrackingResult2["Return"] = "return";
  ActionTrackingResult2["Throw"] = "throw";
})(ActionTrackingResult || (ActionTrackingResult = {}));
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function typesObjectHelper(objFn, frozen2, typeInfoGen) {
  assertIsFunction(objFn, "objFn");
  return lateTypeChecker(() => {
    const objectSchema = objFn();
    assertIsObject(objectSchema, "objectSchema");
    const schemaEntries = Object.entries(objectSchema);
    const getTypeName = (...recursiveTypeCheckers) => {
      const propsMsg = [];
      for (const [k2, unresolvedTc] of schemaEntries) {
        const tc2 = resolveTypeChecker(unresolvedTc);
        let propTypename = "...";
        if (!recursiveTypeCheckers.includes(tc2)) {
          propTypename = tc2.getTypeName(...recursiveTypeCheckers, tc2);
        }
        propsMsg.push(`${k2}: ${propTypename};`);
      }
      return `{ ${propsMsg.join(" ")} }`;
    };
    const applySnapshotProcessor = (obj, mode) => {
      const newObj = {};
      const keys2 = Object.keys(obj);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const k2 = keys2[i2];
        const unresolvedTc = objectSchema[k2];
        if (unresolvedTc) {
          const tc2 = resolveTypeChecker(unresolvedTc);
          newObj[k2] = mode === "from" ? tc2.fromSnapshotProcessor(obj[k2]) : tc2.toSnapshotProcessor(obj[k2]);
        } else {
          newObj[k2] = obj[k2];
        }
      }
      return newObj;
    };
    const thisTc = new TypeChecker(TypeCheckerBaseType.Object, (obj, path, typeCheckedValue) => {
      if (!isObject$1(obj) || frozen2 && !(obj instanceof Frozen)) {
        return new TypeCheckError(path, getTypeName(thisTc), obj, typeCheckedValue);
      }
      for (const [k2, unresolvedTc] of schemaEntries) {
        const tc2 = resolveTypeChecker(unresolvedTc);
        const objVal = obj[k2];
        const valueError = tc2.check(objVal, [...path, k2], typeCheckedValue);
        if (valueError) {
          return valueError;
        }
      }
      return null;
    }, getTypeName, typeInfoGen, (obj) => {
      if (!isObject$1(obj)) {
        return null;
      }
      for (const [k2, unresolvedTc] of schemaEntries) {
        const tc2 = resolveTypeChecker(unresolvedTc);
        const objVal = obj[k2];
        const valueActualChecker = tc2.snapshotType(objVal);
        if (!valueActualChecker) {
          return null;
        }
      }
      return thisTc;
    }, (obj) => {
      return applySnapshotProcessor(obj, "from");
    }, (obj) => {
      return applySnapshotProcessor(obj, "to");
    });
    return thisTc;
  }, typeInfoGen);
}
function typesObject(objectFunction) {
  const typeInfoGen = (t2) => new ObjectTypeInfo(t2, objectFunction);
  return typesObjectHelper(objectFunction, false, typeInfoGen);
}
class ObjectTypeInfo extends TypeInfo {
  constructor(thisType, _objTypeFn) {
    super(thisType);
    __publicField(this, "_objTypeFn");
    __publicField(this, "_props", lazy(() => {
      const objSchema = this._objTypeFn();
      const propTypes = {};
      Object.keys(objSchema).forEach((propName) => {
        const type = resolveStandardType(objSchema[propName]);
        propTypes[propName] = { type, typeInfo: getTypeInfo(type) };
      });
      return propTypes;
    }));
    this._objTypeFn = _objTypeFn;
  }
  get props() {
    return this._props();
  }
}
const unchecked = new TypeChecker(TypeCheckerBaseType.Any, null, () => "any", (t2) => new UncheckedTypeInfo(t2), () => unchecked, identityFn, identityFn);
function typesUnchecked() {
  return unchecked;
}
class UncheckedTypeInfo extends TypeInfo {
}
function typesOr(dispatcherOrType, ...moreOrTypes) {
  const orTypes = moreOrTypes.slice();
  let finalDispatcher;
  const firstTypeChecker = resolveStandardTypeNoThrow(dispatcherOrType);
  if (firstTypeChecker) {
    orTypes.unshift(firstTypeChecker);
  } else {
    const dispatcher = dispatcherOrType;
    finalDispatcher = (sn) => {
      const type = dispatcher(sn);
      const typeChecker = resolveTypeChecker(type);
      return typeChecker;
    };
  }
  if (orTypes.length <= 0) {
    throw failure("or type must have at least 1 possible type");
  }
  const typeInfoGen = (t2) => new OrTypeInfo(t2, orTypes.map(resolveStandardType));
  return lateTypeChecker(() => {
    const checkers = orTypes.map(resolveTypeChecker);
    if (checkers.some((tc2) => tc2.unchecked)) {
      return typesUnchecked();
    }
    const getTypeName = (...recursiveTypeCheckers) => {
      const typeNames = checkers.map((tc2) => {
        if (recursiveTypeCheckers.includes(tc2)) {
          return "...";
        }
        return tc2.getTypeName(...recursiveTypeCheckers, tc2);
      });
      return typeNames.join(" | ");
    };
    let thisTcBaseType;
    if (checkers.some((c2) => c2.baseType !== checkers[0].baseType)) {
      thisTcBaseType = TypeCheckerBaseType.Any;
    } else {
      thisTcBaseType = checkers[0].baseType;
    }
    const thisTc = new TypeChecker(thisTcBaseType, (value, path, typeCheckedValue) => {
      const someMatchingType = checkers.some((tc2) => !tc2.check(value, path, typeCheckedValue));
      if (someMatchingType) {
        return null;
      } else {
        return new TypeCheckError(path, getTypeName(thisTc), value, typeCheckedValue);
      }
    }, getTypeName, typeInfoGen, (value) => {
      const valueBaseType = getTypeCheckerBaseTypeFromValue(value);
      const checkerForBaseType = checkers.filter((c2) => c2.baseType === valueBaseType || c2.baseType === TypeCheckerBaseType.Any);
      if (checkerForBaseType.length === 1 && checkerForBaseType[0].baseType === valueBaseType) {
        return checkerForBaseType[0];
      }
      for (let i2 = 0; i2 < checkerForBaseType.length; i2++) {
        const matchingType = checkerForBaseType[i2].snapshotType(value);
        if (matchingType) {
          return matchingType;
        }
      }
      return null;
    }, (sn) => {
      const type = finalDispatcher ? finalDispatcher(sn) : thisTc.snapshotType(sn);
      if (!type) {
        throw failure(`snapshot '${JSON.stringify(sn)}' does not match the following type: ${getTypeName(thisTc)}`);
      }
      return type.fromSnapshotProcessor(sn);
    }, (sn) => {
      const type = finalDispatcher ? finalDispatcher(sn) : thisTc.snapshotType(sn);
      if (!type) {
        throw failure(`snapshot '${JSON.stringify(sn)}' does not match the following type: ${getTypeName(thisTc)}`);
      }
      return type.toSnapshotProcessor(sn);
    });
    return thisTc;
  }, typeInfoGen);
}
class OrTypeInfo extends TypeInfo {
  constructor(thisType, orTypes) {
    super(thisType);
    __publicField(this, "orTypes");
    __publicField(this, "_orTypeInfos", lazy(() => this.orTypes.map(getTypeInfo)));
    this.orTypes = orTypes;
  }
  get orTypeInfos() {
    return this._orTypeInfos();
  }
}
const noDefaultValueSymbol = Symbol("noDefaultValue");
const tPropCache = /* @__PURE__ */ new WeakMap();
function getOrCreateTProp(type, defKey, createTProp) {
  let defValueCache = tPropCache.get(type);
  if (!defValueCache) {
    defValueCache = /* @__PURE__ */ new Map();
    tPropCache.set(type, defValueCache);
  }
  let prop2 = defValueCache.get(defKey);
  if (!prop2) {
    prop2 = createTProp();
    defValueCache.set(defKey, prop2);
  }
  return prop2;
}
function tProp(typeOrDefaultValue, def) {
  switch (typeof typeOrDefaultValue) {
    case "string":
      return tProp(typesString, typeOrDefaultValue);
    case "number":
      return tProp(typesNumber, typeOrDefaultValue);
    case "boolean":
      return tProp(typesBoolean, typeOrDefaultValue);
  }
  const hasDefaultValue = arguments.length >= 2;
  const typeChecker = resolveStandardType(typeOrDefaultValue);
  return getOrCreateTProp(typeChecker, hasDefaultValue ? def : noDefaultValueSymbol, () => {
    const fromSnapshotTypeChecker = hasDefaultValue ? typesOr(typeChecker, typesUndefined, typesNull) : typeChecker;
    const newProp = Object.create(hasDefaultValue ? prop(def) : prop());
    Object.assign(newProp, {
      _typeChecker: typeChecker,
      _fromSnapshotProcessor: tPropFromSnapshotProcessor.bind(void 0, fromSnapshotTypeChecker),
      _toSnapshotProcessor: tPropToSnapshotProcessor.bind(void 0, typeChecker)
    });
    return newProp;
  });
}
function tPropFromSnapshotProcessor(fromSnapshotTypeChecker, sn) {
  const fsnp = resolveTypeChecker(fromSnapshotTypeChecker).fromSnapshotProcessor;
  return fsnp ? fsnp(sn) : sn;
}
function tPropToSnapshotProcessor(typeChecker, sn) {
  const tsnp = resolveTypeChecker(typeChecker).toSnapshotProcessor;
  return tsnp ? tsnp(sn) : sn;
}
function chainFns(...fns) {
  const definedFns = fns.filter((fn) => !!fn);
  if (definedFns.length <= 0)
    return void 0;
  const chainedFn = (v2, ...args) => {
    let ret = v2;
    for (let i2 = 0; i2 < definedFns.length; i2++) {
      ret = definedFns[i2](ret, ...args);
    }
    return ret;
  };
  return chainedFn;
}
function assertIsClassOrDataModelClass(model2, argName, customErrMsg = "must be a class or data model class") {
  if (!isModelClass(model2) && !isDataModelClass(model2)) {
    throw failure(`${argName} ${customErrMsg}`);
  }
}
function getModelInstanceDataField(model2, modelProp, modelPropName) {
  const value = model2.$[modelPropName];
  if (!modelProp._transform) {
    return value;
  }
  return modelProp._transform.transform(value, model2, modelPropName, (newValue) => {
    applySet(model2.$, modelPropName, newValue);
  });
}
function setModelInstanceDataField(model2, modelProp, modelPropName, value) {
  if (!(modelInitializedSymbol in model2)) {
    return;
  }
  if (modelProp._setter === "assign" && !getCurrentActionContext()) {
    applySet(model2, modelPropName, value);
    return;
  }
  let untransformedValue = modelProp._transform ? modelProp._transform.untransform(value, model2, modelPropName) : value;
  if (untransformedValue == null) {
    const defaultValue = getModelPropDefaultValue(modelProp);
    if (defaultValue !== noDefaultValue) {
      untransformedValue = defaultValue;
    }
  }
  model2.$[modelPropName] = untransformedValue;
}
const idGenerator = () => getGlobalConfig().modelIdGenerator();
const tPropForId = tProp(typesString, idGenerator);
tPropForId._isId = true;
const propForId = prop(idGenerator);
propForId._isId = true;
function sharedInternalModel({ modelProps, baseModel, type, valueType, fromSnapshotProcessor, toSnapshotProcessor }) {
  assertIsObject(modelProps, "modelProps");
  modelProps = Object.assign(/* @__PURE__ */ Object.create(null), modelProps);
  if (baseModel) {
    assertIsClassOrDataModelClass(baseModel, "baseModel");
    const unwrappedClass = baseModel[modelUnwrappedClassSymbol];
    if (unwrappedClass) {
      baseModel = unwrappedClass;
      assertIsClassOrDataModelClass(baseModel, "baseModel");
    }
  }
  const composedModelProps = modelProps;
  if (baseModel) {
    const oldModelProps = getInternalModelClassPropsInfo(baseModel);
    for (const oldModelPropKey of Object.keys(oldModelProps)) {
      if (!modelProps[oldModelPropKey]) {
        composedModelProps[oldModelPropKey] = oldModelProps[oldModelPropKey];
      }
    }
  }
  const idKeys = Object.keys(composedModelProps).filter((k2) => {
    const p2 = composedModelProps[k2];
    return p2._isId;
  });
  if (type === "class") {
    if (idKeys.length > 1) {
      throw failure(`expected at most one idProp but got many: ${JSON.stringify(idKeys)}`);
    }
  } else {
    if (idKeys.length >= 1) {
      throw failure(`expected no idProp but got some: ${JSON.stringify(idKeys)}`);
    }
  }
  const needsTypeChecker = Object.values(composedModelProps).some((mp) => !!mp._typeChecker);
  let idKey;
  if (idKeys.length >= 1) {
    idKey = idKeys[0];
    const idProp2 = composedModelProps[idKey];
    let baseProp2 = needsTypeChecker ? tPropForId : propForId;
    switch (idProp2 == null ? void 0 : idProp2._setter) {
      case true:
        baseProp2 = baseProp2.withSetter();
        break;
      case "assign":
        baseProp2 = baseProp2.withSetter("assign");
        break;
    }
    composedModelProps[idKey] = baseProp2;
  }
  let dataTypeChecker;
  if (needsTypeChecker) {
    const typeCheckerObj = {};
    for (const [k2, mp] of Object.entries(composedModelProps)) {
      typeCheckerObj[k2] = !mp._typeChecker ? typesUnchecked() : mp._typeChecker;
    }
    dataTypeChecker = typesObject(() => typeCheckerObj);
  }
  const base = baseModel != null ? baseModel : type === "class" ? BaseModel : BaseDataModel;
  const basePropNames = type === "class" ? baseModelPropNames : baseDataModelPropNames;
  let propsToDeleteFromBase;
  function ThisModel(initialData, constructorOptions) {
    var _a2;
    const modelClass2 = (_a2 = constructorOptions == null ? void 0 : constructorOptions.modelClass) != null ? _a2 : this.constructor;
    const baseModel2 = new base(initialData, {
      ...constructorOptions,
      modelClass: modelClass2
    });
    if (!propsToDeleteFromBase) {
      propsToDeleteFromBase = Object.keys(composedModelProps).filter((p2) => !basePropNames.has(p2) && Object.hasOwn(baseModel2, p2));
    }
    propsToDeleteFromBase.forEach((prop2) => delete baseModel2[prop2]);
    return baseModel2;
  }
  Object.assign(ThisModel, base);
  const initializers = base[modelInitializersSymbol];
  if (initializers) {
    ThisModel[modelInitializersSymbol] = initializers.slice();
  }
  setInternalModelClassPropsInfo(ThisModel, composedModelProps);
  if (type === "class") {
    const metadata = {
      dataType: dataTypeChecker,
      modelIdProperty: idKey,
      valueType
    };
    ThisModel[modelMetadataSymbol] = metadata;
  } else {
    const metadata = {
      dataType: dataTypeChecker
    };
    ThisModel[modelMetadataSymbol] = metadata;
  }
  const newPrototype = Object.create(base.prototype);
  ThisModel.prototype = new Proxy(newPrototype, {
    get(target, p2, receiver) {
      if (receiver === ThisModel.prototype) {
        return target[p2];
      }
      const modelProp = !basePropNames.has(p2) && composedModelProps[p2];
      return modelProp ? getModelInstanceDataField(receiver, modelProp, p2) : Reflect.get(target, p2, receiver);
    },
    set(target, p2, v2, receiver) {
      if (receiver === ThisModel.prototype) {
        target[p2] = v2;
        return true;
      }
      const modelProp = !basePropNames.has(p2) && composedModelProps[p2];
      if (modelProp) {
        setModelInstanceDataField(receiver, modelProp, p2, v2);
        return true;
      }
      return Reflect.set(target, p2, v2, receiver);
    },
    has(target, p2) {
      const modelProp = !basePropNames.has(p2) && composedModelProps[p2];
      return !!modelProp || Reflect.has(target, p2);
    }
  });
  newPrototype.constructor = ThisModel;
  for (const [propName, propData] of Object.entries(modelProps)) {
    if (propData._setter === true) {
      const setterName = propNameToSetterName(propName);
      const newPropDescriptor = modelAction(newPrototype, setterName, {
        value: function(value) {
          this[propName] = value;
        },
        writable: true,
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(newPrototype, setterName, newPropDescriptor);
    }
  }
  const modelPropsFromSnapshotProcessor = getModelPropsFromSnapshotProcessor(composedModelProps);
  const modelPropsToSnapshotProcessor = getModelPropsToSnapshotProcessor(composedModelProps);
  if (fromSnapshotProcessor) {
    const fn = fromSnapshotProcessor;
    fromSnapshotProcessor = (sn) => {
      return {
        ...fn(sn),
        [modelTypeKey]: sn[modelTypeKey]
      };
    };
  }
  if (toSnapshotProcessor) {
    const fn = toSnapshotProcessor;
    toSnapshotProcessor = (sn, modelInstance) => {
      return {
        ...fn(sn, modelInstance),
        [modelTypeKey]: sn[modelTypeKey]
      };
    };
  }
  ThisModel.fromSnapshotProcessor = chainFns(fromSnapshotProcessor, modelPropsFromSnapshotProcessor);
  ThisModel.toSnapshotProcessor = chainFns(modelPropsToSnapshotProcessor, toSnapshotProcessor);
  return ThisModel;
}
function getModelPropsFromSnapshotProcessor(composedModelProps) {
  const propsWithFromSnapshotProcessor = Object.entries(composedModelProps).filter(([_propName, propData]) => propData._fromSnapshotProcessor);
  if (propsWithFromSnapshotProcessor.length <= 0) {
    return void 0;
  }
  return (sn) => {
    const newSn = { ...sn };
    for (const [propName, propData] of propsWithFromSnapshotProcessor) {
      if (propData._fromSnapshotProcessor) {
        newSn[propName] = propData._fromSnapshotProcessor(sn[propName]);
      }
    }
    return newSn;
  };
}
function getModelPropsToSnapshotProcessor(composedModelProps) {
  const propsWithToSnapshotProcessor = Object.entries(composedModelProps).filter(([_propName, propData]) => propData._toSnapshotProcessor);
  if (propsWithToSnapshotProcessor.length <= 0) {
    return void 0;
  }
  return (sn) => {
    const newSn = { ...sn };
    for (const [propName, propData] of propsWithToSnapshotProcessor) {
      if (propData._toSnapshotProcessor) {
        newSn[propName] = propData._toSnapshotProcessor(sn[propName]);
      }
    }
    return newSn;
  };
}
function Model(fnModelPropsOrModelProps, modelOptions) {
  const modelProps = typeof fnModelPropsOrModelProps === "function" ? fnModelPropsOrModelProps() : fnModelPropsOrModelProps;
  return internalModel$1(modelProps, void 0, modelOptions);
}
function internalModel$1(modelProps, baseModel, modelOptions) {
  var _a2;
  return sharedInternalModel({
    modelProps,
    baseModel,
    type: "class",
    valueType: (_a2 = modelOptions == null ? void 0 : modelOptions.valueType) != null ? _a2 : false,
    fromSnapshotProcessor: modelOptions == null ? void 0 : modelOptions.fromSnapshotProcessor,
    toSnapshotProcessor: modelOptions == null ? void 0 : modelOptions.toSnapshotProcessor
  });
}
const model = (name2) => (clazz) => {
  return internalModel(name2)(clazz);
};
const proxyClassHandlerTag = /* @__PURE__ */ new WeakMap();
const proxyClassHandler = {
  construct(target, args) {
    const instance = new target(...args);
    runLateInitializationFunctions(instance, runAfterNewSymbol);
    const tag2 = proxyClassHandlerTag.get(target);
    if (!tag2.makeObservableFailed && getMobxVersion() >= 6) {
      try {
        mobx6.makeObservable(instance);
      } catch (e2) {
        tag2.makeObservableFailed = true;
        const err = e2;
        if (err.message !== "[MobX] No annotations were passed to makeObservable, but no decorator members have been found either" && err.message !== "[MobX] No annotations were passed to makeObservable, but no decorated members have been found either") {
          throw err;
        }
      }
    }
    addHiddenProp(instance, modelInitializedSymbol, true, false);
    runLateInitializationFunctions(instance, runBeforeOnInitSymbol);
    if (tag2.type === "class" && instance.onInit) {
      wrapModelMethodInActionIfNeeded(instance, "onInit", HookAction.OnInit);
      instance.onInit();
    }
    if (tag2.type === "data" && instance.onLazyInit) {
      wrapModelMethodInActionIfNeeded(instance, "onLazyInit", HookAction.OnLazyInit);
      instance.onLazyInit();
    }
    return instance;
  }
};
const internalModel = (name2) => (clazz) => {
  const type = isModelClass(clazz) ? "class" : isDataModelClass(clazz) ? "data" : void 0;
  if (!type) {
    throw failure(`clazz must be a class that extends from Model/DataModel`);
  }
  if (modelInfoByName[name2]) {
    if (getGlobalConfig().showDuplicateModelNameWarnings) {
      logWarning("warn", `a model with name "${name2}" already exists (if you are using hot-reloading you may safely ignore this warning)`, `duplicateModelName - ${name2}`);
    }
  }
  if (modelUnwrappedClassSymbol in clazz && clazz[modelUnwrappedClassSymbol] === clazz) {
    throw failure("a class already decorated with `@model` cannot be re-decorated");
  }
  proxyClassHandlerTag.set(clazz, { makeObservableFailed: false, type });
  const proxyClass = new Proxy(clazz, proxyClassHandler);
  clazz.toString = () => `class ${clazz.name}#${name2}`;
  if (type === "class") {
    clazz[modelTypeKey] = name2;
  }
  proxyClass.prototype.constructor = proxyClass;
  proxyClass[modelUnwrappedClassSymbol] = clazz;
  const modelInfo = {
    name: name2,
    class: proxyClass
  };
  modelInfoByName[name2] = modelInfo;
  modelInfoByClass.set(proxyClass, modelInfo);
  modelInfoByClass.set(clazz, modelInfo);
  runLateInitializationFunctions(clazz, runAfterModelDecoratorSymbol);
  return proxyClass;
};
function typesArray(itemType) {
  const typeInfoGen = (t2) => new ArrayTypeInfo(t2, resolveStandardType(itemType));
  return lateTypeChecker(() => {
    const itemChecker = resolveTypeChecker(itemType);
    const getTypeName = (...recursiveTypeCheckers) => `Array<${itemChecker.getTypeName(...recursiveTypeCheckers, itemChecker)}>`;
    const thisTc = new TypeChecker(TypeCheckerBaseType.Array, (array2, path, typeCheckedValue) => {
      if (!isArray$2(array2)) {
        return new TypeCheckError(path, getTypeName(thisTc), array2, typeCheckedValue);
      }
      if (!itemChecker.unchecked) {
        for (let i2 = 0; i2 < array2.length; i2++) {
          const itemError = itemChecker.check(array2[i2], [...path, i2], typeCheckedValue);
          if (itemError) {
            return itemError;
          }
        }
      }
      return null;
    }, getTypeName, typeInfoGen, (array2) => {
      if (!isArray$2(array2)) {
        return null;
      }
      if (!itemChecker.unchecked) {
        for (let i2 = 0; i2 < array2.length; i2++) {
          const itemActualChecker = itemChecker.snapshotType(array2[i2]);
          if (!itemActualChecker) {
            return null;
          }
        }
      }
      return thisTc;
    }, (sn) => {
      if (itemChecker.unchecked) {
        return sn;
      }
      return sn.map((item) => itemChecker.fromSnapshotProcessor(item));
    }, (sn) => {
      if (itemChecker.unchecked) {
        return sn;
      }
      return sn.map((item) => itemChecker.toSnapshotProcessor(item));
    });
    return thisTc;
  }, typeInfoGen);
}
class ArrayTypeInfo extends TypeInfo {
  constructor(thisType, itemType) {
    super(thisType);
    __publicField(this, "itemType");
    this.itemType = itemType;
  }
  get itemTypeInfo() {
    return getTypeInfo(this.itemType);
  }
}
var UndoEventType;
(function(UndoEventType2) {
  UndoEventType2["Single"] = "single";
  UndoEventType2["Group"] = "group";
})(UndoEventType || (UndoEventType = {}));
function toSingleEvents(event, reverse2) {
  if (event.type === UndoEventType.Single)
    return [event];
  else {
    const array2 = [];
    for (const e2 of event.events) {
      if (reverse2) {
        array2.unshift(...toSingleEvents(e2, true));
      } else {
        array2.push(...toSingleEvents(e2, false));
      }
    }
    return array2;
  }
}
let UndoStore = class UndoStore2 extends Model({
  // TODO: add proper type checking to undo store
  undoEvents: tProp(typesArray(typesUnchecked()), () => []),
  redoEvents: tProp(typesArray(typesUnchecked()), () => [])
}) {
  constructor() {
    super(...arguments);
    __publicField(this, "_groupStack", []);
  }
  /**
   * @ignore
   */
  _clearUndo() {
    withoutUndo(() => {
      this.undoEvents.length = 0;
    });
  }
  /**
   * @ignore
   */
  _clearRedo() {
    withoutUndo(() => {
      this.redoEvents.length = 0;
    });
  }
  /**
   * @ignore
   */
  enforceMaxLevels({ maxUndoLevels, maxRedoLevels }) {
    if (maxUndoLevels !== void 0) {
      while (this.undoEvents.length > maxUndoLevels) {
        this.undoEvents.shift();
      }
    }
    if (maxRedoLevels !== void 0) {
      while (this.redoEvents.length > maxRedoLevels) {
        this.redoEvents.shift();
      }
    }
  }
  /**
   * @ignore
   */
  _undo({ maxRedoLevels }) {
    withoutUndo(() => {
      const event = this.undoEvents.pop();
      this.redoEvents.push(event);
      this.enforceMaxLevels({ maxRedoLevels });
    });
  }
  /**
   * @ignore
   */
  _redo({ maxUndoLevels }) {
    withoutUndo(() => {
      const event = this.redoEvents.pop();
      this.undoEvents.push(event);
      this.enforceMaxLevels({ maxUndoLevels });
    });
  }
  /**
   * @ignore
   */
  _addUndo({ event, maxUndoLevels }) {
    withoutUndo(() => {
      this.undoEvents.push(event);
      this.redoEvents.length = 0;
      this.enforceMaxLevels({ maxUndoLevels });
    });
  }
  /**
   * @ignore
   */
  _addUndoToParentGroup(parentGroup, event) {
    parentGroup.events.push(event);
  }
  /**
   * @ignore
   */
  get _currentGroup() {
    return this._groupStack[this._groupStack.length - 1];
  }
  /**
   * @ignore
   */
  _startGroup(groupName, startRunning, options) {
    var _a2;
    let running = false;
    let ended = false;
    const parentGroup = this._currentGroup;
    const group = {
      type: UndoEventType.Group,
      groupName,
      events: []
    };
    const attachedStateBeforeEvent = parentGroup ? void 0 : (_a2 = options == null ? void 0 : options.attachedState) == null ? void 0 : _a2.save();
    const api2 = {
      pause: () => {
        if (ended) {
          throw failure("cannot pause a group when it is already ended");
        }
        if (!running) {
          throw failure("cannot pause a group when it is not running");
        }
        if (this._currentGroup !== group) {
          throw failure("group out of order");
        }
        this._groupStack.pop();
        running = false;
      },
      resume: () => {
        if (ended) {
          throw failure("cannot resume a group when it is already ended");
        }
        if (running) {
          throw failure("cannot resume a group when it is already running");
        }
        this._groupStack.push(group);
        running = true;
      },
      end: () => {
        var _a3;
        if (running) {
          api2.pause();
        }
        ended = true;
        if (parentGroup) {
          this._addUndoToParentGroup(parentGroup, group);
        } else {
          this._addUndo({
            event: {
              ...group,
              attachedState: {
                beforeEvent: attachedStateBeforeEvent,
                afterEvent: (_a3 = options == null ? void 0 : options.attachedState) == null ? void 0 : _a3.save()
              }
            },
            maxUndoLevels: options == null ? void 0 : options.maxUndoLevels
          });
        }
      }
    };
    if (startRunning) {
      api2.resume();
    }
    return api2;
  }
};
__decorate([
  modelAction
], UndoStore.prototype, "_clearUndo", null);
__decorate([
  modelAction
], UndoStore.prototype, "_clearRedo", null);
__decorate([
  modelAction
], UndoStore.prototype, "_undo", null);
__decorate([
  modelAction
], UndoStore.prototype, "_redo", null);
__decorate([
  modelAction
], UndoStore.prototype, "_addUndo", null);
UndoStore = __decorate([
  model(`${namespace$2}/UndoStore`)
], UndoStore);
class UndoManager {
  /**
   * Creates an instance of `UndoManager`.
   * Do not use directly, use `undoMiddleware` instead.
   *
   * @param disposer
   * @param subtreeRoot
   * @param [store]
   */
  constructor(disposer, subtreeRoot, store, options) {
    __publicField(this, "disposer");
    __publicField(this, "subtreeRoot");
    __publicField(this, "options");
    __publicField(this, "store");
    __publicField(this, "_isUndoRecordingDisabled", false);
    this.disposer = disposer;
    this.subtreeRoot = subtreeRoot;
    this.options = options;
    if (getMobxVersion() >= 6) {
      mobx6.makeObservable(this);
    }
    this.store = store != null ? store : new UndoStore({});
  }
  /**
   * The undo stack, where the first operation to undo will be the last of the array.
   * Do not manipulate this array directly.
   */
  get undoQueue() {
    return this.store.undoEvents;
  }
  /**
   * The redo stack, where the first operation to redo will be the last of the array.
   * Do not manipulate this array directly.
   */
  get redoQueue() {
    return this.store.redoEvents;
  }
  /**
   * The number of undo actions available.
   */
  get undoLevels() {
    return this.undoQueue.length;
  }
  /**
   * If undo can be performed (if there is at least one undo action available).
   */
  get canUndo() {
    return this.undoLevels > 0;
  }
  /**
   * Clears the undo queue.
   */
  clearUndo() {
    this.store._clearUndo();
  }
  /**
   * The number of redo actions available.
   */
  get redoLevels() {
    return this.redoQueue.length;
  }
  /**
   * If redo can be performed (if there is at least one redo action available)
   */
  get canRedo() {
    return this.redoLevels > 0;
  }
  /**
   * Clears the redo queue.
   */
  clearRedo() {
    this.store._clearRedo();
  }
  /**
   * Undoes the last action.
   * Will throw if there is no action to undo.
   */
  undo() {
    var _a2;
    if (!this.canUndo) {
      throw failure("nothing to undo");
    }
    const event = this.undoQueue[this.undoQueue.length - 1];
    withoutUndo(() => {
      var _a3, _b2, _c2;
      toSingleEvents(event, true).forEach((e2) => {
        applyPatches(this.subtreeRoot, e2.inversePatches, true);
      });
      if ((_a3 = event.attachedState) == null ? void 0 : _a3.beforeEvent) {
        (_c2 = (_b2 = this.options) == null ? void 0 : _b2.attachedState) == null ? void 0 : _c2.restore(event.attachedState.beforeEvent);
      }
    });
    this.store._undo({ maxRedoLevels: (_a2 = this.options) == null ? void 0 : _a2.maxRedoLevels });
  }
  /**
   * Redoes the previous action.
   * Will throw if there is no action to redo.
   */
  redo() {
    var _a2;
    if (!this.canRedo) {
      throw failure("nothing to redo");
    }
    const event = this.redoQueue[this.redoQueue.length - 1];
    withoutUndo(() => {
      var _a3, _b2, _c2;
      toSingleEvents(event, false).forEach((e2) => {
        applyPatches(this.subtreeRoot, e2.patches);
      });
      if ((_a3 = event.attachedState) == null ? void 0 : _a3.afterEvent) {
        (_c2 = (_b2 = this.options) == null ? void 0 : _b2.attachedState) == null ? void 0 : _c2.restore(event.attachedState.afterEvent);
      }
    });
    this.store._redo({ maxUndoLevels: (_a2 = this.options) == null ? void 0 : _a2.maxUndoLevels });
  }
  /**
   * Disposes the undo middleware.
   */
  dispose() {
    this.disposer();
  }
  /**
   * Returns if undo recording is currently disabled or not for this particular `UndoManager`.
   */
  get isUndoRecordingDisabled() {
    return this._isUndoRecordingDisabled;
  }
  /**
   * Skips the undo recording mechanism for the code block that gets run synchronously inside.
   *
   * @typeparam T Code block return type.
   * @param fn Code block to run.
   * @returns The value returned by the code block.
   */
  withoutUndo(fn) {
    const savedUndoDisabled = this._isUndoRecordingDisabled;
    this._isUndoRecordingDisabled = true;
    try {
      return fn();
    } finally {
      this._isUndoRecordingDisabled = savedUndoDisabled;
    }
  }
  /**
   * Creates a custom group that can be continued multiple times and then ended.
   * @param groupName Optional group name.
   * @returns An API to continue/end the group.
   */
  createGroup(groupName) {
    const group = this.store._startGroup(groupName, false, this.options);
    return {
      continue(fn) {
        group.resume();
        try {
          return fn();
        } finally {
          group.pause();
        }
      },
      end() {
        group.end();
      }
    };
  }
  withGroup(arg1, arg2) {
    let groupName;
    let fn;
    if (typeof arg1 === "string") {
      groupName = arg1;
      fn = arg2;
    } else {
      fn = arg1;
    }
    const group = this.store._startGroup(groupName, true, this.options);
    try {
      return fn();
    } finally {
      group.end();
    }
  }
  withGroupFlow(arg1, arg2) {
    let groupName;
    let fn;
    if (typeof arg1 === "string") {
      groupName = arg1;
      fn = arg2;
    } else {
      fn = arg1;
    }
    const gen = fn();
    const group = this.store._startGroup(groupName, false, this.options);
    const genNext = gen.next.bind(gen);
    const genThrow = gen.throw.bind(gen);
    const promise = new Promise(function(resolve, reject) {
      function onFulfilled(res) {
        group.resume();
        let ret;
        try {
          ret = genNext(res);
        } catch (e2) {
          group.end();
          reject(e2);
          return;
        }
        group.pause();
        next(ret);
      }
      function onRejected(err) {
        group.resume();
        let ret;
        try {
          ret = genThrow(err);
        } catch (e2) {
          group.end();
          reject(e2);
          return;
        }
        group.pause();
        next(ret);
      }
      function next(ret) {
        if (ret && typeof ret.then === "function") {
          ret.then(next, reject);
        } else if (ret.done) {
          group.end();
          resolve(ret.value);
        } else {
          Promise.resolve(ret.value).then(onFulfilled, onRejected);
        }
      }
      onFulfilled(void 0);
    });
    return promise;
  }
}
__decorate([
  computed
], UndoManager.prototype, "undoQueue", null);
__decorate([
  computed
], UndoManager.prototype, "redoQueue", null);
__decorate([
  computed
], UndoManager.prototype, "undoLevels", null);
__decorate([
  computed
], UndoManager.prototype, "canUndo", null);
__decorate([
  action
], UndoManager.prototype, "clearUndo", null);
__decorate([
  computed
], UndoManager.prototype, "redoLevels", null);
__decorate([
  computed
], UndoManager.prototype, "canRedo", null);
__decorate([
  action
], UndoManager.prototype, "clearRedo", null);
__decorate([
  action
], UndoManager.prototype, "undo", null);
__decorate([
  action
], UndoManager.prototype, "redo", null);
let _isGlobalUndoRecordingDisabled = false;
function withoutUndo(fn) {
  const savedUndoDisabled = _isGlobalUndoRecordingDisabled;
  _isGlobalUndoRecordingDisabled = true;
  try {
    return fn();
  } finally {
    _isGlobalUndoRecordingDisabled = savedUndoDisabled;
  }
}
function resolveContextValue(contextValue) {
  if (contextValue.type === "value") {
    return contextValue.value;
  } else {
    return contextValue.value.get();
  }
}
const createContextValueAtom = () => createAtom("contextValue");
class ContextClass {
  constructor(defaultValue) {
    __publicField(this, "defaultContextValue", observable$1.box(void 0, { deep: false }));
    __publicField(this, "overrideContextValue", observable$1.box(void 0, {
      deep: false
    }));
    __publicField(this, "nodeContextValue", /* @__PURE__ */ new WeakMap());
    __publicField(this, "nodeAtom", /* @__PURE__ */ new WeakMap());
    __publicField(this, "setDefault", action((value) => {
      this.defaultContextValue.set({
        type: "value",
        value
      });
    }));
    __publicField(this, "setDefaultComputed", action((valueFn) => {
      this.defaultContextValue.set({
        type: "computed",
        value: computed(valueFn)
      });
    }));
    __publicField(this, "set", action((node, value) => {
      assertTweakedObject(node, "node");
      this.nodeContextValue.set(node, {
        type: "value",
        value
      });
      this.getNodeAtom(node).reportChanged();
    }));
    __publicField(this, "setComputed", action((node, valueFn) => {
      this._setComputed(node, computed(valueFn));
    }));
    __publicField(this, "unset", action((node) => {
      assertTweakedObject(node, "node");
      this.nodeContextValue.delete(node);
      this.getNodeAtom(node).reportChanged();
    }));
    __publicField(this, "apply", action((fn, value) => {
      const old = this.overrideContextValue.get();
      this.overrideContextValue.set({
        type: "value",
        value
      });
      try {
        const ret = fn();
        if (isTweakedObject(ret, true)) {
          this.set(ret, value);
        }
        return ret;
      } finally {
        this.overrideContextValue.set(old);
      }
    }));
    __publicField(this, "applyComputed", action((fn, valueFn) => {
      const computedValueFn = computed(valueFn);
      const old = this.overrideContextValue.get();
      this.overrideContextValue.set({
        type: "computed",
        value: computedValueFn
      });
      try {
        const ret = fn();
        if (isTweakedObject(ret, true)) {
          this._setComputed(ret, computedValueFn);
        }
        return ret;
      } finally {
        this.overrideContextValue.set(old);
      }
    }));
    this.setDefault(defaultValue);
  }
  getNodeAtom(node) {
    return getOrCreate(this.nodeAtom, node, createContextValueAtom);
  }
  fastGet(node) {
    this.getNodeAtom(node).reportObserved();
    const obsForNode = this.nodeContextValue.get(node);
    if (obsForNode) {
      return resolveContextValue(obsForNode);
    }
    const parent = fastGetParent(node);
    if (!parent) {
      const overrideValue = this.overrideContextValue.get();
      if (overrideValue) {
        return resolveContextValue(overrideValue);
      }
      return this.getDefault();
    }
    return this.fastGet(parent);
  }
  get(node) {
    assertTweakedObject(node, "node");
    return this.fastGet(node);
  }
  fastGetProviderNode(node) {
    this.getNodeAtom(node).reportObserved();
    const obsForNode = this.nodeContextValue.get(node);
    if (obsForNode) {
      return node;
    }
    const parent = fastGetParent(node);
    if (!parent) {
      return void 0;
    }
    return this.fastGetProviderNode(parent);
  }
  getProviderNode(node) {
    assertTweakedObject(node, "node");
    return this.fastGetProviderNode(node);
  }
  getDefault() {
    return resolveContextValue(this.defaultContextValue.get());
  }
  _setComputed(node, computedValueFn) {
    assertTweakedObject(node, "node");
    this.nodeContextValue.set(node, { type: "computed", value: computedValueFn });
    this.getNodeAtom(node).reportChanged();
  }
}
function createContext(defaultValue) {
  return new ContextClass(defaultValue);
}
createContext(false);
class Ref extends Model({
  /**
   * Reference id.
   */
  id: tProp(typesString)
}) {
  /**
   * The object this reference points to, or `undefined` if the reference is currently invalid.
   */
  get maybeCurrent() {
    return this.resolve();
  }
  /**
   * If the reference is currently valid.
   */
  get isValid() {
    return !!this.maybeCurrent;
  }
  /**
   * The object this reference points to, or throws if invalid.
   */
  get current() {
    const current = this.maybeCurrent;
    if (!current) {
      throw failure(`a reference of type '${this[modelTypeKey]}' could not resolve an object with id '${this.id}'`);
    }
    return current;
  }
}
__decorate([
  computed
], Ref.prototype, "maybeCurrent", null);
__decorate([
  computed
], Ref.prototype, "isValid", null);
__decorate([
  computed
], Ref.prototype, "current", null);
const objectBackRefs = /* @__PURE__ */ new WeakMap();
function internalCustomRef(modelTypeId, resolverGen, getId, onResolvedValueChange) {
  let CustomRef = class CustomRef extends Ref {
    constructor() {
      super(...arguments);
      __publicField(this, "resolver");
      __publicField(this, "savedOldTarget");
    }
    resolve() {
      if (!this.resolver) {
        this.resolver = resolverGen(this);
      }
      return this.resolver(this);
    }
    internalForceUpdateBackRefs(newTarget) {
      const oldTarget = this.savedOldTarget;
      this.savedOldTarget = newTarget;
      updateBackRefs(this, thisRefConstructor, newTarget, oldTarget);
    }
    forceUpdateBackRefs() {
      this.internalForceUpdateBackRefs(this.maybeCurrent);
    }
    onInit() {
      let savedOldTarget;
      let savedFirstTime = true;
      reaction(() => this.maybeCurrent, (newTarget) => {
        this.internalForceUpdateBackRefs(newTarget);
        const oldTarget = savedOldTarget;
        const firstTime = savedFirstTime;
        savedOldTarget = newTarget;
        savedFirstTime = false;
        if (!firstTime && onResolvedValueChange && newTarget !== oldTarget) {
          onResolvedValueChange(this, newTarget, oldTarget);
        }
      }, { fireImmediately: true });
    }
  };
  __decorate([
    action
  ], CustomRef.prototype, "forceUpdateBackRefs", null);
  CustomRef = __decorate([
    model(modelTypeId)
  ], CustomRef);
  const fn = (target) => {
    let id2;
    if (typeof target === "string") {
      id2 = target;
    } else {
      assertIsObject(target, "target");
      id2 = getId(target);
    }
    if (typeof id2 !== "string") {
      throw failure("ref target object must have an id of string type");
    }
    const ref = new CustomRef({
      id: id2
    });
    return ref;
  };
  fn.refClass = CustomRef;
  const thisRefConstructor = fn;
  return thisRefConstructor;
}
function getModelRefId(target) {
  if (isModel(target) && target.getRefId) {
    const id2 = target.getRefId();
    if (id2 !== void 0 && typeof id2 !== "string") {
      throw failure("'getRefId()' must return a string or undefined when present");
    }
    return id2;
  }
  return void 0;
}
const computedIdTrees = /* @__PURE__ */ new WeakMap();
function resolveId(root, id2, getId = getModelRefId) {
  const computedIdTree = getOrCreate(computedIdTrees, getId, () => computedWalkTreeAggregate((node) => getId(node)));
  const idMap = computedIdTree.walk(root);
  return idMap ? idMap.get(id2) : void 0;
}
function getBackRefs(target, refType) {
  let backRefs = objectBackRefs.get(target);
  if (!backRefs) {
    backRefs = {
      all: observable$1.set(void 0, { deep: false }),
      byType: /* @__PURE__ */ new WeakMap()
    };
    objectBackRefs.set(target, backRefs);
  }
  if (!refType) {
    return backRefs.all;
  } else {
    let byType = backRefs.byType.get(refType);
    if (!byType) {
      byType = observable$1.set(void 0, { deep: false });
      backRefs.byType.set(refType, byType);
    }
    return byType;
  }
}
const updateBackRefs = action("updateBackRefs", (ref, refClass, newTarget, oldTarget) => {
  if (newTarget === oldTarget) {
    return;
  }
  if (oldTarget) {
    getBackRefs(oldTarget).delete(ref);
    getBackRefs(oldTarget, refClass).delete(ref);
  }
  if (newTarget) {
    getBackRefs(newTarget).add(ref);
    getBackRefs(newTarget, refClass).add(ref);
  }
});
registerDeepObjectChildrenExtension({
  initData() {
    return {
      all: /* @__PURE__ */ new Set(),
      byType: /* @__PURE__ */ new WeakMap()
    };
  },
  addNode(node, data) {
    if (node instanceof Ref) {
      data.all.add(node);
      const refsByThisType = getOrCreate(data.byType, node.constructor, () => /* @__PURE__ */ new Set());
      refsByThisType.add(node);
    }
  }
});
action("customRef", (modelTypeId, options) => {
  var _a2;
  const getId = (_a2 = options.getId) != null ? _a2 : getModelRefId;
  return internalCustomRef(modelTypeId, () => options.resolve, getId, options.onResolvedValueChange);
});
action("rootRef", (modelTypeId, options) => {
  var _a2;
  const getId = (_a2 = options == null ? void 0 : options.getId) != null ? _a2 : getModelRefId;
  const onResolvedValueChange = options == null ? void 0 : options.onResolvedValueChange;
  const resolverGen = (ref) => {
    let cachedTarget;
    return () => {
      const refRoot = fastGetRoot(ref);
      if (isRefRootCachedTargetOk(ref, refRoot, cachedTarget, getId)) {
        return cachedTarget;
      }
      const newTarget = resolveId(refRoot, ref.id, getId);
      if (newTarget) {
        cachedTarget = newTarget;
      }
      return newTarget;
    };
  };
  return internalCustomRef(modelTypeId, resolverGen, getId, onResolvedValueChange);
});
function isRefRootCachedTargetOk(ref, refRoot, cachedTarget, getId) {
  if (!cachedTarget)
    return false;
  if (ref.id !== getId(cachedTarget))
    return false;
  if (refRoot !== fastGetRoot(cachedTarget))
    return false;
  return true;
}
function standaloneAction(actionName, fn) {
  return addStandaloneAction(actionName, fn, false);
}
function _splice(array2, ...args) {
  return array2.splice(...args);
}
const namespace$1 = `${namespace$2}/arrayActions`;
({
  set: standaloneAction(`${namespace$1}::set`, (array2, index2, value) => {
    setIfDifferent(array2, index2, value);
  }),
  delete: standaloneAction(`${namespace$1}::delete`, (array2, index2) => {
    return remove$1(array2, "" + index2);
  }),
  setLength: standaloneAction(`${namespace$1}::setLength`, (array2, length) => {
    array2.length = length;
  }),
  concat: standaloneAction(`${namespace$1}::concat`, (array2, ...items2) => {
    return array2.concat(...items2);
  }),
  copyWithin: standaloneAction(`${namespace$1}::copyWithin`, (array2, target, start, end) => {
    return array2.copyWithin(target, start, end);
  }),
  fill: standaloneAction(`${namespace$1}::fill`, (array2, value, start, end) => {
    return array2.fill(value, start, end);
  }),
  pop: standaloneAction(`${namespace$1}::pop`, (array2) => {
    return array2.pop();
  }),
  push: standaloneAction(`${namespace$1}::push`, (array2, ...items2) => {
    return array2.push(...items2);
  }),
  reverse: standaloneAction(`${namespace$1}::reverse`, (array2) => {
    return array2.reverse();
  }),
  shift: standaloneAction(`${namespace$1}::shift`, (array2) => {
    return array2.shift();
  }),
  slice: standaloneAction(`${namespace$1}::slice`, (array2, start, end) => {
    return array2.slice(start, end);
  }),
  sort: standaloneAction(`${namespace$1}::sort`, (array2, compareFn) => {
    return array2.sort(compareFn);
  }),
  splice: standaloneAction(`${namespace$1}::splice`, _splice),
  unshift: standaloneAction(`${namespace$1}::unshift`, (array2, ...items2) => {
    return array2.unshift(...items2);
  }),
  swap: standaloneAction(`${namespace$1}::swap`, (array2, index1, index2) => {
    if (index1 < 0 || index2 < 0 || index1 >= array2.length || index2 >= array2.length) {
      return false;
    }
    if (index2 < index1) {
      [index1, index2] = [index2, index1];
    }
    const [v1] = array2.splice(index1, 1);
    const [v2] = array2.splice(index2 - 1, 1);
    array2.splice(index1, 0, v2);
    array2.splice(index2, 0, v1);
    return true;
  }),
  create: (data) => toTreeNode(data)
});
const namespace = `${namespace$2}/objectActions`;
({
  set: standaloneAction(`${namespace}::set`, (target, key, value) => {
    if (isObservable(target)) {
      setIfDifferent(target, key, value);
    } else {
      target[key] = value;
    }
  }),
  assign: standaloneAction(`${namespace}::assign`, (target, partialObject) => {
    assertIsObject(partialObject, "partialObject");
    const keys2 = Object.keys(partialObject);
    if (isObservable(target)) {
      for (const key of keys2) {
        const newValue = partialObject[key];
        setIfDifferent(target, key, newValue);
      }
    } else {
      for (const key of keys2) {
        target[key] = partialObject[key];
      }
    }
  }),
  delete: standaloneAction(`${namespace}::delete`, (target, key) => {
    return remove$1(target, key);
  }),
  call: standaloneAction(`${namespace}::call`, (target, methodName, ...args) => {
    return target[methodName](...args);
  }),
  create: (data) => toTreeNode(data)
});
action((obj) => {
  const map2 = observable$1.map();
  map2.dataObject = obj;
  const keys2 = Object.keys(obj);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const k2 = keys2[i2];
    map2.set(k2, obj[k2]);
  }
  let mapAlreadyChanged = false;
  let objectAlreadyChanged = false;
  observe(obj, action((change) => {
    if (mapAlreadyChanged) {
      return;
    }
    objectAlreadyChanged = true;
    try {
      switch (change.type) {
        case "add":
        case "update": {
          map2.set(change.name, change.newValue);
          break;
        }
        case "remove": {
          map2.delete(change.name);
          break;
        }
      }
    } finally {
      objectAlreadyChanged = false;
    }
  }));
  intercept(map2, action((change) => {
    if (mapAlreadyChanged) {
      return null;
    }
    if (objectAlreadyChanged) {
      return change;
    }
    mapAlreadyChanged = true;
    try {
      switch (change.type) {
        case "add":
        case "update": {
          setIfDifferent(obj, change.name, change.newValue);
          break;
        }
        case "delete": {
          remove$1(obj, change.name);
          break;
        }
      }
      return change;
    } finally {
      mapAlreadyChanged = false;
    }
  }));
  return map2;
});
action((array2) => {
  let map2;
  if (getMobxVersion() >= 6) {
    map2 = observable$1.map(array2);
  } else {
    map2 = observable$1.map();
    array2.forEach(([k2, v2]) => {
      map2.set(k2, v2);
    });
  }
  map2.dataObject = array2;
  if (map2.size !== array2.length) {
    throw failure("arrays backing a map cannot contain duplicate keys");
  }
  let mapAlreadyChanged = false;
  let arrayAlreadyChanged = false;
  observe(array2, action((change) => {
    if (mapAlreadyChanged) {
      return;
    }
    arrayAlreadyChanged = true;
    try {
      switch (change.type) {
        case "splice": {
          {
            const removed = change.removed;
            for (let i2 = 0; i2 < removed.length; i2++) {
              map2.delete(removed[i2][0]);
            }
          }
          {
            const added = change.added;
            for (let i2 = 0; i2 < added.length; i2++) {
              map2.set(added[i2][0], added[i2][1]);
            }
          }
          break;
        }
        case "update": {
          map2.delete(change.oldValue[0]);
          map2.set(change.newValue[0], change.newValue[1]);
          break;
        }
      }
    } finally {
      arrayAlreadyChanged = false;
    }
  }));
  intercept(map2, action((change) => {
    if (mapAlreadyChanged) {
      return null;
    }
    if (arrayAlreadyChanged) {
      return change;
    }
    mapAlreadyChanged = true;
    try {
      switch (change.type) {
        case "update": {
          const i2 = array2.findIndex((i22) => i22[0] === change.name);
          array2[i2] = [change.name, change.newValue];
          break;
        }
        case "add": {
          array2.push([change.name, change.newValue]);
          break;
        }
        case "delete": {
          const i2 = array2.findIndex((i22) => i22[0] === change.name);
          if (i2 >= 0) {
            array2.splice(i2, 1);
          }
          break;
        }
      }
      return change;
    } finally {
      mapAlreadyChanged = false;
    }
  }));
  return map2;
});
action((array2) => {
  let set22;
  if (getMobxVersion() >= 6) {
    set22 = observable$1.set(array2);
  } else {
    set22 = observable$1.set();
    array2.forEach((item) => {
      set22.add(item);
    });
  }
  set22.dataObject = array2;
  if (set22.size !== array2.length) {
    throw failure("arrays backing a set cannot contain duplicate values");
  }
  let setAlreadyChanged = false;
  let arrayAlreadyChanged = false;
  observe(array2, action((change) => {
    if (setAlreadyChanged) {
      return;
    }
    arrayAlreadyChanged = true;
    try {
      switch (change.type) {
        case "splice": {
          {
            const removed = change.removed;
            for (let i2 = 0; i2 < removed.length; i2++) {
              set22.delete(removed[i2]);
            }
          }
          {
            const added = change.added;
            for (let i2 = 0; i2 < added.length; i2++) {
              set22.add(added[i2]);
            }
          }
          break;
        }
        case "update": {
          set22.delete(change.oldValue);
          set22.add(change.newValue);
          break;
        }
      }
    } finally {
      arrayAlreadyChanged = false;
    }
  }));
  intercept(set22, action((change) => {
    if (setAlreadyChanged) {
      return null;
    }
    if (arrayAlreadyChanged) {
      return change;
    }
    setAlreadyChanged = true;
    try {
      switch (change.type) {
        case "add": {
          array2.push(change.newValue);
          break;
        }
        case "delete": {
          const i2 = array2.indexOf(change.oldValue);
          if (i2 >= 0) {
            array2.splice(i2, 1);
          }
          break;
        }
      }
      return change;
    } finally {
      setAlreadyChanged = false;
    }
  }));
  return set22;
});
class Draft {
  /**
   * Creates an instance of Draft.
   * Do not use directly, use `draft` instead.
   *
   * @param original
   */
  constructor(original) {
    __publicField(this, "data");
    __publicField(this, "originalData");
    assertTweakedObject(original, "original");
    this.originalData = original;
    this.data = fromSnapshot(this.originalSnapshot, { generateNewIds: false });
  }
  /**
   * Commits current draft changes to the original object.
   */
  commit() {
    applySnapshot(this.originalData, getSnapshot(this.data));
  }
  /**
   * Partially commits current draft changes to the original object.
   * If the path cannot be resolved in either the draft or the original object it will throw.
   * Note that model IDs are checked to be the same when resolving the paths.
   *
   * @param path Path to commit.
   */
  commitByPath(path) {
    const draftTarget = resolvePath$1(this.data, path);
    if (!draftTarget.resolved) {
      throw failure(`path ${JSON.stringify(path)} could not be resolved in draft object`);
    }
    const draftPathIds = pathToTargetPathIdsIgnoringLast(this.data, path);
    const originalTarget = resolvePathCheckingIds(this.originalData, path, draftPathIds);
    if (!originalTarget.resolved) {
      throw failure(`path ${JSON.stringify(path)} could not be resolved in original object`);
    }
    applyPatches(this.originalData, [
      {
        path,
        op: "replace",
        value: getSnapshot(draftTarget.value)
      }
    ]);
  }
  /**
   * Resets the draft to be an exact copy of the current state of the original object.
   */
  reset() {
    applySnapshot(this.data, this.originalSnapshot);
  }
  /**
   * Partially resets current draft changes to be the same as the original object.
   * If the path cannot be resolved in either the draft or the original object it will throw.
   * Note that model IDs are checked to be the same when resolving the paths.
   *
   * @param path Path to reset.
   */
  resetByPath(path) {
    const originalTarget = resolvePath$1(this.originalData, path);
    if (!originalTarget.resolved) {
      throw failure(`path ${JSON.stringify(path)} could not be resolved in original object`);
    }
    const originalPathIds = pathToTargetPathIdsIgnoringLast(this.originalData, path);
    const draftTarget = resolvePathCheckingIds(this.data, path, originalPathIds);
    if (!draftTarget.resolved) {
      throw failure(`path ${JSON.stringify(path)} could not be resolved in draft object`);
    }
    applyPatches(this.data, [
      {
        path,
        op: "replace",
        value: getSnapshot(originalTarget.value)
      }
    ]);
  }
  /**
   * Returns `true` if the draft has changed compared to the original object, `false` otherwise.
   */
  get isDirty() {
    return !deepEquals(getSnapshot(this.data), this.originalSnapshot);
  }
  /**
   * Returns `true` if the value at the given path of the draft has changed compared to the original object.
   * If the path cannot be resolved in the draft it will throw.
   * If the path cannot be resolved in the original object it will return `true`.
   * Note that model IDs are checked to be the same when resolving the paths.
   *
   * @param path Path to check.
   */
  isDirtyByPath(path) {
    const draftTarget = resolvePath$1(this.data, path);
    if (!draftTarget.resolved) {
      throw failure(`path ${JSON.stringify(path)} could not be resolved in draft object`);
    }
    const draftPathIds = pathToTargetPathIdsIgnoringLast(this.data, path);
    const originalTarget = resolvePathCheckingIds(this.originalData, path, draftPathIds);
    if (!originalTarget.resolved) {
      return true;
    }
    return !deepEquals(draftTarget.value, originalTarget.value);
  }
  get originalSnapshot() {
    return getSnapshot(this.originalData);
  }
}
__decorate([
  action
], Draft.prototype, "commit", null);
__decorate([
  action
], Draft.prototype, "commitByPath", null);
__decorate([
  action
], Draft.prototype, "reset", null);
__decorate([
  action
], Draft.prototype, "resetByPath", null);
__decorate([
  computed
], Draft.prototype, "isDirty", null);
__decorate([
  computed
], Draft.prototype, "originalSnapshot", null);
function pathToTargetPathIdsIgnoringLast(root, path) {
  const pathIds = pathToTargetPathIds(root, path);
  if (pathIds.length >= 1) {
    pathIds[pathIds.length - 1] = skipIdChecking;
  }
  return pathIds;
}
createContext();
let ArraySet = class ArraySet2 extends Model({
  [modelIdKey]: idProp,
  items: tProp(typesArray(typesUnchecked()), () => [])
  // will be properly checked by types.arraySet(subType)
}) {
  add(value) {
    const items2 = this.items;
    if (!items2.includes(value)) {
      items2.push(value);
    }
    return this;
  }
  clear() {
    this.items.length = 0;
  }
  delete(value) {
    const items2 = this.items;
    const index2 = items2.findIndex((t2) => t2 === value);
    if (index2 >= 0) {
      items2.splice(index2, 1);
      return true;
    } else {
      return false;
    }
  }
  forEach(callbackfn, thisArg) {
    const items2 = this.items;
    const len = items2.length;
    for (let i2 = 0; i2 < len; i2++) {
      const k2 = items2[i2];
      callbackfn.call(thisArg, k2, k2, this);
    }
  }
  has(value) {
    return this.items.includes(value);
  }
  get size() {
    return this.items.length;
  }
  keys() {
    return this.values();
  }
  values() {
    const items2 = this.items;
    return values(items2)[Symbol.iterator]();
  }
  entries() {
    const items2 = this.items;
    return items2.map((v2) => [v2, v2]).values();
  }
  [Symbol.iterator]() {
    return this.values();
  }
  get [Symbol.toStringTag]() {
    return "ArraySet";
  }
};
__decorate([
  modelAction
], ArraySet.prototype, "add", null);
__decorate([
  modelAction
], ArraySet.prototype, "clear", null);
__decorate([
  modelAction
], ArraySet.prototype, "delete", null);
ArraySet = __decorate([
  model(`${namespace$2}/ArraySet`)
], ArraySet);
function typesRecord(valueType) {
  const typeInfoGen = (tc2) => new RecordTypeInfo(tc2, resolveStandardType(valueType));
  return lateTypeChecker(() => {
    const valueChecker = resolveTypeChecker(valueType);
    const getTypeName = (...recursiveTypeCheckers) => `Record<${valueChecker.getTypeName(...recursiveTypeCheckers, valueChecker)}>`;
    const applySnapshotProcessor = (obj, mode) => {
      if (valueChecker.unchecked) {
        return obj;
      }
      const newObj = {};
      const keys2 = Object.keys(obj);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const k2 = keys2[i2];
        const v2 = mode === "from" ? valueChecker.fromSnapshotProcessor(obj[k2]) : valueChecker.toSnapshotProcessor(obj[k2]);
        newObj[k2] = v2;
      }
      return newObj;
    };
    const thisTc = new TypeChecker(TypeCheckerBaseType.Object, (obj, path, typeCheckedValue) => {
      if (!isObject$1(obj)) {
        return new TypeCheckError(path, getTypeName(thisTc), obj, typeCheckedValue);
      }
      if (!valueChecker.unchecked) {
        const keys2 = Object.keys(obj);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const k2 = keys2[i2];
          const v2 = obj[k2];
          const valueError = valueChecker.check(v2, [...path, k2], typeCheckedValue);
          if (valueError) {
            return valueError;
          }
        }
      }
      return null;
    }, getTypeName, typeInfoGen, (obj) => {
      if (!isObject$1(obj))
        return null;
      if (!valueChecker.unchecked) {
        const keys2 = Object.keys(obj);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const k2 = keys2[i2];
          const v2 = obj[k2];
          const valueActualChecker = valueChecker.snapshotType(v2);
          if (!valueActualChecker) {
            return null;
          }
        }
      }
      return thisTc;
    }, (obj) => {
      return applySnapshotProcessor(obj, "from");
    }, (obj) => {
      return applySnapshotProcessor(obj, "to");
    });
    return thisTc;
  }, typeInfoGen);
}
class RecordTypeInfo extends TypeInfo {
  constructor(thisType, valueType) {
    super(thisType);
    __publicField(this, "valueType");
    this.valueType = valueType;
  }
  get valueTypeInfo() {
    return getTypeInfo(this.valueType);
  }
}
let ObjectMap = class ObjectMap2 extends Model({
  [modelIdKey]: idProp,
  items: tProp(typesRecord(typesUnchecked()), () => ({}))
  // will be properly checked by types.objectMap(subType)
}) {
  clear() {
    const items2 = this.items;
    const keys2 = Object.keys(items2);
    const len = keys2.length;
    for (let i2 = 0; i2 < len; i2++) {
      const k2 = keys2[i2];
      remove$1(items2, k2);
    }
  }
  delete(key) {
    const hasKey = this.has(key);
    if (hasKey) {
      remove$1(this.items, key);
      return true;
    } else {
      return false;
    }
  }
  forEach(callbackfn, thisArg) {
    const items2 = this.items;
    const keys2 = Object.keys(items2);
    const len = keys2.length;
    for (let i2 = 0; i2 < len; i2++) {
      const k2 = keys2[i2];
      callbackfn.call(thisArg, items2[k2], k2, this);
    }
  }
  get(key) {
    return get$2(this.items, key);
  }
  has(key) {
    return has(this.items, key);
  }
  set(key, value) {
    setIfDifferent(this.items, key, value);
    return this;
  }
  get size() {
    return keys(this.items).length;
  }
  keys() {
    return keys(this.items)[Symbol.iterator]();
  }
  values() {
    return values(this.items)[Symbol.iterator]();
  }
  entries() {
    return entries(this.items)[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return "ObjectMap";
  }
};
__decorate([
  modelAction
], ObjectMap.prototype, "clear", null);
__decorate([
  modelAction
], ObjectMap.prototype, "delete", null);
__decorate([
  modelAction
], ObjectMap.prototype, "set", null);
ObjectMap = __decorate([
  model(`${namespace$2}/ObjectMap`)
], ObjectMap);
function typesRefinement(baseType, checkFn, typeName) {
  const typeInfoGen = (t2) => new RefinementTypeInfo(t2, resolveStandardType(baseType), checkFn, typeName);
  return lateTypeChecker(() => {
    const baseChecker = resolveTypeChecker(baseType);
    const getTypeName = (...recursiveTypeCheckers) => {
      const baseTypeName = baseChecker.getTypeName(...recursiveTypeCheckers, baseChecker);
      const refinementName = typeName || "refinementOf";
      return `${refinementName}<${baseTypeName}>`;
    };
    const thisTc = new TypeChecker(
      baseChecker.baseType,
      (data, path, typeCheckedValue) => {
        const baseErr = baseChecker.check(data, path, typeCheckedValue);
        if (baseErr) {
          return baseErr;
        }
        const refinementErr = checkFn(data);
        if (refinementErr === true || refinementErr == null) {
          return null;
        } else if (refinementErr === false) {
          return new TypeCheckError(path, getTypeName(thisTc), data, typeCheckedValue);
        } else {
          return new TypeCheckError(refinementErr.path, refinementErr.expectedTypeName, refinementErr.actualValue, typeCheckedValue);
        }
      },
      getTypeName,
      typeInfoGen,
      // we cannot check refinement here since it checks data instances, not snapshots
      (sn) => baseChecker.snapshotType(sn),
      (sn) => baseChecker.fromSnapshotProcessor(sn),
      (sn) => baseChecker.toSnapshotProcessor(sn)
    );
    return thisTc;
  }, typeInfoGen);
}
class RefinementTypeInfo extends TypeInfo {
  constructor(thisType, baseType, checkFunction, typeName) {
    super(thisType);
    __publicField(this, "baseType");
    __publicField(this, "checkFunction");
    __publicField(this, "typeName");
    this.baseType = baseType;
    this.checkFunction = checkFunction;
    this.typeName = typeName;
  }
  get baseTypeInfo() {
    return getTypeInfo(this.baseType);
  }
}
typesRefinement(typesNumber, (n2) => Number.isInteger(n2), "integer");
typesRefinement(typesString, (s2) => s2 !== "", "nonEmpty");
var DoubleIndexedKV = (
  /** @class */
  function() {
    function DoubleIndexedKV2() {
      this.keyToValue = /* @__PURE__ */ new Map();
      this.valueToKey = /* @__PURE__ */ new Map();
    }
    DoubleIndexedKV2.prototype.set = function(key, value) {
      this.keyToValue.set(key, value);
      this.valueToKey.set(value, key);
    };
    DoubleIndexedKV2.prototype.getByKey = function(key) {
      return this.keyToValue.get(key);
    };
    DoubleIndexedKV2.prototype.getByValue = function(value) {
      return this.valueToKey.get(value);
    };
    DoubleIndexedKV2.prototype.clear = function() {
      this.keyToValue.clear();
      this.valueToKey.clear();
    };
    return DoubleIndexedKV2;
  }()
);
var Registry = (
  /** @class */
  function() {
    function Registry2(generateIdentifier) {
      this.generateIdentifier = generateIdentifier;
      this.kv = new DoubleIndexedKV();
    }
    Registry2.prototype.register = function(value, identifier) {
      if (this.kv.getByValue(value)) {
        return;
      }
      if (!identifier) {
        identifier = this.generateIdentifier(value);
      }
      this.kv.set(identifier, value);
    };
    Registry2.prototype.clear = function() {
      this.kv.clear();
    };
    Registry2.prototype.getIdentifier = function(value) {
      return this.kv.getByValue(value);
    };
    Registry2.prototype.getValue = function(identifier) {
      return this.kv.getByKey(identifier);
    };
    return Registry2;
  }()
);
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ClassRegistry = (
  /** @class */
  function(_super) {
    __extends(ClassRegistry2, _super);
    function ClassRegistry2() {
      var _this = _super.call(this, function(c2) {
        return c2.name;
      }) || this;
      _this.classToAllowedProps = /* @__PURE__ */ new Map();
      return _this;
    }
    ClassRegistry2.prototype.register = function(value, options) {
      if (typeof options === "object") {
        if (options.allowProps) {
          this.classToAllowedProps.set(value, options.allowProps);
        }
        _super.prototype.register.call(this, value, options.identifier);
      } else {
        _super.prototype.register.call(this, value, options);
      }
    };
    ClassRegistry2.prototype.getAllowedProps = function(value) {
      return this.classToAllowedProps.get(value);
    };
    return ClassRegistry2;
  }(Registry)
);
var __read$3 = globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  var values2 = [];
  for (var key in record) {
    if (record.hasOwnProperty(key)) {
      values2.push(record[key]);
    }
  }
  return values2;
}
function find(record, predicate) {
  var values2 = valuesOfObj(record);
  if ("find" in values2) {
    return values2.find(predicate);
  }
  var valuesNotNever = values2;
  for (var i2 = 0; i2 < valuesNotNever.length; i2++) {
    var value = valuesNotNever[i2];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run3) {
  Object.entries(record).forEach(function(_a2) {
    var _b2 = __read$3(_a2, 2), key = _b2[0], value = _b2[1];
    return run3(value, key);
  });
}
function includes$1(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (var i2 = 0; i2 < record.length; i2++) {
    var value = record[i2];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function CustomTransformerRegistry2() {
      this.transfomers = {};
    }
    CustomTransformerRegistry2.prototype.register = function(transformer) {
      this.transfomers[transformer.name] = transformer;
    };
    CustomTransformerRegistry2.prototype.findApplicable = function(v2) {
      return find(this.transfomers, function(transformer) {
        return transformer.isApplicable(v2);
      });
    };
    CustomTransformerRegistry2.prototype.findByName = function(name2) {
      return this.transfomers[name2];
    };
    return CustomTransformerRegistry2;
  }()
);
var getType$1 = function(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
};
var isUndefined$1 = function(payload) {
  return typeof payload === "undefined";
};
var isNull = function(payload) {
  return payload === null;
};
var isPlainObject$2 = function(payload) {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject$1 = function(payload) {
  return isPlainObject$2(payload) && Object.keys(payload).length === 0;
};
var isArray$1 = function(payload) {
  return Array.isArray(payload);
};
var isString$1 = function(payload) {
  return typeof payload === "string";
};
var isNumber = function(payload) {
  return typeof payload === "number" && !isNaN(payload);
};
var isBoolean$1 = function(payload) {
  return typeof payload === "boolean";
};
var isRegExp = function(payload) {
  return payload instanceof RegExp;
};
var isMap = function(payload) {
  return payload instanceof Map;
};
var isSet = function(payload) {
  return payload instanceof Set;
};
var isSymbol = function(payload) {
  return getType$1(payload) === "Symbol";
};
var isDate = function(payload) {
  return payload instanceof Date && !isNaN(payload.valueOf());
};
var isError = function(payload) {
  return payload instanceof Error;
};
var isNaNValue = function(payload) {
  return typeof payload === "number" && isNaN(payload);
};
var isPrimitive$1 = function(payload) {
  return isBoolean$1(payload) || isNull(payload) || isUndefined$1(payload) || isNumber(payload) || isString$1(payload) || isSymbol(payload);
};
var isBigint = function(payload) {
  return typeof payload === "bigint";
};
var isInfinite = function(payload) {
  return payload === Infinity || payload === -Infinity;
};
var isTypedArray = function(payload) {
  return ArrayBuffer.isView(payload) && !(payload instanceof DataView);
};
var isURL = function(payload) {
  return payload instanceof URL;
};
var escapeKey = function(key) {
  return key.replace(/\./g, "\\.");
};
var stringifyPath = function(path) {
  return path.map(String).map(escapeKey).join(".");
};
var parsePath$1 = function(string) {
  var result = [];
  var segment = "";
  for (var i2 = 0; i2 < string.length; i2++) {
    var char = string.charAt(i2);
    var isEscapedDot = char === "\\" && string.charAt(i2 + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i2++;
      continue;
    }
    var isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  var lastSegment = segment;
  result.push(lastSegment);
  return result;
};
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var __read$2 = globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var __spreadArray$3 = globalThis && globalThis.__spreadArray || function(to2, from) {
  for (var i2 = 0, il2 = from.length, j2 = to2.length; i2 < il2; i2++, j2++)
    to2[j2] = from[i2];
  return to2;
};
function simpleTransformation(isApplicable2, annotation, transform, untransform) {
  return {
    isApplicable: isApplicable2,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined$1, "undefined", function() {
    return null;
  }, function() {
    return void 0;
  }),
  simpleTransformation(isBigint, "bigint", function(v2) {
    return v2.toString();
  }, function(v2) {
    if (typeof BigInt !== "undefined") {
      return BigInt(v2);
    }
    console.error("Please add a BigInt polyfill.");
    return v2;
  }),
  simpleTransformation(isDate, "Date", function(v2) {
    return v2.toISOString();
  }, function(v2) {
    return new Date(v2);
  }),
  simpleTransformation(isError, "Error", function(v2, superJson) {
    var baseError = {
      name: v2.name,
      message: v2.message
    };
    superJson.allowedErrorProps.forEach(function(prop2) {
      baseError[prop2] = v2[prop2];
    });
    return baseError;
  }, function(v2, superJson) {
    var e2 = new Error(v2.message);
    e2.name = v2.name;
    e2.stack = v2.stack;
    superJson.allowedErrorProps.forEach(function(prop2) {
      e2[prop2] = v2[prop2];
    });
    return e2;
  }),
  simpleTransformation(isRegExp, "regexp", function(v2) {
    return "" + v2;
  }, function(regex) {
    var body = regex.slice(1, regex.lastIndexOf("/"));
    var flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(v2) {
      return __spreadArray$3([], __read$2(v2.values()));
    },
    function(v2) {
      return new Set(v2);
    }
  ),
  simpleTransformation(isMap, "map", function(v2) {
    return __spreadArray$3([], __read$2(v2.entries()));
  }, function(v2) {
    return new Map(v2);
  }),
  simpleTransformation(function(v2) {
    return isNaNValue(v2) || isInfinite(v2);
  }, "number", function(v2) {
    if (isNaNValue(v2)) {
      return "NaN";
    }
    if (v2 > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation(function(v2) {
    return v2 === 0 && 1 / v2 === -Infinity;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(v2) {
    return v2.toString();
  }, function(v2) {
    return new URL(v2);
  })
];
function compositeTransformation(isApplicable2, annotation, transform, untransform) {
  return {
    isApplicable: isApplicable2,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation(function(s2, superJson) {
  if (isSymbol(s2)) {
    var isRegistered = !!superJson.symbolRegistry.getIdentifier(s2);
    return isRegistered;
  }
  return false;
}, function(s2, superJson) {
  var identifier = superJson.symbolRegistry.getIdentifier(s2);
  return ["symbol", identifier];
}, function(v2) {
  return v2.description;
}, function(_2, a2, superJson) {
  var value = superJson.symbolRegistry.getValue(a2[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(obj, ctor) {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, function(v2) {
  return ["typed-array", v2.constructor.name];
}, function(v2) {
  return __spreadArray$3([], __read$2(v2));
}, function(v2, a2) {
  var ctor = constructorToName[a2[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v2);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {
    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(clazz, superJson) {
  var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, function(clazz, superJson) {
  var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return __assign$3({}, clazz);
  }
  var result = {};
  allowedProps.forEach(function(prop2) {
    result[prop2] = clazz[prop2];
  });
  return result;
}, function(v2, a2, superJson) {
  var clazz = superJson.classRegistry.getValue(a2[1]);
  if (!clazz) {
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  }
  return Object.assign(Object.create(clazz.prototype), v2);
});
var customRule = compositeTransformation(function(value, superJson) {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, function(v2, a2, superJson) {
  var transformer = superJson.customTransformerRegistry.findByName(a2[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v2);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = function(value, superJson) {
  var applicableCompositeRule = findArr(compositeRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  var applicableSimpleRule = findArr(simpleRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach(function(rule) {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = function(json, type, superJson) {
  if (isArray$1(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    var transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};
var getNthKey = function(value, n2) {
  var keys2 = value.keys();
  while (n2 > 0) {
    keys2.next();
    n2--;
  }
  return keys2.next().value;
};
function validatePath(path) {
  if (includes$1(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes$1(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes$1(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = function(object2, path) {
  validatePath(path);
  for (var i2 = 0; i2 < path.length; i2++) {
    var key = path[i2];
    if (isSet(object2)) {
      object2 = getNthKey(object2, +key);
    } else if (isMap(object2)) {
      var row = +key;
      var type = +path[++i2] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(object2, row);
      switch (type) {
        case "key":
          object2 = keyOfRow;
          break;
        case "value":
          object2 = object2.get(keyOfRow);
          break;
      }
    } else {
      object2 = object2[key];
    }
  }
  return object2;
};
var setDeep = function(object2, path, mapper) {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object2);
  }
  var parent = object2;
  for (var i2 = 0; i2 < path.length - 1; i2++) {
    var key = path[i2];
    if (isArray$1(parent)) {
      var index2 = +key;
      parent = parent[index2];
    } else if (isPlainObject$2(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      var row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      var isEnd = i2 === path.length - 2;
      if (isEnd) {
        break;
      }
      var row = +key;
      var type = +path[++i2] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  var lastKey = path[path.length - 1];
  if (isArray$1(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject$2(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    var oldValue = getNthKey(parent, +lastKey);
    var newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent["delete"](oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    var row = +path[path.length - 2];
    var keyToRow = getNthKey(parent, row);
    var type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        var newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent["delete"](keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object2;
};
var __read$1 = globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to2, from) {
  for (var i2 = 0, il2 = from.length, j2 = to2.length; i2 < il2; i2++, j2++)
    to2[j2] = from[i2];
  return to2;
};
function traverse(tree, walker2, origin) {
  if (origin === void 0) {
    origin = [];
  }
  if (!tree) {
    return;
  }
  if (!isArray$1(tree)) {
    forEach(tree, function(subtree, key) {
      return traverse(subtree, walker2, __spreadArray$2(__spreadArray$2([], __read$1(origin)), __read$1(parsePath$1(key))));
    });
    return;
  }
  var _a2 = __read$1(tree, 2), nodeValue = _a2[0], children = _a2[1];
  if (children) {
    forEach(children, function(child, key) {
      traverse(child, walker2, __spreadArray$2(__spreadArray$2([], __read$1(origin)), __read$1(parsePath$1(key))));
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, function(type, path) {
    plain = setDeep(plain, path, function(v2) {
      return untransformValue(v2, type, superJson);
    });
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    var object2 = getDeep(plain, parsePath$1(path));
    identicalPaths.map(parsePath$1).forEach(function(identicalObjectPath) {
      plain = setDeep(plain, identicalObjectPath, function() {
        return object2;
      });
    });
  }
  if (isArray$1(annotations)) {
    var _a2 = __read$1(annotations, 2), root = _a2[0], other = _a2[1];
    root.forEach(function(identicalPath) {
      plain = setDeep(plain, parsePath$1(identicalPath), function() {
        return plain;
      });
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = function(object2, superJson) {
  return isPlainObject$2(object2) || isArray$1(object2) || isMap(object2) || isSet(object2) || isInstanceOfRegisteredClass(object2, superJson);
};
function addIdentity(object2, path, identities) {
  var existingSet = identities.get(object2);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object2, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites) {
  var result = {};
  var rootEqualityPaths = void 0;
  identitites.forEach(function(paths) {
    if (paths.length <= 1) {
      return;
    }
    var _a2 = __read$1(paths.map(function(path) {
      return path.map(String);
    }).sort(function(a2, b2) {
      return a2.length - b2.length;
    })), shortestPath = _a2[0], identicalPaths = _a2.slice(1);
    if (shortestPath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(shortestPath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject$1(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject$1(result) ? void 0 : result;
  }
}
var walker = function(object2, identities, superJson, dedupe, path, objectsInThisPath, seenObjects) {
  var _a2;
  if (path === void 0) {
    path = [];
  }
  if (objectsInThisPath === void 0) {
    objectsInThisPath = [];
  }
  if (seenObjects === void 0) {
    seenObjects = /* @__PURE__ */ new Map();
  }
  var primitive = isPrimitive$1(object2);
  if (!primitive) {
    addIdentity(object2, path, identities);
    var seen2 = seenObjects.get(object2);
    if (seen2) {
      return dedupe ? {
        transformedValue: null
      } : seen2;
    }
  }
  if (!isDeep(object2, superJson)) {
    var transformed_1 = transformValue(object2, superJson);
    var result_1 = transformed_1 ? {
      transformedValue: transformed_1.value,
      annotations: [transformed_1.type]
    } : {
      transformedValue: object2
    };
    if (!primitive) {
      seenObjects.set(object2, result_1);
    }
    return result_1;
  }
  if (includes$1(objectsInThisPath, object2)) {
    return {
      transformedValue: null
    };
  }
  var transformationResult = transformValue(object2, superJson);
  var transformed = (_a2 = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a2 !== void 0 ? _a2 : object2;
  var transformedValue = isArray$1(transformed) ? [] : {};
  var innerAnnotations = {};
  forEach(transformed, function(value, index2) {
    var recursiveResult = walker(value, identities, superJson, dedupe, __spreadArray$2(__spreadArray$2([], __read$1(path)), [index2]), __spreadArray$2(__spreadArray$2([], __read$1(objectsInThisPath)), [object2]), seenObjects);
    transformedValue[index2] = recursiveResult.transformedValue;
    if (isArray$1(recursiveResult.annotations)) {
      innerAnnotations[index2] = recursiveResult.annotations;
    } else if (isPlainObject$2(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, function(tree, key) {
        innerAnnotations[escapeKey(index2) + "." + key] = tree;
      });
    }
  });
  var result = isEmptyObject$1(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object2, result);
  }
  return result;
};
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isPlainObject$1(payload) {
  if (getType(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isArray(payload) {
  return getType(payload) === "Array";
}
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject$1(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var __read = globalThis && globalThis.__read || function(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2)
    return o3;
  var i2 = m2.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar2;
};
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to2, from) {
  for (var i2 = 0, il2 = from.length, j2 = to2.length; i2 < il2; i2++, j2++)
    to2[j2] = from[i2];
  return to2;
};
var SuperJSON = (
  /** @class */
  function() {
    function SuperJSON2(_a2) {
      var _b2 = _a2 === void 0 ? {} : _a2, _c2 = _b2.dedupe, dedupe = _c2 === void 0 ? false : _c2;
      this.classRegistry = new ClassRegistry();
      this.symbolRegistry = new Registry(function(s2) {
        var _a3;
        return (_a3 = s2.description) !== null && _a3 !== void 0 ? _a3 : "";
      });
      this.customTransformerRegistry = new CustomTransformerRegistry();
      this.allowedErrorProps = [];
      this.dedupe = dedupe;
    }
    SuperJSON2.prototype.serialize = function(object2) {
      var identities = /* @__PURE__ */ new Map();
      var output = walker(object2, identities, this, this.dedupe);
      var res = {
        json: output.transformedValue
      };
      if (output.annotations) {
        res.meta = __assign$2(__assign$2({}, res.meta), { values: output.annotations });
      }
      var equalityAnnotations = generateReferentialEqualityAnnotations(identities);
      if (equalityAnnotations) {
        res.meta = __assign$2(__assign$2({}, res.meta), { referentialEqualities: equalityAnnotations });
      }
      return res;
    };
    SuperJSON2.prototype.deserialize = function(payload) {
      var json = payload.json, meta = payload.meta;
      var result = copy(json);
      if (meta === null || meta === void 0 ? void 0 : meta.values) {
        result = applyValueAnnotations(result, meta.values, this);
      }
      if (meta === null || meta === void 0 ? void 0 : meta.referentialEqualities) {
        result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
      }
      return result;
    };
    SuperJSON2.prototype.stringify = function(object2) {
      return JSON.stringify(this.serialize(object2));
    };
    SuperJSON2.prototype.parse = function(string) {
      return this.deserialize(JSON.parse(string));
    };
    SuperJSON2.prototype.registerClass = function(v2, options) {
      this.classRegistry.register(v2, options);
    };
    SuperJSON2.prototype.registerSymbol = function(v2, identifier) {
      this.symbolRegistry.register(v2, identifier);
    };
    SuperJSON2.prototype.registerCustom = function(transformer, name2) {
      this.customTransformerRegistry.register(__assign$2({ name: name2 }, transformer));
    };
    SuperJSON2.prototype.allowErrorProps = function() {
      var _a2;
      var props = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        props[_i] = arguments[_i];
      }
      (_a2 = this.allowedErrorProps).push.apply(_a2, __spreadArray$1([], __read(props)));
    };
    SuperJSON2.defaultInstance = new SuperJSON2();
    SuperJSON2.serialize = SuperJSON2.defaultInstance.serialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.deserialize = SuperJSON2.defaultInstance.deserialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.stringify = SuperJSON2.defaultInstance.stringify.bind(SuperJSON2.defaultInstance);
    SuperJSON2.parse = SuperJSON2.defaultInstance.parse.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerClass = SuperJSON2.defaultInstance.registerClass.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerSymbol = SuperJSON2.defaultInstance.registerSymbol.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerCustom = SuperJSON2.defaultInstance.registerCustom.bind(SuperJSON2.defaultInstance);
    SuperJSON2.allowErrorProps = SuperJSON2.defaultInstance.allowErrorProps.bind(SuperJSON2.defaultInstance);
    return SuperJSON2;
  }()
);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
const sleep$1 = async (ms) => new Promise((res) => setTimeout(() => res(null), ms));
const minTime = async (promise, ms = 1500) => {
  const [res] = await Promise.all([promise, sleep$1(ms)]);
  return res;
};
const addDefaultPropClasses = (props, defaultProps) => Object.fromEntries(
  Object.entries(props).map(([key, classes]) => [
    key,
    `${defaultProps[key]} ${classes}`
  ])
);
const addDefaultClasses = (propObject, defaultProps) => Object.fromEntries(
  Object.entries(propObject).map(([propKey, prop2]) => [
    propKey,
    addDefaultPropClasses(prop2, defaultProps)
  ])
);
const mapObject = (obj, objMapper) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [
    key,
    objMapper(key, value)
  ])
);
const reduceObject = (obj, objReducer, defaultValue) => {
  const entries2 = Object.entries(obj);
  return entries2.reduce(objReducer, defaultValue);
};
const reduceStringLength = (obj) => reduceObject(
  obj,
  (reduction, entry) => reduction += entry[1]?.length ?? 0,
  0
);
function r$4(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r$4(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r$4(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const falsyToString = (value) => typeof value === "boolean" ? "".concat(value) : value === 0 ? "0" : value;
const cx = clsx;
const cva = (base, config2) => {
  return (props) => {
    var ref;
    if ((config2 === null || config2 === void 0 ? void 0 : config2.variants) == null)
      return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    const { variants, defaultVariants } = config2;
    const getVariantClassNames = Object.keys(variants).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null)
        return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants[variant][variantKey];
    });
    const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
    const getCompoundVariantClassNames = config2 === null || config2 === void 0 ? void 0 : (ref = config2.compoundVariants) === null || ref === void 0 ? void 0 : ref.reduce((acc, param1) => {
      let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param1;
      return Object.entries(compoundVariantOptions).every((param) => {
        let [key, value] = param;
        return Array.isArray(value) ? value.includes({
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key]) : {
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key] === value;
      }) ? [
        ...acc,
        cvClass,
        cvClassName
      ] : acc;
    }, []);
    return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  };
};
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && React.createContext(DefaultContext);
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __rest$2 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i2) {
    return React.createElement(node.tag, __assign$1({
      key: i2
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return React.createElement(IconBase, __assign$1({
      attr: __assign$1({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest$2(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return React.createElement("svg", __assign$1({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign$1(__assign$1({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function RiArrowLeftDoubleFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4.83594 12.0001L11.043 18.2072L12.4573 16.793L7.66436 12.0001L12.4573 7.20718L11.043 5.79297L4.83594 12.0001ZM10.4858 12.0001L16.6929 18.2072L18.1072 16.793L13.3143 12.0001L18.1072 7.20718L16.6929 5.79297L10.4858 12.0001Z" } }] })(props);
}
function RiArrowRightDoubleLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19.1643 12.0001L12.9572 5.79297L11.543 7.20718L16.3359 12.0001L11.543 16.793L12.9572 18.2072L19.1643 12.0001ZM13.5144 12.0001L7.30728 5.79297L5.89307 7.20718L10.686 12.0001L5.89307 16.793L7.30728 18.2072L13.5144 12.0001Z" } }] })(props);
}
function RiBuilding2Fill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 19.0003H14V6.00028L20.3939 8.74053C20.7616 8.89811 21 9.25964 21 9.65967V19.0003H23V21.0003H1V19.0003H3V5.65015C3 5.25496 3.23273 4.89684 3.59386 4.73634L11.2969 1.31275C11.5493 1.2006 11.8448 1.31424 11.9569 1.56659C11.9853 1.63052 12 1.6997 12 1.76966V19.0003Z" } }] })(props);
}
function RiLinksFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M13.0605 8.11073L14.4747 9.52494C17.2084 12.2586 17.2084 16.6908 14.4747 19.4244L14.1211 19.778C11.3875 22.5117 6.95531 22.5117 4.22164 19.778C1.48797 17.0443 1.48797 12.6122 4.22164 9.87849L5.63585 11.2927C3.68323 13.2453 3.68323 16.4112 5.63585 18.3638C7.58847 20.3164 10.7543 20.3164 12.7069 18.3638L13.0605 18.0102C15.0131 16.0576 15.0131 12.8918 13.0605 10.9392L11.6463 9.52494L13.0605 8.11073ZM19.778 14.1211L18.3638 12.7069C20.3164 10.7543 20.3164 7.58847 18.3638 5.63585C16.4112 3.68323 13.2453 3.68323 11.2927 5.63585L10.9392 5.98941C8.98653 7.94203 8.98653 11.1079 10.9392 13.0605L12.3534 14.4747L10.9392 15.8889L9.52494 14.4747C6.79127 11.741 6.79127 7.30886 9.52494 4.57519L9.87849 4.22164C12.6122 1.48797 17.0443 1.48797 19.778 4.22164C22.5117 6.95531 22.5117 11.3875 19.778 14.1211Z" } }] })(props);
}
function RiMailAddFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M22 13.3414C21.3744 13.1203 20.7013 13 20 13C16.6863 13 14 15.6863 14 19C14 19.7013 14.1203 20.3744 14.3414 21H3C2.44772 21 2 20.5523 2 20V4C2 3.44772 2.44772 3 3 3H21C21.5523 3 22 3.44772 22 4V13.3414ZM12.0606 11.6829L5.64722 6.2377L4.35278 7.7623L12.0731 14.3171L19.6544 7.75616L18.3456 6.24384L12.0606 11.6829ZM21 18H24V20H21V23H19V20H16V18H19V15H21V18Z" } }] })(props);
}
function RiMailCloseFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M22 13.3414C21.3744 13.1203 20.7013 13 20 13C16.6863 13 14 15.6863 14 19C14 19.7013 14.1203 20.3744 14.3414 21H3C2.44772 21 2 20.5523 2 20V4C2 3.44772 2.44772 3 3 3H21C21.5523 3 22 3.44772 22 4V13.3414ZM12.0606 11.6829L5.64722 6.2377L4.35278 7.7623L12.0731 14.3171L19.6544 7.75616L18.3456 6.24384L12.0606 11.6829ZM21.4142 19L23.5355 21.1213L22.1213 22.5355L20 20.4142L17.8787 22.5355L16.4645 21.1213L18.5858 19L16.4645 16.8787L17.8787 15.4645L20 17.5858L22.1213 15.4645L23.5355 16.8787L21.4142 19Z" } }] })(props);
}
function RiPhoneFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M21 16.42V19.9561C21 20.4811 20.5941 20.9167 20.0705 20.9537C19.6331 20.9846 19.2763 21 19 21C10.1634 21 3 13.8366 3 5C3 4.72371 3.01545 4.36687 3.04635 3.9295C3.08337 3.40588 3.51894 3 4.04386 3H7.5801C7.83678 3 8.05176 3.19442 8.07753 3.4498C8.10067 3.67907 8.12218 3.86314 8.14207 4.00202C8.34435 5.41472 8.75753 6.75936 9.3487 8.00303C9.44359 8.20265 9.38171 8.44159 9.20185 8.57006L7.04355 10.1118C8.35752 13.1811 10.8189 15.6425 13.8882 16.9565L15.4271 14.8019C15.5572 14.6199 15.799 14.5573 16.001 14.6532C17.2446 15.2439 18.5891 15.6566 20.0016 15.8584C20.1396 15.8782 20.3225 15.8995 20.5502 15.9225C20.8056 15.9483 21 16.1633 21 16.42Z" } }] })(props);
}
function RiMapPinFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M18.364 17.364L12 23.7279L5.63604 17.364C2.12132 13.8492 2.12132 8.15076 5.63604 4.63604C9.15076 1.12132 14.8492 1.12132 18.364 4.63604C21.8787 8.15076 21.8787 13.8492 18.364 17.364ZM12 15C14.2091 15 16 13.2091 16 11C16 8.79086 14.2091 7 12 7C9.79086 7 8 8.79086 8 11C8 13.2091 9.79086 15 12 15ZM12 13C10.8954 13 10 12.1046 10 11C10 9.89543 10.8954 9 12 9C13.1046 9 14 9.89543 14 11C14 12.1046 13.1046 13 12 13Z" } }] })(props);
}
function RiCheckboxCircleFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM11.0026 16L18.0737 8.92893L16.6595 7.51472L11.0026 13.1716L8.17421 10.3431L6.75999 11.7574L11.0026 16Z" } }] })(props);
}
function RiInformationFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM11 11V17H13V11H11ZM11 7V9H13V7H11Z" } }] })(props);
}
function RiLoader2Line(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 2C12.5523 2 13 2.44772 13 3V6C13 6.55228 12.5523 7 12 7C11.4477 7 11 6.55228 11 6V3C11 2.44772 11.4477 2 12 2ZM12 17C12.5523 17 13 17.4477 13 18V21C13 21.5523 12.5523 22 12 22C11.4477 22 11 21.5523 11 21V18C11 17.4477 11.4477 17 12 17ZM22 12C22 12.5523 21.5523 13 21 13H18C17.4477 13 17 12.5523 17 12C17 11.4477 17.4477 11 18 11H21C21.5523 11 22 11.4477 22 12ZM7 12C7 12.5523 6.55228 13 6 13H3C2.44772 13 2 12.5523 2 12C2 11.4477 2.44772 11 3 11H6C6.55228 11 7 11.4477 7 12ZM19.0711 19.0711C18.6805 19.4616 18.0474 19.4616 17.6569 19.0711L15.5355 16.9497C15.145 16.5592 15.145 15.9261 15.5355 15.5355C15.9261 15.145 16.5592 15.145 16.9497 15.5355L19.0711 17.6569C19.4616 18.0474 19.4616 18.6805 19.0711 19.0711ZM8.46447 8.46447C8.07394 8.85499 7.44078 8.85499 7.05025 8.46447L4.92893 6.34315C4.53841 5.95262 4.53841 5.31946 4.92893 4.92893C5.31946 4.53841 5.95262 4.53841 6.34315 4.92893L8.46447 7.05025C8.85499 7.44078 8.85499 8.07394 8.46447 8.46447ZM4.92893 19.0711C4.53841 18.6805 4.53841 18.0474 4.92893 17.6569L7.05025 15.5355C7.44078 15.145 8.07394 15.145 8.46447 15.5355C8.85499 15.9261 8.85499 16.5592 8.46447 16.9497L6.34315 19.0711C5.95262 19.4616 5.31946 19.4616 4.92893 19.0711ZM15.5355 8.46447C15.145 8.07394 15.145 7.44078 15.5355 7.05025L17.6569 4.92893C18.0474 4.53841 18.6805 4.53841 19.0711 4.92893C19.4616 5.31946 19.4616 5.95262 19.0711 6.34315L16.9497 8.46447C16.5592 8.85499 15.9261 8.85499 15.5355 8.46447Z" } }] })(props);
}
function RiLoader3Line(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M3.05469 13H5.07065C5.55588 16.3923 8.47329 19 11.9998 19C15.5262 19 18.4436 16.3923 18.9289 13H20.9448C20.4474 17.5 16.6323 21 11.9998 21C7.36721 21 3.55213 17.5 3.05469 13ZM3.05469 11C3.55213 6.50005 7.36721 3 11.9998 3C16.6323 3 20.4474 6.50005 20.9448 11H18.9289C18.4436 7.60771 15.5262 5 11.9998 5C8.47329 5 5.55588 7.60771 5.07065 11H3.05469Z" } }] })(props);
}
function RiLoader4Line(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M18.364 5.63604L16.9497 7.05025C15.683 5.7835 13.933 5 12 5C8.13401 5 5 8.13401 5 12C5 15.866 8.13401 19 12 19C15.866 19 19 15.866 19 12H21C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C14.4853 3 16.7353 4.00736 18.364 5.63604Z" } }] })(props);
}
function RiLoader5Line(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 3C16.9706 3 21 7.02944 21 12H19C19 8.13401 15.866 5 12 5V3Z" } }] })(props);
}
function RiLoaderLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M11.9995 2C12.5518 2 12.9995 2.44772 12.9995 3V6C12.9995 6.55228 12.5518 7 11.9995 7C11.4472 7 10.9995 6.55228 10.9995 6V3C10.9995 2.44772 11.4472 2 11.9995 2ZM11.9995 17C12.5518 17 12.9995 17.4477 12.9995 18V21C12.9995 21.5523 12.5518 22 11.9995 22C11.4472 22 10.9995 21.5523 10.9995 21V18C10.9995 17.4477 11.4472 17 11.9995 17ZM20.6597 7C20.9359 7.47829 20.772 8.08988 20.2937 8.36602L17.6956 9.86602C17.2173 10.1422 16.6057 9.97829 16.3296 9.5C16.0535 9.02171 16.2173 8.41012 16.6956 8.13398L19.2937 6.63397C19.772 6.35783 20.3836 6.52171 20.6597 7ZM7.66935 14.5C7.94549 14.9783 7.78161 15.5899 7.30332 15.866L4.70525 17.366C4.22695 17.6422 3.61536 17.4783 3.33922 17C3.06308 16.5217 3.22695 15.9101 3.70525 15.634L6.30332 14.134C6.78161 13.8578 7.3932 14.0217 7.66935 14.5ZM20.6597 17C20.3836 17.4783 19.772 17.6422 19.2937 17.366L16.6956 15.866C16.2173 15.5899 16.0535 14.9783 16.3296 14.5C16.6057 14.0217 17.2173 13.8578 17.6956 14.134L20.2937 15.634C20.772 15.9101 20.9359 16.5217 20.6597 17ZM7.66935 9.5C7.3932 9.97829 6.78161 10.1422 6.30332 9.86602L3.70525 8.36602C3.22695 8.08988 3.06308 7.47829 3.33922 7C3.61536 6.52171 4.22695 6.35783 4.70525 6.63397L7.30332 8.13398C7.78161 8.41012 7.94549 9.02171 7.66935 9.5Z" } }] })(props);
}
function RiQuestionLine(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM13 13.3551V14H11V12.5C11 11.9477 11.4477 11.5 12 11.5C12.8284 11.5 13.5 10.8284 13.5 10C13.5 9.17157 12.8284 8.5 12 8.5C11.2723 8.5 10.6656 9.01823 10.5288 9.70577L8.56731 9.31346C8.88637 7.70919 10.302 6.5 12 6.5C13.933 6.5 15.5 8.067 15.5 10C15.5 11.5855 14.4457 12.9248 13 13.3551Z" } }] })(props);
}
function RiSearch2Line(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M11 2C15.968 2 20 6.032 20 11C20 15.968 15.968 20 11 20C6.032 20 2 15.968 2 11C2 6.032 6.032 2 11 2ZM11 18C14.8675 18 18 14.8675 18 11C18 7.1325 14.8675 4 11 4C7.1325 4 4 7.1325 4 11C4 14.8675 7.1325 18 11 18ZM19.4853 18.0711L22.3137 20.8995L20.8995 22.3137L18.0711 19.4853L19.4853 18.0711Z" } }] })(props);
}
function RiContactsFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M2 22C2 17.5817 5.58172 14 10 14C14.4183 14 18 17.5817 18 22H2ZM10 13C6.685 13 4 10.315 4 7C4 3.685 6.685 1 10 1C13.315 1 16 3.685 16 7C16 10.315 13.315 13 10 13ZM20 17H24V19H20V17ZM17 12H24V14H17V12ZM19 7H24V9H19V7Z" } }] })(props);
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter$a(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var version$7 = "4.0.1";
function wait(durationMs, resolveWith) {
  return new Promise(function(resolve) {
    return setTimeout(resolve, durationMs, resolveWith);
  });
}
function releaseEventLoop() {
  return wait(0);
}
function requestIdleCallbackIfAvailable(fallbackTimeout, deadlineTimeout) {
  if (deadlineTimeout === void 0) {
    deadlineTimeout = Infinity;
  }
  var requestIdleCallback = window.requestIdleCallback;
  if (requestIdleCallback) {
    return new Promise(function(resolve) {
      return requestIdleCallback.call(window, function() {
        return resolve();
      }, { timeout: deadlineTimeout });
    });
  } else {
    return wait(Math.min(fallbackTimeout, deadlineTimeout));
  }
}
function isPromise(value) {
  return !!value && typeof value.then === "function";
}
function awaitIfAsync(action2, callback) {
  try {
    var returnedValue = action2();
    if (isPromise(returnedValue)) {
      returnedValue.then(function(result) {
        return callback(true, result);
      }, function(error) {
        return callback(false, error);
      });
    } else {
      callback(true, returnedValue);
    }
  } catch (error) {
    callback(false, error);
  }
}
function mapWithBreaks(items2, callback, loopReleaseInterval) {
  if (loopReleaseInterval === void 0) {
    loopReleaseInterval = 16;
  }
  return __awaiter$a(this, void 0, void 0, function() {
    var results, lastLoopReleaseTime, i2, now;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          results = Array(items2.length);
          lastLoopReleaseTime = Date.now();
          i2 = 0;
          _a2.label = 1;
        case 1:
          if (!(i2 < items2.length))
            return [3, 4];
          results[i2] = callback(items2[i2], i2);
          now = Date.now();
          if (!(now >= lastLoopReleaseTime + loopReleaseInterval))
            return [3, 3];
          lastLoopReleaseTime = now;
          return [4, wait(0)];
        case 2:
          _a2.sent();
          _a2.label = 3;
        case 3:
          ++i2;
          return [3, 1];
        case 4:
          return [2, results];
      }
    });
  });
}
function suppressUnhandledRejectionWarning(promise) {
  promise.then(void 0, function() {
    return void 0;
  });
}
function includes(haystack, needle) {
  for (var i2 = 0, l2 = haystack.length; i2 < l2; ++i2) {
    if (haystack[i2] === needle) {
      return true;
    }
  }
  return false;
}
function excludes(haystack, needle) {
  return !includes(haystack, needle);
}
function toInt(value) {
  return parseInt(value);
}
function toFloat(value) {
  return parseFloat(value);
}
function replaceNaN(value, replacement) {
  return typeof value === "number" && isNaN(value) ? replacement : value;
}
function countTruthy(values2) {
  return values2.reduce(function(sum, value) {
    return sum + (value ? 1 : 0);
  }, 0);
}
function round$1(value, base) {
  if (base === void 0) {
    base = 1;
  }
  if (Math.abs(base) >= 1) {
    return Math.round(value / base) * base;
  } else {
    var counterBase = 1 / base;
    return Math.round(value * counterBase) / counterBase;
  }
}
function parseSimpleCssSelector(selector) {
  var _a2, _b2;
  var errorMessage = "Unexpected syntax '".concat(selector, "'");
  var tagMatch = /^\s*([a-z-]*)(.*)$/i.exec(selector);
  var tag = tagMatch[1] || void 0;
  var attributes = {};
  var partsRegex = /([.:#][\w-]+|\[.+?\])/gi;
  var addAttribute = function(name2, value) {
    attributes[name2] = attributes[name2] || [];
    attributes[name2].push(value);
  };
  for (; ; ) {
    var match = partsRegex.exec(tagMatch[2]);
    if (!match) {
      break;
    }
    var part = match[0];
    switch (part[0]) {
      case ".":
        addAttribute("class", part.slice(1));
        break;
      case "#":
        addAttribute("id", part.slice(1));
        break;
      case "[": {
        var attributeMatch = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(part);
        if (attributeMatch) {
          addAttribute(attributeMatch[1], (_b2 = (_a2 = attributeMatch[4]) !== null && _a2 !== void 0 ? _a2 : attributeMatch[5]) !== null && _b2 !== void 0 ? _b2 : "");
        } else {
          throw new Error(errorMessage);
        }
        break;
      }
      default:
        throw new Error(errorMessage);
    }
  }
  return [tag, attributes];
}
function getUTF8Bytes(input) {
  var result = new Uint8Array(input.length);
  for (var i2 = 0; i2 < input.length; i2++) {
    var charCode = input.charCodeAt(i2);
    if (charCode < 0 || charCode > 127) {
      return new TextEncoder().encode(input);
    }
    result[i2] = charCode;
  }
  return result;
}
function x64Add(m2, n2) {
  var m0 = m2[0] >>> 16, m1 = m2[0] & 65535, m22 = m2[1] >>> 16, m3 = m2[1] & 65535;
  var n0 = n2[0] >>> 16, n1 = n2[0] & 65535, n22 = n2[1] >>> 16, n3 = n2[1] & 65535;
  var o0 = 0, o1 = 0, o22 = 0, o3 = 0;
  o3 += m3 + n3;
  o22 += o3 >>> 16;
  o3 &= 65535;
  o22 += m22 + n22;
  o1 += o22 >>> 16;
  o22 &= 65535;
  o1 += m1 + n1;
  o0 += o1 >>> 16;
  o1 &= 65535;
  o0 += m0 + n0;
  o0 &= 65535;
  m2[0] = o0 << 16 | o1;
  m2[1] = o22 << 16 | o3;
}
function x64Multiply(m2, n2) {
  var m0 = m2[0] >>> 16, m1 = m2[0] & 65535, m22 = m2[1] >>> 16, m3 = m2[1] & 65535;
  var n0 = n2[0] >>> 16, n1 = n2[0] & 65535, n22 = n2[1] >>> 16, n3 = n2[1] & 65535;
  var o0 = 0, o1 = 0, o22 = 0, o3 = 0;
  o3 += m3 * n3;
  o22 += o3 >>> 16;
  o3 &= 65535;
  o22 += m22 * n3;
  o1 += o22 >>> 16;
  o22 &= 65535;
  o22 += m3 * n22;
  o1 += o22 >>> 16;
  o22 &= 65535;
  o1 += m1 * n3;
  o0 += o1 >>> 16;
  o1 &= 65535;
  o1 += m22 * n22;
  o0 += o1 >>> 16;
  o1 &= 65535;
  o1 += m3 * n1;
  o0 += o1 >>> 16;
  o1 &= 65535;
  o0 += m0 * n3 + m1 * n22 + m22 * n1 + m3 * n0;
  o0 &= 65535;
  m2[0] = o0 << 16 | o1;
  m2[1] = o22 << 16 | o3;
}
function x64Rotl(m2, bits) {
  var m0 = m2[0];
  bits %= 64;
  if (bits === 32) {
    m2[0] = m2[1];
    m2[1] = m0;
  } else if (bits < 32) {
    m2[0] = m0 << bits | m2[1] >>> 32 - bits;
    m2[1] = m2[1] << bits | m0 >>> 32 - bits;
  } else {
    bits -= 32;
    m2[0] = m2[1] << bits | m0 >>> 32 - bits;
    m2[1] = m0 << bits | m2[1] >>> 32 - bits;
  }
}
function x64LeftShift(m2, bits) {
  bits %= 64;
  if (bits === 0) {
    return;
  } else if (bits < 32) {
    m2[0] = m2[1] >>> 32 - bits;
    m2[1] = m2[1] << bits;
  } else {
    m2[0] = m2[1] << bits - 32;
    m2[1] = 0;
  }
}
function x64Xor(m2, n2) {
  m2[0] ^= n2[0];
  m2[1] ^= n2[1];
}
var F1 = [4283543511, 3981806797];
var F2 = [3301882366, 444984403];
function x64Fmix(h2) {
  var shifted = [0, h2[0] >>> 1];
  x64Xor(h2, shifted);
  x64Multiply(h2, F1);
  shifted[1] = h2[0] >>> 1;
  x64Xor(h2, shifted);
  x64Multiply(h2, F2);
  shifted[1] = h2[0] >>> 1;
  x64Xor(h2, shifted);
}
var C1 = [2277735313, 289559509];
var C2 = [1291169091, 658871167];
var M$1$1 = [0, 5];
var N1 = [0, 1390208809];
var N2 = [0, 944331445];
function x64hash128(input, seed) {
  var key = getUTF8Bytes(input);
  seed = seed || 0;
  var length = [0, key.length];
  var remainder = length[1] % 16;
  var bytes = length[1] - remainder;
  var h1 = [0, seed];
  var h2 = [0, seed];
  var k1 = [0, 0];
  var k2 = [0, 0];
  var i2;
  for (i2 = 0; i2 < bytes; i2 = i2 + 16) {
    k1[0] = key[i2 + 4] | key[i2 + 5] << 8 | key[i2 + 6] << 16 | key[i2 + 7] << 24;
    k1[1] = key[i2] | key[i2 + 1] << 8 | key[i2 + 2] << 16 | key[i2 + 3] << 24;
    k2[0] = key[i2 + 12] | key[i2 + 13] << 8 | key[i2 + 14] << 16 | key[i2 + 15] << 24;
    k2[1] = key[i2 + 8] | key[i2 + 9] << 8 | key[i2 + 10] << 16 | key[i2 + 11] << 24;
    x64Multiply(k1, C1);
    x64Rotl(k1, 31);
    x64Multiply(k1, C2);
    x64Xor(h1, k1);
    x64Rotl(h1, 27);
    x64Add(h1, h2);
    x64Multiply(h1, M$1$1);
    x64Add(h1, N1);
    x64Multiply(k2, C2);
    x64Rotl(k2, 33);
    x64Multiply(k2, C1);
    x64Xor(h2, k2);
    x64Rotl(h2, 31);
    x64Add(h2, h1);
    x64Multiply(h2, M$1$1);
    x64Add(h2, N2);
  }
  k1[0] = 0;
  k1[1] = 0;
  k2[0] = 0;
  k2[1] = 0;
  var val = [0, 0];
  switch (remainder) {
    case 15:
      val[1] = key[i2 + 14];
      x64LeftShift(val, 48);
      x64Xor(k2, val);
    case 14:
      val[1] = key[i2 + 13];
      x64LeftShift(val, 40);
      x64Xor(k2, val);
    case 13:
      val[1] = key[i2 + 12];
      x64LeftShift(val, 32);
      x64Xor(k2, val);
    case 12:
      val[1] = key[i2 + 11];
      x64LeftShift(val, 24);
      x64Xor(k2, val);
    case 11:
      val[1] = key[i2 + 10];
      x64LeftShift(val, 16);
      x64Xor(k2, val);
    case 10:
      val[1] = key[i2 + 9];
      x64LeftShift(val, 8);
      x64Xor(k2, val);
    case 9:
      val[1] = key[i2 + 8];
      x64Xor(k2, val);
      x64Multiply(k2, C2);
      x64Rotl(k2, 33);
      x64Multiply(k2, C1);
      x64Xor(h2, k2);
    case 8:
      val[1] = key[i2 + 7];
      x64LeftShift(val, 56);
      x64Xor(k1, val);
    case 7:
      val[1] = key[i2 + 6];
      x64LeftShift(val, 48);
      x64Xor(k1, val);
    case 6:
      val[1] = key[i2 + 5];
      x64LeftShift(val, 40);
      x64Xor(k1, val);
    case 5:
      val[1] = key[i2 + 4];
      x64LeftShift(val, 32);
      x64Xor(k1, val);
    case 4:
      val[1] = key[i2 + 3];
      x64LeftShift(val, 24);
      x64Xor(k1, val);
    case 3:
      val[1] = key[i2 + 2];
      x64LeftShift(val, 16);
      x64Xor(k1, val);
    case 2:
      val[1] = key[i2 + 1];
      x64LeftShift(val, 8);
      x64Xor(k1, val);
    case 1:
      val[1] = key[i2];
      x64Xor(k1, val);
      x64Multiply(k1, C1);
      x64Rotl(k1, 31);
      x64Multiply(k1, C2);
      x64Xor(h1, k1);
  }
  x64Xor(h1, length);
  x64Xor(h2, length);
  x64Add(h1, h2);
  x64Add(h2, h1);
  x64Fmix(h1);
  x64Fmix(h2);
  x64Add(h1, h2);
  x64Add(h2, h1);
  return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
}
function errorToObject(error) {
  var _a2;
  return __assign({ name: error.name, message: error.message, stack: (_a2 = error.stack) === null || _a2 === void 0 ? void 0 : _a2.split("\n") }, error);
}
function isFinalResultLoaded(loadResult) {
  return typeof loadResult !== "function";
}
function loadSource(source, sourceOptions) {
  var sourceLoadPromise = new Promise(function(resolveLoad) {
    var loadStartTime = Date.now();
    awaitIfAsync(source.bind(null, sourceOptions), function() {
      var loadArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        loadArgs[_i] = arguments[_i];
      }
      var loadDuration = Date.now() - loadStartTime;
      if (!loadArgs[0]) {
        return resolveLoad(function() {
          return { error: loadArgs[1], duration: loadDuration };
        });
      }
      var loadResult = loadArgs[1];
      if (isFinalResultLoaded(loadResult)) {
        return resolveLoad(function() {
          return { value: loadResult, duration: loadDuration };
        });
      }
      resolveLoad(function() {
        return new Promise(function(resolveGet) {
          var getStartTime = Date.now();
          awaitIfAsync(loadResult, function() {
            var getArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              getArgs[_i2] = arguments[_i2];
            }
            var duration = loadDuration + Date.now() - getStartTime;
            if (!getArgs[0]) {
              return resolveGet({ error: getArgs[1], duration });
            }
            resolveGet({ value: getArgs[1], duration });
          });
        });
      });
    });
  });
  suppressUnhandledRejectionWarning(sourceLoadPromise);
  return function getComponent() {
    return sourceLoadPromise.then(function(finalizeSource) {
      return finalizeSource();
    });
  };
}
function loadSources(sources2, sourceOptions, excludeSources) {
  var includedSources = Object.keys(sources2).filter(function(sourceKey) {
    return excludes(excludeSources, sourceKey);
  });
  var sourceGettersPromise = mapWithBreaks(includedSources, function(sourceKey) {
    return loadSource(sources2[sourceKey], sourceOptions);
  });
  suppressUnhandledRejectionWarning(sourceGettersPromise);
  return function getComponents() {
    return __awaiter$a(this, void 0, void 0, function() {
      var sourceGetters, componentPromises, componentArray, components, index2;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, sourceGettersPromise];
          case 1:
            sourceGetters = _a2.sent();
            return [4, mapWithBreaks(sourceGetters, function(sourceGetter) {
              var componentPromise = sourceGetter();
              suppressUnhandledRejectionWarning(componentPromise);
              return componentPromise;
            })];
          case 2:
            componentPromises = _a2.sent();
            return [
              4,
              Promise.all(componentPromises)
              // Keeping the component keys order the same as the source keys order
            ];
          case 3:
            componentArray = _a2.sent();
            components = {};
            for (index2 = 0; index2 < includedSources.length; ++index2) {
              components[includedSources[index2]] = componentArray[index2];
            }
            return [2, components];
        }
      });
    });
  };
}
function isTrident() {
  var w2 = window;
  var n2 = navigator;
  return countTruthy([
    "MSCSSMatrix" in w2,
    "msSetImmediate" in w2,
    "msIndexedDB" in w2,
    "msMaxTouchPoints" in n2,
    "msPointerEnabled" in n2
  ]) >= 4;
}
function isEdgeHTML() {
  var w2 = window;
  var n2 = navigator;
  return countTruthy(["msWriteProfilerMark" in w2, "MSStream" in w2, "msLaunchUri" in n2, "msSaveBlob" in n2]) >= 3 && !isTrident();
}
function isChromium() {
  var w2 = window;
  var n2 = navigator;
  return countTruthy([
    "webkitPersistentStorage" in n2,
    "webkitTemporaryStorage" in n2,
    n2.vendor.indexOf("Google") === 0,
    "webkitResolveLocalFileSystemURL" in w2,
    "BatteryManager" in w2,
    "webkitMediaStream" in w2,
    "webkitSpeechGrammar" in w2
  ]) >= 5;
}
function isWebKit$1() {
  var w2 = window;
  var n2 = navigator;
  return countTruthy([
    "ApplePayError" in w2,
    "CSSPrimitiveValue" in w2,
    "Counter" in w2,
    n2.vendor.indexOf("Apple") === 0,
    "getStorageUpdates" in n2,
    "WebKitMediaKeys" in w2
  ]) >= 4;
}
function isDesktopSafari() {
  var w2 = window;
  return countTruthy([
    "safari" in w2,
    !("ongestureend" in w2),
    !("TouchEvent" in w2),
    !("orientation" in w2),
    "HTMLElement" in w2 && !("autocapitalize" in HTMLElement.prototype),
    "Document" in w2 && "pointerLockElement" in Document.prototype
  ]) >= 4;
}
function isGecko() {
  var _a2, _b2;
  var w2 = window;
  return countTruthy([
    "buildID" in navigator,
    "MozAppearance" in ((_b2 = (_a2 = document.documentElement) === null || _a2 === void 0 ? void 0 : _a2.style) !== null && _b2 !== void 0 ? _b2 : {}),
    "onmozfullscreenchange" in w2,
    "mozInnerScreenX" in w2,
    "CSSMozDocumentRule" in w2,
    "CanvasCaptureMediaStream" in w2
  ]) >= 4;
}
function isChromium86OrNewer() {
  var w2 = window;
  return countTruthy([
    !("MediaSettingsRange" in w2),
    "RTCEncodedAudioFrame" in w2,
    "" + w2.Intl === "[object Intl]",
    "" + w2.Reflect === "[object Reflect]"
  ]) >= 3;
}
function isWebKit606OrNewer() {
  var w2 = window;
  return countTruthy([
    "DOMRectList" in w2,
    "RTCPeerConnectionIceEvent" in w2,
    "SVGGeometryElement" in w2,
    "ontransitioncancel" in w2
  ]) >= 3;
}
function isIPad() {
  if (navigator.platform === "iPad") {
    return true;
  }
  var s2 = screen;
  var screenRatio = s2.width / s2.height;
  return countTruthy([
    "MediaSource" in window,
    !!Element.prototype.webkitRequestFullscreen,
    // iPhone 4S that runs iOS 9 matches this. But it won't match the criteria above, so it won't be detected as iPad.
    screenRatio > 0.65 && screenRatio < 1.53
  ]) >= 2;
}
function getFullscreenElement() {
  var d2 = document;
  return d2.fullscreenElement || d2.msFullscreenElement || d2.mozFullScreenElement || d2.webkitFullscreenElement || null;
}
function exitFullscreen() {
  var d2 = document;
  return (d2.exitFullscreen || d2.msExitFullscreen || d2.mozCancelFullScreen || d2.webkitExitFullscreen).call(d2);
}
function isAndroid() {
  var isItChromium = isChromium();
  var isItGecko = isGecko();
  if (!isItChromium && !isItGecko) {
    return false;
  }
  var w2 = window;
  return countTruthy([
    "onorientationchange" in w2,
    "orientation" in w2,
    isItChromium && !("SharedWorker" in w2),
    isItGecko && /android/i.test(navigator.appVersion)
  ]) >= 2;
}
function getAudioFingerprint() {
  var w2 = window;
  var AudioContext = w2.OfflineAudioContext || w2.webkitOfflineAudioContext;
  if (!AudioContext) {
    return -2;
  }
  if (doesCurrentBrowserSuspendAudioContext()) {
    return -1;
  }
  var hashFromIndex = 4500;
  var hashToIndex = 5e3;
  var context = new AudioContext(1, hashToIndex, 44100);
  var oscillator = context.createOscillator();
  oscillator.type = "triangle";
  oscillator.frequency.value = 1e4;
  var compressor = context.createDynamicsCompressor();
  compressor.threshold.value = -50;
  compressor.knee.value = 40;
  compressor.ratio.value = 12;
  compressor.attack.value = 0;
  compressor.release.value = 0.25;
  oscillator.connect(compressor);
  compressor.connect(context.destination);
  oscillator.start(0);
  var _a2 = startRenderingAudio(context), renderPromise = _a2[0], finishRendering = _a2[1];
  var fingerprintPromise = renderPromise.then(function(buffer) {
    return getHash(buffer.getChannelData(0).subarray(hashFromIndex));
  }, function(error) {
    if (error.name === "timeout" || error.name === "suspended") {
      return -3;
    }
    throw error;
  });
  suppressUnhandledRejectionWarning(fingerprintPromise);
  return function() {
    finishRendering();
    return fingerprintPromise;
  };
}
function doesCurrentBrowserSuspendAudioContext() {
  return isWebKit$1() && !isDesktopSafari() && !isWebKit606OrNewer();
}
function startRenderingAudio(context) {
  var renderTryMaxCount = 3;
  var renderRetryDelay = 500;
  var runningMaxAwaitTime = 500;
  var runningSufficientTime = 5e3;
  var finalize = function() {
    return void 0;
  };
  var resultPromise = new Promise(function(resolve, reject) {
    var isFinalized = false;
    var renderTryCount = 0;
    var startedRunningAt = 0;
    context.oncomplete = function(event) {
      return resolve(event.renderedBuffer);
    };
    var startRunningTimeout = function() {
      setTimeout(function() {
        return reject(makeInnerError(
          "timeout"
          /* InnerErrorName.Timeout */
        ));
      }, Math.min(runningMaxAwaitTime, startedRunningAt + runningSufficientTime - Date.now()));
    };
    var tryRender = function() {
      try {
        var renderingPromise = context.startRendering();
        if (isPromise(renderingPromise)) {
          suppressUnhandledRejectionWarning(renderingPromise);
        }
        switch (context.state) {
          case "running":
            startedRunningAt = Date.now();
            if (isFinalized) {
              startRunningTimeout();
            }
            break;
          case "suspended":
            if (!document.hidden) {
              renderTryCount++;
            }
            if (isFinalized && renderTryCount >= renderTryMaxCount) {
              reject(makeInnerError(
                "suspended"
                /* InnerErrorName.Suspended */
              ));
            } else {
              setTimeout(tryRender, renderRetryDelay);
            }
            break;
        }
      } catch (error) {
        reject(error);
      }
    };
    tryRender();
    finalize = function() {
      if (!isFinalized) {
        isFinalized = true;
        if (startedRunningAt > 0) {
          startRunningTimeout();
        }
      }
    };
  });
  return [resultPromise, finalize];
}
function getHash(signal) {
  var hash = 0;
  for (var i2 = 0; i2 < signal.length; ++i2) {
    hash += Math.abs(signal[i2]);
  }
  return hash;
}
function makeInnerError(name2) {
  var error = new Error(name2);
  error.name = name2;
  return error;
}
function withIframe(action2, initialHtml, domPollInterval) {
  var _a2, _b2, _c2;
  if (domPollInterval === void 0) {
    domPollInterval = 50;
  }
  return __awaiter$a(this, void 0, void 0, function() {
    var d2, iframe;
    return __generator(this, function(_d2) {
      switch (_d2.label) {
        case 0:
          d2 = document;
          _d2.label = 1;
        case 1:
          if (!!d2.body)
            return [3, 3];
          return [4, wait(domPollInterval)];
        case 2:
          _d2.sent();
          return [3, 1];
        case 3:
          iframe = d2.createElement("iframe");
          _d2.label = 4;
        case 4:
          _d2.trys.push([4, , 10, 11]);
          return [4, new Promise(function(_resolve, _reject) {
            var isComplete = false;
            var resolve = function() {
              isComplete = true;
              _resolve();
            };
            var reject = function(error) {
              isComplete = true;
              _reject(error);
            };
            iframe.onload = resolve;
            iframe.onerror = reject;
            var style = iframe.style;
            style.setProperty("display", "block", "important");
            style.position = "absolute";
            style.top = "0";
            style.left = "0";
            style.visibility = "hidden";
            if (initialHtml && "srcdoc" in iframe) {
              iframe.srcdoc = initialHtml;
            } else {
              iframe.src = "about:blank";
            }
            d2.body.appendChild(iframe);
            var checkReadyState = function() {
              var _a3, _b3;
              if (isComplete) {
                return;
              }
              if (((_b3 = (_a3 = iframe.contentWindow) === null || _a3 === void 0 ? void 0 : _a3.document) === null || _b3 === void 0 ? void 0 : _b3.readyState) === "complete") {
                resolve();
              } else {
                setTimeout(checkReadyState, 10);
              }
            };
            checkReadyState();
          })];
        case 5:
          _d2.sent();
          _d2.label = 6;
        case 6:
          if (!!((_b2 = (_a2 = iframe.contentWindow) === null || _a2 === void 0 ? void 0 : _a2.document) === null || _b2 === void 0 ? void 0 : _b2.body))
            return [3, 8];
          return [4, wait(domPollInterval)];
        case 7:
          _d2.sent();
          return [3, 6];
        case 8:
          return [4, action2(iframe, iframe.contentWindow)];
        case 9:
          return [2, _d2.sent()];
        case 10:
          (_c2 = iframe.parentNode) === null || _c2 === void 0 ? void 0 : _c2.removeChild(iframe);
          return [
            7
            /*endfinally*/
          ];
        case 11:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function selectorToElement(selector) {
  var _a2 = parseSimpleCssSelector(selector), tag = _a2[0], attributes = _a2[1];
  var element = document.createElement(tag !== null && tag !== void 0 ? tag : "div");
  for (var _i = 0, _b2 = Object.keys(attributes); _i < _b2.length; _i++) {
    var name_1 = _b2[_i];
    var value = attributes[name_1].join(" ");
    if (name_1 === "style") {
      addStyleString(element.style, value);
    } else {
      element.setAttribute(name_1, value);
    }
  }
  return element;
}
function addStyleString(style, source) {
  for (var _i = 0, _a2 = source.split(";"); _i < _a2.length; _i++) {
    var property = _a2[_i];
    var match = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(property);
    if (match) {
      var name_2 = match[1], value = match[2], priority = match[4];
      style.setProperty(name_2, value, priority || "");
    }
  }
}
var testString = "mmMwWLliI0O&1";
var textSize = "48px";
var baseFonts = ["monospace", "sans-serif", "serif"];
var fontList = [
  // This is android-specific font from "Roboto" family
  "sans-serif-thin",
  "ARNO PRO",
  "Agency FB",
  "Arabic Typesetting",
  "Arial Unicode MS",
  "AvantGarde Bk BT",
  "BankGothic Md BT",
  "Batang",
  "Bitstream Vera Sans Mono",
  "Calibri",
  "Century",
  "Century Gothic",
  "Clarendon",
  "EUROSTILE",
  "Franklin Gothic",
  "Futura Bk BT",
  "Futura Md BT",
  "GOTHAM",
  "Gill Sans",
  "HELV",
  "Haettenschweiler",
  "Helvetica Neue",
  "Humanst521 BT",
  "Leelawadee",
  "Letter Gothic",
  "Levenim MT",
  "Lucida Bright",
  "Lucida Sans",
  "Menlo",
  "MS Mincho",
  "MS Outlook",
  "MS Reference Specialty",
  "MS UI Gothic",
  "MT Extra",
  "MYRIAD PRO",
  "Marlett",
  "Meiryo UI",
  "Microsoft Uighur",
  "Minion Pro",
  "Monotype Corsiva",
  "PMingLiU",
  "Pristina",
  "SCRIPTINA",
  "Segoe UI Light",
  "Serifa",
  "SimHei",
  "Small Fonts",
  "Staccato222 BT",
  "TRAJAN PRO",
  "Univers CE 55 Medium",
  "Vrinda",
  "ZWAdobeF"
];
function getFonts() {
  var _this = this;
  return withIframe(function(_2, _a2) {
    var document2 = _a2.document;
    return __awaiter$a(_this, void 0, void 0, function() {
      var holder, spansContainer, defaultWidth, defaultHeight, createSpan, createSpanWithFonts, initializeBaseFontsSpans, initializeFontsSpans, isFontAvailable, baseFontsSpans, fontsSpans, index2;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            holder = document2.body;
            holder.style.fontSize = textSize;
            spansContainer = document2.createElement("div");
            spansContainer.style.setProperty("visibility", "hidden", "important");
            defaultWidth = {};
            defaultHeight = {};
            createSpan = function(fontFamily) {
              var span = document2.createElement("span");
              var style = span.style;
              style.position = "absolute";
              style.top = "0";
              style.left = "0";
              style.fontFamily = fontFamily;
              span.textContent = testString;
              spansContainer.appendChild(span);
              return span;
            };
            createSpanWithFonts = function(fontToDetect, baseFont) {
              return createSpan("'".concat(fontToDetect, "',").concat(baseFont));
            };
            initializeBaseFontsSpans = function() {
              return baseFonts.map(createSpan);
            };
            initializeFontsSpans = function() {
              var spans = {};
              var _loop_1 = function(font2) {
                spans[font2] = baseFonts.map(function(baseFont) {
                  return createSpanWithFonts(font2, baseFont);
                });
              };
              for (var _i = 0, fontList_1 = fontList; _i < fontList_1.length; _i++) {
                var font = fontList_1[_i];
                _loop_1(font);
              }
              return spans;
            };
            isFontAvailable = function(fontSpans) {
              return baseFonts.some(function(baseFont, baseFontIndex) {
                return fontSpans[baseFontIndex].offsetWidth !== defaultWidth[baseFont] || fontSpans[baseFontIndex].offsetHeight !== defaultHeight[baseFont];
              });
            };
            baseFontsSpans = initializeBaseFontsSpans();
            fontsSpans = initializeFontsSpans();
            holder.appendChild(spansContainer);
            return [
              4,
              releaseEventLoop()
              // get the default width for the three base fonts
            ];
          case 1:
            _b2.sent();
            for (index2 = 0; index2 < baseFonts.length; index2++) {
              defaultWidth[baseFonts[index2]] = baseFontsSpans[index2].offsetWidth;
              defaultHeight[baseFonts[index2]] = baseFontsSpans[index2].offsetHeight;
            }
            return [2, fontList.filter(function(font) {
              return isFontAvailable(fontsSpans[font]);
            })];
        }
      });
    });
  });
}
function getPlugins() {
  var rawPlugins = navigator.plugins;
  if (!rawPlugins) {
    return void 0;
  }
  var plugins = [];
  for (var i2 = 0; i2 < rawPlugins.length; ++i2) {
    var plugin = rawPlugins[i2];
    if (!plugin) {
      continue;
    }
    var mimeTypes = [];
    for (var j2 = 0; j2 < plugin.length; ++j2) {
      var mimeType = plugin[j2];
      mimeTypes.push({
        type: mimeType.type,
        suffixes: mimeType.suffixes
      });
    }
    plugins.push({
      name: plugin.name,
      description: plugin.description,
      mimeTypes
    });
  }
  return plugins;
}
function getCanvasFingerprint() {
  return __awaiter$a(this, void 0, void 0, function() {
    var winding, geometry, text, _a2, canvas, context, textImage1, textImage2;
    return __generator(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          winding = false;
          _a2 = makeCanvasContext(), canvas = _a2[0], context = _a2[1];
          if (!!isSupported(canvas, context))
            return [3, 1];
          geometry = text = "unsupported";
          return [3, 5];
        case 1:
          winding = doesSupportWinding(context);
          renderTextImage(canvas, context);
          return [4, releaseEventLoop()];
        case 2:
          _b2.sent();
          textImage1 = canvasToString(canvas);
          textImage2 = canvasToString(canvas);
          if (!(textImage1 !== textImage2))
            return [3, 3];
          geometry = text = "unstable";
          return [3, 5];
        case 3:
          text = textImage1;
          renderGeometryImage(canvas, context);
          return [4, releaseEventLoop()];
        case 4:
          _b2.sent();
          geometry = canvasToString(canvas);
          _b2.label = 5;
        case 5:
          return [2, { winding, geometry, text }];
      }
    });
  });
}
function makeCanvasContext() {
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  return [canvas, canvas.getContext("2d")];
}
function isSupported(canvas, context) {
  return !!(context && canvas.toDataURL);
}
function doesSupportWinding(context) {
  context.rect(0, 0, 10, 10);
  context.rect(2, 2, 6, 6);
  return !context.isPointInPath(5, 5, "evenodd");
}
function renderTextImage(canvas, context) {
  canvas.width = 240;
  canvas.height = 60;
  context.textBaseline = "alphabetic";
  context.fillStyle = "#f60";
  context.fillRect(100, 1, 62, 20);
  context.fillStyle = "#069";
  context.font = '11pt "Times New Roman"';
  var printedText = "Cwm fjordbank gly ".concat(
    String.fromCharCode(55357, 56835)
    /* 😃 */
  );
  context.fillText(printedText, 2, 15);
  context.fillStyle = "rgba(102, 204, 0, 0.2)";
  context.font = "18pt Arial";
  context.fillText(printedText, 4, 45);
}
function renderGeometryImage(canvas, context) {
  canvas.width = 122;
  canvas.height = 110;
  context.globalCompositeOperation = "multiply";
  for (var _i = 0, _a2 = [
    ["#f2f", 40, 40],
    ["#2ff", 80, 40],
    ["#ff2", 60, 80]
  ]; _i < _a2.length; _i++) {
    var _b2 = _a2[_i], color = _b2[0], x2 = _b2[1], y2 = _b2[2];
    context.fillStyle = color;
    context.beginPath();
    context.arc(x2, y2, 40, 0, Math.PI * 2, true);
    context.closePath();
    context.fill();
  }
  context.fillStyle = "#f9c";
  context.arc(60, 60, 60, 0, Math.PI * 2, true);
  context.arc(60, 60, 20, 0, Math.PI * 2, true);
  context.fill("evenodd");
}
function canvasToString(canvas) {
  return canvas.toDataURL();
}
function getTouchSupport() {
  var n2 = navigator;
  var maxTouchPoints = 0;
  var touchEvent;
  if (n2.maxTouchPoints !== void 0) {
    maxTouchPoints = toInt(n2.maxTouchPoints);
  } else if (n2.msMaxTouchPoints !== void 0) {
    maxTouchPoints = n2.msMaxTouchPoints;
  }
  try {
    document.createEvent("TouchEvent");
    touchEvent = true;
  } catch (_a2) {
    touchEvent = false;
  }
  var touchStart = "ontouchstart" in window;
  return {
    maxTouchPoints,
    touchEvent,
    touchStart
  };
}
function getOsCpu() {
  return navigator.oscpu;
}
function getLanguages() {
  var n2 = navigator;
  var result = [];
  var language = n2.language || n2.userLanguage || n2.browserLanguage || n2.systemLanguage;
  if (language !== void 0) {
    result.push([language]);
  }
  if (Array.isArray(n2.languages)) {
    if (!(isChromium() && isChromium86OrNewer())) {
      result.push(n2.languages);
    }
  } else if (typeof n2.languages === "string") {
    var languages = n2.languages;
    if (languages) {
      result.push(languages.split(","));
    }
  }
  return result;
}
function getColorDepth() {
  return window.screen.colorDepth;
}
function getDeviceMemory() {
  return replaceNaN(toFloat(navigator.deviceMemory), void 0);
}
function getScreenResolution() {
  var s2 = screen;
  var parseDimension = function(value) {
    return replaceNaN(toInt(value), null);
  };
  var dimensions = [parseDimension(s2.width), parseDimension(s2.height)];
  dimensions.sort().reverse();
  return dimensions;
}
var screenFrameCheckInterval = 2500;
var roundingPrecision = 10;
var screenFrameBackup;
var screenFrameSizeTimeoutId;
function watchScreenFrame() {
  if (screenFrameSizeTimeoutId !== void 0) {
    return;
  }
  var checkScreenFrame = function() {
    var frameSize = getCurrentScreenFrame();
    if (isFrameSizeNull(frameSize)) {
      screenFrameSizeTimeoutId = setTimeout(checkScreenFrame, screenFrameCheckInterval);
    } else {
      screenFrameBackup = frameSize;
      screenFrameSizeTimeoutId = void 0;
    }
  };
  checkScreenFrame();
}
function getScreenFrame() {
  var _this = this;
  watchScreenFrame();
  return function() {
    return __awaiter$a(_this, void 0, void 0, function() {
      var frameSize;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            frameSize = getCurrentScreenFrame();
            if (!isFrameSizeNull(frameSize))
              return [3, 2];
            if (screenFrameBackup) {
              return [2, __spreadArray([], screenFrameBackup, true)];
            }
            if (!getFullscreenElement())
              return [3, 2];
            return [4, exitFullscreen()];
          case 1:
            _a2.sent();
            frameSize = getCurrentScreenFrame();
            _a2.label = 2;
          case 2:
            if (!isFrameSizeNull(frameSize)) {
              screenFrameBackup = frameSize;
            }
            return [2, frameSize];
        }
      });
    });
  };
}
function getRoundedScreenFrame() {
  var _this = this;
  var screenFrameGetter = getScreenFrame();
  return function() {
    return __awaiter$a(_this, void 0, void 0, function() {
      var frameSize, processSize;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, screenFrameGetter()];
          case 1:
            frameSize = _a2.sent();
            processSize = function(sideSize) {
              return sideSize === null ? null : round$1(sideSize, roundingPrecision);
            };
            return [2, [processSize(frameSize[0]), processSize(frameSize[1]), processSize(frameSize[2]), processSize(frameSize[3])]];
        }
      });
    });
  };
}
function getCurrentScreenFrame() {
  var s2 = screen;
  return [
    replaceNaN(toFloat(s2.availTop), null),
    replaceNaN(toFloat(s2.width) - toFloat(s2.availWidth) - replaceNaN(toFloat(s2.availLeft), 0), null),
    replaceNaN(toFloat(s2.height) - toFloat(s2.availHeight) - replaceNaN(toFloat(s2.availTop), 0), null),
    replaceNaN(toFloat(s2.availLeft), null)
  ];
}
function isFrameSizeNull(frameSize) {
  for (var i2 = 0; i2 < 4; ++i2) {
    if (frameSize[i2]) {
      return false;
    }
  }
  return true;
}
function getHardwareConcurrency() {
  return replaceNaN(toInt(navigator.hardwareConcurrency), void 0);
}
function getTimezone() {
  var _a2;
  var DateTimeFormat = (_a2 = window.Intl) === null || _a2 === void 0 ? void 0 : _a2.DateTimeFormat;
  if (DateTimeFormat) {
    var timezone = new DateTimeFormat().resolvedOptions().timeZone;
    if (timezone) {
      return timezone;
    }
  }
  var offset2 = -getTimezoneOffset();
  return "UTC".concat(offset2 >= 0 ? "+" : "").concat(Math.abs(offset2));
}
function getTimezoneOffset() {
  var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  return Math.max(
    // `getTimezoneOffset` returns a number as a string in some unidentified cases
    toFloat(new Date(currentYear, 0, 1).getTimezoneOffset()),
    toFloat(new Date(currentYear, 6, 1).getTimezoneOffset())
  );
}
function getSessionStorage() {
  try {
    return !!window.sessionStorage;
  } catch (error) {
    return true;
  }
}
function getLocalStorage() {
  try {
    return !!window.localStorage;
  } catch (e2) {
    return true;
  }
}
function getIndexedDB() {
  if (isTrident() || isEdgeHTML()) {
    return void 0;
  }
  try {
    return !!window.indexedDB;
  } catch (e2) {
    return true;
  }
}
function getOpenDatabase() {
  return !!window.openDatabase;
}
function getCpuClass() {
  return navigator.cpuClass;
}
function getPlatform() {
  var platform2 = navigator.platform;
  if (platform2 === "MacIntel") {
    if (isWebKit$1() && !isDesktopSafari()) {
      return isIPad() ? "iPad" : "iPhone";
    }
  }
  return platform2;
}
function getVendor() {
  return navigator.vendor || "";
}
function getVendorFlavors() {
  var flavors = [];
  for (var _i = 0, _a2 = [
    // Blink and some browsers on iOS
    "chrome",
    // Safari on macOS
    "safari",
    // Chrome on iOS (checked in 85 on 13 and 87 on 14)
    "__crWeb",
    "__gCrWeb",
    // Yandex Browser on iOS, macOS and Android (checked in 21.2 on iOS 14, macOS and Android)
    "yandex",
    // Yandex Browser on iOS (checked in 21.2 on 14)
    "__yb",
    "__ybro",
    // Firefox on iOS (checked in 32 on 14)
    "__firefox__",
    // Edge on iOS (checked in 46 on 14)
    "__edgeTrackingPreventionStatistics",
    "webkit",
    // Opera Touch on iOS (checked in 2.6 on 14)
    "oprt",
    // Samsung Internet on Android (checked in 11.1)
    "samsungAr",
    // UC Browser on Android (checked in 12.10 and 13.0)
    "ucweb",
    "UCShellJava",
    // Puffin on Android (checked in 9.0)
    "puffinDevice"
    // UC on iOS and Opera on Android have no specific global variables
    // Edge for Android isn't checked
  ]; _i < _a2.length; _i++) {
    var key = _a2[_i];
    var value = window[key];
    if (value && typeof value === "object") {
      flavors.push(key);
    }
  }
  return flavors.sort();
}
function areCookiesEnabled() {
  var d2 = document;
  try {
    d2.cookie = "cookietest=1; SameSite=Strict;";
    var result = d2.cookie.indexOf("cookietest=") !== -1;
    d2.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT";
    return result;
  } catch (e2) {
    return false;
  }
}
function getFilters() {
  var fromB64 = atob;
  return {
    abpIndo: [
      "#Iklan-Melayang",
      "#Kolom-Iklan-728",
      "#SidebarIklan-wrapper",
      '[title="ALIENBOLA" i]',
      fromB64("I0JveC1CYW5uZXItYWRz")
    ],
    abpvn: [".quangcao", "#mobileCatfish", fromB64("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [
      ".mainostila",
      fromB64("LnNwb25zb3JpdA=="),
      ".ylamainos",
      fromB64("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")
    ],
    adBlockPersian: [
      "#navbar_notice_50",
      ".kadr",
      'TABLE[width="140px"]',
      "#divAgahi",
      fromB64("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")
    ],
    adBlockWarningRemoval: [
      "#adblock-honeypot",
      ".adblocker-root",
      ".wp_adblock_detect",
      fromB64("LmhlYWRlci1ibG9ja2VkLWFk"),
      fromB64("I2FkX2Jsb2NrZXI=")
    ],
    adGuardAnnoyances: [
      ".hs-sosyal",
      "#cookieconsentdiv",
      'div[class^="app_gdpr"]',
      ".as-oil",
      '[data-cypress="soft-push-notification-modal"]'
    ],
    adGuardBase: [
      ".BetterJsPopOverlay",
      fromB64("I2FkXzMwMFgyNTA="),
      fromB64("I2Jhbm5lcmZsb2F0MjI="),
      fromB64("I2NhbXBhaWduLWJhbm5lcg=="),
      fromB64("I0FkLUNvbnRlbnQ=")
    ],
    adGuardChinese: [
      fromB64("LlppX2FkX2FfSA=="),
      fromB64("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"),
      "#widget-quan",
      fromB64("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"),
      fromB64("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")
    ],
    adGuardFrench: [
      "#pavePub",
      fromB64("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"),
      ".mobile_adhesion",
      ".widgetadv",
      fromB64("LmFkc19iYW4=")
    ],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: [
      "#kauli_yad_1",
      fromB64("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="),
      fromB64("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="),
      fromB64("LmFkZ29vZ2xl"),
      fromB64("Ll9faXNib29zdFJldHVybkFk")
    ],
    adGuardMobile: [
      fromB64("YW1wLWF1dG8tYWRz"),
      fromB64("LmFtcF9hZA=="),
      'amp-embed[type="24smi"]',
      "#mgid_iframe1",
      fromB64("I2FkX2ludmlld19hcmVh")
    ],
    adGuardRussian: [
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="),
      fromB64("LnJlY2xhbWE="),
      'div[id^="smi2adblock"]',
      fromB64("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"),
      "#psyduckpockeball"
    ],
    adGuardSocial: [
      fromB64("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="),
      fromB64("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="),
      ".etsy-tweet",
      "#inlineShare",
      ".popup-social"
    ],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: [
      "#qoo-counter",
      fromB64("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="),
      fromB64("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="),
      fromB64("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="),
      "#top100counter"
    ],
    adGuardTurkish: [
      "#backkapat",
      fromB64("I3Jla2xhbWk="),
      fromB64("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="),
      fromB64("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"),
      fromB64("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")
    ],
    bulgarian: [fromB64("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [
      ".yb-floorad",
      fromB64("LndpZGdldF9wb19hZHNfd2lkZ2V0"),
      fromB64("LnRyYWZmaWNqdW5reS1hZA=="),
      ".textad_headline",
      fromB64("LnNwb25zb3JlZC10ZXh0LWxpbmtz")
    ],
    easyListChina: [
      fromB64("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="),
      fromB64("LmZyb250cGFnZUFkdk0="),
      "#taotaole",
      "#aafoot.top_box",
      ".cfa_popup"
    ],
    easyListCookie: [
      ".ezmob-footer",
      ".cc-CookieWarning",
      "[data-cookie-number]",
      fromB64("LmF3LWNvb2tpZS1iYW5uZXI="),
      ".sygnal24-gdpr-modal-wrap"
    ],
    easyListCzechSlovak: [
      "#onlajny-stickers",
      fromB64("I3Jla2xhbW5pLWJveA=="),
      fromB64("LnJla2xhbWEtbWVnYWJvYXJk"),
      ".sklik",
      fromB64("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")
    ],
    easyListDutch: [
      fromB64("I2FkdmVydGVudGll"),
      fromB64("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="),
      ".adstekst",
      fromB64("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="),
      "#semilo-lrectangle"
    ],
    easyListGermany: [
      "#SSpotIMPopSlider",
      fromB64("LnNwb25zb3JsaW5rZ3J1ZW4="),
      fromB64("I3dlcmJ1bmdza3k="),
      fromB64("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")
    ],
    easyListItaly: [
      fromB64("LmJveF9hZHZfYW5udW5jaQ=="),
      ".sb-box-pubbliredazionale",
      fromB64("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")
    ],
    easyListLithuania: [
      fromB64("LnJla2xhbW9zX3RhcnBhcw=="),
      fromB64("LnJla2xhbW9zX251b3JvZG9z"),
      fromB64("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"),
      fromB64("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"),
      fromB64("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")
    ],
    estonian: [fromB64("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [
      ".open.pushModal",
      "#issuem-leaky-paywall-articles-zero-remaining-nag",
      "#sovrn_container",
      'div[class$="-hide"][zoompage-fontsize][style="display: block;"]',
      ".BlockNag__Card"
    ],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [
      fromB64("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="),
      fromB64("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="),
      "article.category-samarbete",
      fromB64("ZGl2LmhvbGlkQWRz"),
      "ul.adsmodern"
    ],
    greekAdBlock: [
      fromB64("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"),
      fromB64("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="),
      fromB64("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"),
      "DIV.agores300",
      "TABLE.advright"
    ],
    hungarian: [
      "#cemp_doboz",
      ".optimonk-iframe-container",
      fromB64("LmFkX19tYWlu"),
      fromB64("W2NsYXNzKj0iR29vZ2xlQWRzIl0="),
      "#hirdetesek_box"
    ],
    iDontCareAboutCookies: [
      '.alert-info[data-block-track*="CookieNotice"]',
      ".ModuleTemplateCookieIndicator",
      ".o--cookies--container",
      "#cookies-policy-sticky",
      "#stickyCookieBar"
    ],
    icelandicAbp: [fromB64("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [
      fromB64("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="),
      fromB64("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")
    ],
    listKr: [
      fromB64("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="),
      fromB64("I2xpdmVyZUFkV3JhcHBlcg=="),
      fromB64("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="),
      fromB64("aW5zLmZhc3R2aWV3LWFk"),
      ".revenue_unit_item.dable"
    ],
    listeAr: [
      fromB64("LmdlbWluaUxCMUFk"),
      ".right-and-left-sponsers",
      fromB64("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="),
      fromB64("YVtocmVmKj0iYm9vcmFxLm9yZyJd"),
      fromB64("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")
    ],
    listeFr: [
      fromB64("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="),
      fromB64("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="),
      fromB64("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="),
      ".site-pub-interstitiel",
      'div[id^="crt-"][data-criteo-id]'
    ],
    officialPolish: [
      "#ceneo-placeholder-ceneo-12",
      fromB64("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"),
      fromB64("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="),
      fromB64("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="),
      fromB64("ZGl2I3NrYXBpZWNfYWQ=")
    ],
    ro: [
      fromB64("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="),
      fromB64("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"),
      'a[href^="/url/"]'
    ],
    ruAd: [
      fromB64("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"),
      fromB64("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="),
      fromB64("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="),
      "#pgeldiz",
      ".yandex-rtb-block"
    ],
    thaiAds: [
      "a[href*=macau-uta-popup]",
      fromB64("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="),
      fromB64("LmFkczMwMHM="),
      ".bumq",
      ".img-kosana"
    ],
    webAnnoyancesUltralist: [
      "#mod-social-share-2",
      "#social-tools",
      fromB64("LmN0cGwtZnVsbGJhbm5lcg=="),
      ".zergnet-recommend",
      ".yt.btn-link.btn-md.btn"
    ]
  };
}
function getDomBlockers(_a2) {
  var _b2 = _a2 === void 0 ? {} : _a2, debug = _b2.debug;
  return __awaiter$a(this, void 0, void 0, function() {
    var filters, filterNames, allSelectors, blockedSelectors, activeBlockers;
    var _c2;
    return __generator(this, function(_d2) {
      switch (_d2.label) {
        case 0:
          if (!isApplicable()) {
            return [2, void 0];
          }
          filters = getFilters();
          filterNames = Object.keys(filters);
          allSelectors = (_c2 = []).concat.apply(_c2, filterNames.map(function(filterName) {
            return filters[filterName];
          }));
          return [4, getBlockedSelectors(allSelectors)];
        case 1:
          blockedSelectors = _d2.sent();
          if (debug) {
            printDebug(filters, blockedSelectors);
          }
          activeBlockers = filterNames.filter(function(filterName) {
            var selectors = filters[filterName];
            var blockedCount = countTruthy(selectors.map(function(selector) {
              return blockedSelectors[selector];
            }));
            return blockedCount > selectors.length * 0.6;
          });
          activeBlockers.sort();
          return [2, activeBlockers];
      }
    });
  });
}
function isApplicable() {
  return isWebKit$1() || isAndroid();
}
function getBlockedSelectors(selectors) {
  var _a2;
  return __awaiter$a(this, void 0, void 0, function() {
    var d2, root, elements, blockedSelectors, i2, element, holder, i2;
    return __generator(this, function(_b2) {
      switch (_b2.label) {
        case 0:
          d2 = document;
          root = d2.createElement("div");
          elements = new Array(selectors.length);
          blockedSelectors = {};
          forceShow(root);
          for (i2 = 0; i2 < selectors.length; ++i2) {
            element = selectorToElement(selectors[i2]);
            if (element.tagName === "DIALOG") {
              element.show();
            }
            holder = d2.createElement("div");
            forceShow(holder);
            holder.appendChild(element);
            root.appendChild(holder);
            elements[i2] = element;
          }
          _b2.label = 1;
        case 1:
          if (!!d2.body)
            return [3, 3];
          return [4, wait(50)];
        case 2:
          _b2.sent();
          return [3, 1];
        case 3:
          d2.body.appendChild(root);
          return [4, releaseEventLoop()];
        case 4:
          _b2.sent();
          try {
            for (i2 = 0; i2 < selectors.length; ++i2) {
              if (!elements[i2].offsetParent) {
                blockedSelectors[selectors[i2]] = true;
              }
            }
          } finally {
            (_a2 = root.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(root);
          }
          return [2, blockedSelectors];
      }
    });
  });
}
function forceShow(element) {
  element.style.setProperty("visibility", "hidden", "important");
  element.style.setProperty("display", "block", "important");
}
function printDebug(filters, blockedSelectors) {
  var message = "DOM blockers debug:\n```";
  for (var _i = 0, _a2 = Object.keys(filters); _i < _a2.length; _i++) {
    var filterName = _a2[_i];
    message += "\n".concat(filterName, ":");
    for (var _b2 = 0, _c2 = filters[filterName]; _b2 < _c2.length; _b2++) {
      var selector = _c2[_b2];
      message += "\n  ".concat(blockedSelectors[selector] ? "🚫" : "➡️", " ").concat(selector);
    }
  }
  console.log("".concat(message, "\n```"));
}
function getColorGamut() {
  for (var _i = 0, _a2 = ["rec2020", "p3", "srgb"]; _i < _a2.length; _i++) {
    var gamut = _a2[_i];
    if (matchMedia("(color-gamut: ".concat(gamut, ")")).matches) {
      return gamut;
    }
  }
  return void 0;
}
function areColorsInverted() {
  if (doesMatch$4("inverted")) {
    return true;
  }
  if (doesMatch$4("none")) {
    return false;
  }
  return void 0;
}
function doesMatch$4(value) {
  return matchMedia("(inverted-colors: ".concat(value, ")")).matches;
}
function areColorsForced() {
  if (doesMatch$3("active")) {
    return true;
  }
  if (doesMatch$3("none")) {
    return false;
  }
  return void 0;
}
function doesMatch$3(value) {
  return matchMedia("(forced-colors: ".concat(value, ")")).matches;
}
var maxValueToCheck = 100;
function getMonochromeDepth() {
  if (!matchMedia("(min-monochrome: 0)").matches) {
    return void 0;
  }
  for (var i2 = 0; i2 <= maxValueToCheck; ++i2) {
    if (matchMedia("(max-monochrome: ".concat(i2, ")")).matches) {
      return i2;
    }
  }
  throw new Error("Too high value");
}
function getContrastPreference() {
  if (doesMatch$2("no-preference")) {
    return 0;
  }
  if (doesMatch$2("high") || doesMatch$2("more")) {
    return 1;
  }
  if (doesMatch$2("low") || doesMatch$2("less")) {
    return -1;
  }
  if (doesMatch$2("forced")) {
    return 10;
  }
  return void 0;
}
function doesMatch$2(value) {
  return matchMedia("(prefers-contrast: ".concat(value, ")")).matches;
}
function isMotionReduced() {
  if (doesMatch$1("reduce")) {
    return true;
  }
  if (doesMatch$1("no-preference")) {
    return false;
  }
  return void 0;
}
function doesMatch$1(value) {
  return matchMedia("(prefers-reduced-motion: ".concat(value, ")")).matches;
}
function isHDR() {
  if (doesMatch("high")) {
    return true;
  }
  if (doesMatch("standard")) {
    return false;
  }
  return void 0;
}
function doesMatch(value) {
  return matchMedia("(dynamic-range: ".concat(value, ")")).matches;
}
var M$7 = Math;
var fallbackFn = function() {
  return 0;
};
function getMathFingerprint() {
  var acos = M$7.acos || fallbackFn;
  var acosh = M$7.acosh || fallbackFn;
  var asin = M$7.asin || fallbackFn;
  var asinh = M$7.asinh || fallbackFn;
  var atanh = M$7.atanh || fallbackFn;
  var atan = M$7.atan || fallbackFn;
  var sin = M$7.sin || fallbackFn;
  var sinh = M$7.sinh || fallbackFn;
  var cos = M$7.cos || fallbackFn;
  var cosh = M$7.cosh || fallbackFn;
  var tan = M$7.tan || fallbackFn;
  var tanh = M$7.tanh || fallbackFn;
  var exp = M$7.exp || fallbackFn;
  var expm1 = M$7.expm1 || fallbackFn;
  var log1p = M$7.log1p || fallbackFn;
  var powPI = function(value) {
    return M$7.pow(M$7.PI, value);
  };
  var acoshPf = function(value) {
    return M$7.log(value + M$7.sqrt(value * value - 1));
  };
  var asinhPf = function(value) {
    return M$7.log(value + M$7.sqrt(value * value + 1));
  };
  var atanhPf = function(value) {
    return M$7.log((1 + value) / (1 - value)) / 2;
  };
  var sinhPf = function(value) {
    return M$7.exp(value) - 1 / M$7.exp(value) / 2;
  };
  var coshPf = function(value) {
    return (M$7.exp(value) + 1 / M$7.exp(value)) / 2;
  };
  var expm1Pf = function(value) {
    return M$7.exp(value) - 1;
  };
  var tanhPf = function(value) {
    return (M$7.exp(2 * value) - 1) / (M$7.exp(2 * value) + 1);
  };
  var log1pPf = function(value) {
    return M$7.log(1 + value);
  };
  return {
    acos: acos(0.12312423423423424),
    acosh: acosh(1e308),
    acoshPf: acoshPf(1e154),
    asin: asin(0.12312423423423424),
    asinh: asinh(1),
    asinhPf: asinhPf(1),
    atanh: atanh(0.5),
    atanhPf: atanhPf(0.5),
    atan: atan(0.5),
    sin: sin(-1e300),
    sinh: sinh(1),
    sinhPf: sinhPf(1),
    cos: cos(10.000000000123),
    cosh: cosh(1),
    coshPf: coshPf(1),
    tan: tan(-1e300),
    tanh: tanh(1),
    tanhPf: tanhPf(1),
    exp: exp(1),
    expm1: expm1(1),
    expm1Pf: expm1Pf(1),
    log1p: log1p(10),
    log1pPf: log1pPf(10),
    powPI: powPI(-100)
  };
}
var defaultText = "mmMwWLliI0fiflO&1";
var presets = {
  /**
   * The default font. User can change it in desktop Chrome, desktop Firefox, IE 11,
   * Android Chrome (but only when the size is ≥ than the default) and Android Firefox.
   */
  default: [],
  /** OS font on macOS. User can change its size and weight. Applies after Safari restart. */
  apple: [{ font: "-apple-system-body" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  serif: [{ fontFamily: "serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  sans: [{ fontFamily: "sans-serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  mono: [{ fontFamily: "monospace" }],
  /**
   * Check the smallest allowed font size. User can change it in desktop Chrome, desktop Firefox and desktop Safari.
   * The height can be 0 in Chrome on a retina display.
   */
  min: [{ fontSize: "1px" }],
  /** Tells one OS from another in desktop Chrome. */
  system: [{ fontFamily: "system-ui" }]
};
function getFontPreferences() {
  return withNaturalFonts(function(document2, container2) {
    var elements = {};
    var sizes = {};
    for (var _i = 0, _a2 = Object.keys(presets); _i < _a2.length; _i++) {
      var key = _a2[_i];
      var _b2 = presets[key], _c2 = _b2[0], style = _c2 === void 0 ? {} : _c2, _d2 = _b2[1], text = _d2 === void 0 ? defaultText : _d2;
      var element = document2.createElement("span");
      element.textContent = text;
      element.style.whiteSpace = "nowrap";
      for (var _e2 = 0, _f2 = Object.keys(style); _e2 < _f2.length; _e2++) {
        var name_1 = _f2[_e2];
        var value = style[name_1];
        if (value !== void 0) {
          element.style[name_1] = value;
        }
      }
      elements[key] = element;
      container2.appendChild(document2.createElement("br"));
      container2.appendChild(element);
    }
    for (var _g = 0, _h = Object.keys(presets); _g < _h.length; _g++) {
      var key = _h[_g];
      sizes[key] = elements[key].getBoundingClientRect().width;
    }
    return sizes;
  });
}
function withNaturalFonts(action2, containerWidthPx) {
  if (containerWidthPx === void 0) {
    containerWidthPx = 4e3;
  }
  return withIframe(function(_2, iframeWindow) {
    var iframeDocument = iframeWindow.document;
    var iframeBody = iframeDocument.body;
    var bodyStyle = iframeBody.style;
    bodyStyle.width = "".concat(containerWidthPx, "px");
    bodyStyle.webkitTextSizeAdjust = bodyStyle.textSizeAdjust = "none";
    if (isChromium()) {
      iframeBody.style.zoom = "".concat(1 / iframeWindow.devicePixelRatio);
    } else if (isWebKit$1()) {
      iframeBody.style.zoom = "reset";
    }
    var linesOfText = iframeDocument.createElement("div");
    linesOfText.textContent = __spreadArray([], Array(containerWidthPx / 20 << 0), true).map(function() {
      return "word";
    }).join(" ");
    iframeBody.appendChild(linesOfText);
    return action2(iframeDocument, iframeBody);
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">');
}
function isPdfViewerEnabled() {
  return navigator.pdfViewerEnabled;
}
function getArchitecture() {
  var f2 = new Float32Array(1);
  var u8 = new Uint8Array(f2.buffer);
  f2[0] = Infinity;
  f2[0] = f2[0] - f2[0];
  return u8[3];
}
function getApplePayState() {
  var ApplePaySession = window.ApplePaySession;
  if (typeof (ApplePaySession === null || ApplePaySession === void 0 ? void 0 : ApplePaySession.canMakePayments) !== "function") {
    return -1;
  }
  try {
    return ApplePaySession.canMakePayments() ? 1 : 0;
  } catch (error) {
    return getStateFromError(error);
  }
}
function getStateFromError(error) {
  if (error instanceof Error) {
    if (error.name === "InvalidAccessError") {
      if (/\bfrom\b.*\binsecure\b/i.test(error.message)) {
        return -2;
      }
      if (/\bdifferent\b.*\borigin\b.*top.level\b.*\bframe\b/i.test(error.message)) {
        return -3;
      }
    }
    if (error.name === "SecurityError") {
      if (/\bthird.party iframes?.*\bnot.allowed\b/i.test(error.message)) {
        return -3;
      }
    }
  }
  throw error;
}
function getPrivateClickMeasurement() {
  var _a2;
  var link = document.createElement("a");
  var sourceId = (_a2 = link.attributionSourceId) !== null && _a2 !== void 0 ? _a2 : link.attributionsourceid;
  return sourceId === void 0 ? void 0 : String(sourceId);
}
var STATUS_NO_GL_CONTEXT = -1;
var STATUS_GET_PARAMETER_NOT_A_FUNCTION = -2;
var validContextParameters = /* @__PURE__ */ new Set([
  10752,
  2849,
  2884,
  2885,
  2886,
  2928,
  2929,
  2930,
  2931,
  2932,
  2960,
  2961,
  2962,
  2963,
  2964,
  2965,
  2966,
  2967,
  2968,
  2978,
  3024,
  3042,
  3088,
  3089,
  3106,
  3107,
  32773,
  32777,
  32777,
  32823,
  32824,
  32936,
  32937,
  32938,
  32939,
  32968,
  32969,
  32970,
  32971,
  3317,
  33170,
  3333,
  3379,
  3386,
  33901,
  33902,
  34016,
  34024,
  34076,
  3408,
  3410,
  3411,
  3412,
  3413,
  3414,
  3415,
  34467,
  34816,
  34817,
  34818,
  34819,
  34877,
  34921,
  34930,
  35660,
  35661,
  35724,
  35738,
  35739,
  36003,
  36004,
  36005,
  36347,
  36348,
  36349,
  37440,
  37441,
  37443,
  7936,
  7937,
  7938
  // SAMPLE_ALPHA_TO_COVERAGE (32926) and SAMPLE_COVERAGE (32928) are excluded because they trigger a console warning
  // in IE, Chrome ≤ 59 and Safari ≤ 13 and give no entropy.
]);
var validExtensionParams = /* @__PURE__ */ new Set([
  34047,
  35723,
  36063,
  34852,
  34853,
  34854,
  34229,
  36392,
  36795,
  38449
  // MAX_VIEWS_OVR
]);
var shaderTypes = ["FRAGMENT_SHADER", "VERTEX_SHADER"];
var precisionTypes = ["LOW_FLOAT", "MEDIUM_FLOAT", "HIGH_FLOAT", "LOW_INT", "MEDIUM_INT", "HIGH_INT"];
var rendererInfoExtensionName = "WEBGL_debug_renderer_info";
function getWebGlBasics(_a2) {
  var _b2, _c2, _d2, _e2, _f2, _g;
  var cache2 = _a2.cache;
  var gl2 = getWebGLContext(cache2);
  if (!gl2) {
    return STATUS_NO_GL_CONTEXT;
  }
  if (!isValidParameterGetter(gl2)) {
    return STATUS_GET_PARAMETER_NOT_A_FUNCTION;
  }
  var debugExtension = shouldAvoidDebugRendererInfo() ? null : gl2.getExtension(rendererInfoExtensionName);
  return {
    version: ((_b2 = gl2.getParameter(gl2.VERSION)) === null || _b2 === void 0 ? void 0 : _b2.toString()) || "",
    vendor: ((_c2 = gl2.getParameter(gl2.VENDOR)) === null || _c2 === void 0 ? void 0 : _c2.toString()) || "",
    vendorUnmasked: debugExtension ? (_d2 = gl2.getParameter(debugExtension.UNMASKED_VENDOR_WEBGL)) === null || _d2 === void 0 ? void 0 : _d2.toString() : "",
    renderer: ((_e2 = gl2.getParameter(gl2.RENDERER)) === null || _e2 === void 0 ? void 0 : _e2.toString()) || "",
    rendererUnmasked: debugExtension ? (_f2 = gl2.getParameter(debugExtension.UNMASKED_RENDERER_WEBGL)) === null || _f2 === void 0 ? void 0 : _f2.toString() : "",
    shadingLanguageVersion: ((_g = gl2.getParameter(gl2.SHADING_LANGUAGE_VERSION)) === null || _g === void 0 ? void 0 : _g.toString()) || ""
  };
}
function getWebGlExtensions(_a2) {
  var cache2 = _a2.cache;
  var gl2 = getWebGLContext(cache2);
  if (!gl2) {
    return STATUS_NO_GL_CONTEXT;
  }
  if (!isValidParameterGetter(gl2)) {
    return STATUS_GET_PARAMETER_NOT_A_FUNCTION;
  }
  var extensions2 = gl2.getSupportedExtensions();
  var contextAttributes = gl2.getContextAttributes();
  var attributes = [];
  var parameters = [];
  var extensionParameters = [];
  var shaderPrecisions = [];
  if (contextAttributes) {
    for (var _i = 0, _b2 = Object.keys(contextAttributes); _i < _b2.length; _i++) {
      var attributeName = _b2[_i];
      attributes.push("".concat(attributeName, "=").concat(contextAttributes[attributeName]));
    }
  }
  var constants = getConstantsFromPrototype(gl2);
  for (var _c2 = 0, constants_1 = constants; _c2 < constants_1.length; _c2++) {
    var constant = constants_1[_c2];
    var code = gl2[constant];
    parameters.push("".concat(constant, "=").concat(code).concat(validContextParameters.has(code) ? "=".concat(gl2.getParameter(code)) : ""));
  }
  if (extensions2) {
    for (var _d2 = 0, extensions_1 = extensions2; _d2 < extensions_1.length; _d2++) {
      var name_1 = extensions_1[_d2];
      if (name_1 === rendererInfoExtensionName && shouldAvoidDebugRendererInfo()) {
        continue;
      }
      var extension = gl2.getExtension(name_1);
      if (!extension) {
        continue;
      }
      for (var _e2 = 0, _f2 = getConstantsFromPrototype(extension); _e2 < _f2.length; _e2++) {
        var constant = _f2[_e2];
        var code = extension[constant];
        extensionParameters.push("".concat(constant, "=").concat(code).concat(validExtensionParams.has(code) ? "=".concat(gl2.getParameter(code)) : ""));
      }
    }
  }
  for (var _g = 0, shaderTypes_1 = shaderTypes; _g < shaderTypes_1.length; _g++) {
    var shaderType = shaderTypes_1[_g];
    for (var _h = 0, precisionTypes_1 = precisionTypes; _h < precisionTypes_1.length; _h++) {
      var precisionType = precisionTypes_1[_h];
      var shaderPrecision = getShaderPrecision(gl2, shaderType, precisionType);
      shaderPrecisions.push("".concat(shaderType, ".").concat(precisionType, "=").concat(shaderPrecision.join(",")));
    }
  }
  extensionParameters.sort();
  parameters.sort();
  return {
    contextAttributes: attributes,
    parameters,
    shaderPrecisions,
    extensions: extensions2,
    extensionParameters
  };
}
function getWebGLContext(cache2) {
  if (cache2.webgl) {
    return cache2.webgl.context;
  }
  var canvas = document.createElement("canvas");
  var context;
  canvas.addEventListener("webglCreateContextError", function() {
    return context = void 0;
  });
  for (var _i = 0, _a2 = ["webgl", "experimental-webgl"]; _i < _a2.length; _i++) {
    var type = _a2[_i];
    try {
      context = canvas.getContext(type);
    } catch (_b2) {
    }
    if (context) {
      break;
    }
  }
  cache2.webgl = { context };
  return context;
}
function getShaderPrecision(gl2, shaderType, precisionType) {
  var shaderPrecision = gl2.getShaderPrecisionFormat(gl2[shaderType], gl2[precisionType]);
  return shaderPrecision ? [shaderPrecision.rangeMin, shaderPrecision.rangeMax, shaderPrecision.precision] : [];
}
function getConstantsFromPrototype(obj) {
  var keys2 = Object.keys(obj.__proto__);
  return keys2.filter(isConstantLike);
}
function isConstantLike(key) {
  return typeof key === "string" && !key.match(/[^A-Z0-9_x]/);
}
function shouldAvoidDebugRendererInfo() {
  return isGecko();
}
function isValidParameterGetter(gl2) {
  return typeof gl2.getParameter === "function";
}
var sources = {
  // READ FIRST:
  // See https://github.com/fingerprintjs/fingerprintjs/blob/master/contributing.md#how-to-make-an-entropy-source
  // to learn how entropy source works and how to make your own.
  // The sources run in this exact order.
  // The asynchronous sources are at the start to run in parallel with other sources.
  fonts: getFonts,
  domBlockers: getDomBlockers,
  fontPreferences: getFontPreferences,
  audio: getAudioFingerprint,
  screenFrame: getRoundedScreenFrame,
  canvas: getCanvasFingerprint,
  osCpu: getOsCpu,
  languages: getLanguages,
  colorDepth: getColorDepth,
  deviceMemory: getDeviceMemory,
  screenResolution: getScreenResolution,
  hardwareConcurrency: getHardwareConcurrency,
  timezone: getTimezone,
  sessionStorage: getSessionStorage,
  localStorage: getLocalStorage,
  indexedDB: getIndexedDB,
  openDatabase: getOpenDatabase,
  cpuClass: getCpuClass,
  platform: getPlatform,
  plugins: getPlugins,
  touchSupport: getTouchSupport,
  vendor: getVendor,
  vendorFlavors: getVendorFlavors,
  cookiesEnabled: areCookiesEnabled,
  colorGamut: getColorGamut,
  invertedColors: areColorsInverted,
  forcedColors: areColorsForced,
  monochrome: getMonochromeDepth,
  contrast: getContrastPreference,
  reducedMotion: isMotionReduced,
  hdr: isHDR,
  math: getMathFingerprint,
  pdfViewerEnabled: isPdfViewerEnabled,
  architecture: getArchitecture,
  applePay: getApplePayState,
  privateClickMeasurement: getPrivateClickMeasurement,
  // Some sources can affect other sources (e.g. WebGL can affect canvas), so it's important to run these sources
  // after other sources.
  webGlBasics: getWebGlBasics,
  webGlExtensions: getWebGlExtensions
};
function loadBuiltinSources(options) {
  return loadSources(sources, options, []);
}
var commentTemplate = "$ if upgrade to Pro: https://fpjs.dev/pro";
function getConfidence(components) {
  var openConfidenceScore = getOpenConfidenceScore(components);
  var proConfidenceScore = deriveProConfidenceScore(openConfidenceScore);
  return { score: openConfidenceScore, comment: commentTemplate.replace(/\$/g, "".concat(proConfidenceScore)) };
}
function getOpenConfidenceScore(components) {
  if (isAndroid()) {
    return 0.4;
  }
  if (isWebKit$1()) {
    return isDesktopSafari() ? 0.5 : 0.3;
  }
  var platform2 = "value" in components.platform ? components.platform.value : "";
  if (/^Win/.test(platform2)) {
    return 0.6;
  }
  if (/^Mac/.test(platform2)) {
    return 0.5;
  }
  return 0.7;
}
function deriveProConfidenceScore(openConfidenceScore) {
  return round$1(0.99 + 0.01 * openConfidenceScore, 1e-4);
}
function componentsToCanonicalString(components) {
  var result = "";
  for (var _i = 0, _a2 = Object.keys(components).sort(); _i < _a2.length; _i++) {
    var componentKey = _a2[_i];
    var component = components[componentKey];
    var value = "error" in component ? "error" : JSON.stringify(component.value);
    result += "".concat(result ? "|" : "").concat(componentKey.replace(/([:|\\])/g, "\\$1"), ":").concat(value);
  }
  return result;
}
function componentsToDebugString(components) {
  return JSON.stringify(components, function(_key, value) {
    if (value instanceof Error) {
      return errorToObject(value);
    }
    return value;
  }, 2);
}
function hashComponents(components) {
  return x64hash128(componentsToCanonicalString(components));
}
function makeLazyGetResult(components) {
  var visitorIdCache;
  var confidence = getConfidence(components);
  return {
    get visitorId() {
      if (visitorIdCache === void 0) {
        visitorIdCache = hashComponents(this.components);
      }
      return visitorIdCache;
    },
    set visitorId(visitorId) {
      visitorIdCache = visitorId;
    },
    confidence,
    components,
    version: version$7
  };
}
function prepareForSources(delayFallback) {
  if (delayFallback === void 0) {
    delayFallback = 50;
  }
  return requestIdleCallbackIfAvailable(delayFallback, delayFallback * 2);
}
function makeAgent(getComponents, debug) {
  var creationTime = Date.now();
  return {
    get: function(options) {
      return __awaiter$a(this, void 0, void 0, function() {
        var startTime, components, result;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              startTime = Date.now();
              return [4, getComponents()];
            case 1:
              components = _a2.sent();
              result = makeLazyGetResult(components);
              if (debug || (options === null || options === void 0 ? void 0 : options.debug)) {
                console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(result.version, "\nuserAgent: ").concat(navigator.userAgent, "\ntimeBetweenLoadAndGet: ").concat(startTime - creationTime, "\nvisitorId: ").concat(result.visitorId, "\ncomponents: ").concat(componentsToDebugString(components), "\n```"));
              }
              return [2, result];
          }
        });
      });
    }
  };
}
function monitor() {
  if (window.__fpjs_d_m || Math.random() >= 1e-3) {
    return;
  }
  try {
    var request = new XMLHttpRequest();
    request.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(version$7, "/npm-monitoring"), true);
    request.send();
  } catch (error) {
    console.error(error);
  }
}
function load(_a2) {
  var _b2 = _a2 === void 0 ? {} : _a2, delayFallback = _b2.delayFallback, debug = _b2.debug, _c2 = _b2.monitoring, monitoring = _c2 === void 0 ? true : _c2;
  return __awaiter$a(this, void 0, void 0, function() {
    var getComponents;
    return __generator(this, function(_d2) {
      switch (_d2.label) {
        case 0:
          if (monitoring) {
            monitor();
          }
          return [4, prepareForSources(delayFallback)];
        case 1:
          _d2.sent();
          getComponents = loadBuiltinSources({ cache: {}, debug });
          return [2, makeAgent(getComponents, debug)];
      }
    });
  });
}
var uaParser = { exports: {} };
(function(module, exports) {
  (function(window2, undefined$1) {
    var LIBVERSION = "1.0.35", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 350;
    var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS";
    var extend = function(regexes2, extensions2) {
      var mergedRegexes = {};
      for (var i2 in regexes2) {
        if (extensions2[i2] && extensions2[i2].length % 2 === 0) {
          mergedRegexes[i2] = extensions2[i2].concat(regexes2[i2]);
        } else {
          mergedRegexes[i2] = regexes2[i2];
        }
      }
      return mergedRegexes;
    }, enumerize = function(arr) {
      var enums = {};
      for (var i2 = 0; i2 < arr.length; i2++) {
        enums[arr[i2].toUpperCase()] = arr[i2];
      }
      return enums;
    }, has3 = function(str1, str2) {
      return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
    }, lowerize = function(str) {
      return str.toLowerCase();
    }, majorize = function(version2) {
      return typeof version2 === STR_TYPE ? version2.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined$1;
    }, trim = function(str, len) {
      if (typeof str === STR_TYPE) {
        str = str.replace(/^\s\s*/, EMPTY);
        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
      }
    };
    var rgxMapper = function(ua2, arrays) {
      var i2 = 0, j2, k2, p2, q2, matches, match;
      while (i2 < arrays.length && !matches) {
        var regex = arrays[i2], props = arrays[i2 + 1];
        j2 = k2 = 0;
        while (j2 < regex.length && !matches) {
          if (!regex[j2]) {
            break;
          }
          matches = regex[j2++].exec(ua2);
          if (!!matches) {
            for (p2 = 0; p2 < props.length; p2++) {
              match = matches[++k2];
              q2 = props[p2];
              if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                if (q2.length === 2) {
                  if (typeof q2[1] == FUNC_TYPE) {
                    this[q2[0]] = q2[1].call(this, match);
                  } else {
                    this[q2[0]] = q2[1];
                  }
                } else if (q2.length === 3) {
                  if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                    this[q2[0]] = match ? q2[1].call(this, match, q2[2]) : undefined$1;
                  } else {
                    this[q2[0]] = match ? match.replace(q2[1], q2[2]) : undefined$1;
                  }
                } else if (q2.length === 4) {
                  this[q2[0]] = match ? q2[3].call(this, match.replace(q2[1], q2[2])) : undefined$1;
                }
              } else {
                this[q2] = match ? match : undefined$1;
              }
            }
          }
        }
        i2 += 2;
      }
    }, strMapper = function(str, map2) {
      for (var i2 in map2) {
        if (typeof map2[i2] === OBJ_TYPE && map2[i2].length > 0) {
          for (var j2 = 0; j2 < map2[i2].length; j2++) {
            if (has3(map2[i2][j2], str)) {
              return i2 === UNKNOWN ? undefined$1 : i2;
            }
          }
        } else if (has3(map2[i2], str)) {
          return i2 === UNKNOWN ? undefined$1 : i2;
        }
      }
      return str;
    };
    var oldSafariMap = {
      "1.0": "/8",
      "1.2": "/1",
      "1.3": "/3",
      "2.0": "/412",
      "2.0.2": "/416",
      "2.0.3": "/417",
      "2.0.4": "/419",
      "?": "/"
    }, windowsVersionMap = {
      "ME": "4.90",
      "NT 3.11": "NT3.51",
      "NT 4.0": "NT4.0",
      "2000": "NT 5.0",
      "XP": ["NT 5.1", "NT 5.2"],
      "Vista": "NT 6.0",
      "7": "NT 6.1",
      "8": "NT 6.2",
      "8.1": "NT 6.3",
      "10": ["NT 6.4", "NT 10.0"],
      "RT": "ARM"
    };
    var regexes = {
      browser: [
        [
          /\b(?:crmo|crios)\/([\w\.]+)/i
          // Chrome for Android/iOS
        ],
        [VERSION, [NAME, "Chrome"]],
        [
          /edg(?:e|ios|a)?\/([\w\.]+)/i
          // Microsoft Edge
        ],
        [VERSION, [NAME, "Edge"]],
        [
          // Presto based
          /(opera mini)\/([-\w\.]+)/i,
          // Opera Mini
          /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
          // Opera Mobi/Tablet
          /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
          // Opera
        ],
        [NAME, VERSION],
        [
          /opios[\/ ]+([\w\.]+)/i
          // Opera mini on iphone >= 8.0
        ],
        [VERSION, [NAME, OPERA + " Mini"]],
        [
          /\bopr\/([\w\.]+)/i
          // Opera Webkit
        ],
        [VERSION, [NAME, OPERA]],
        [
          // Mixed
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
          // Lunascape/Maxthon/Netfront/Jasmine/Blazer
          // Trident based
          /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
          // Avant/IEMobile/SlimBrowser
          /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
          // Baidu Browser
          /(?:ms|\()(ie) ([\w\.]+)/i,
          // Internet Explorer
          // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
          /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
          // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
          /(heytap|ovi)browser\/([\d\.]+)/i,
          // Heytap/Ovi
          /(weibo)__([\d\.]+)/i
          // Weibo
        ],
        [NAME, VERSION],
        [
          /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
          // UCBrowser
        ],
        [VERSION, [NAME, "UC" + BROWSER]],
        [
          /microm.+\bqbcore\/([\w\.]+)/i,
          // WeChat Desktop for Windows Built-in Browser
          /\bqbcore\/([\w\.]+).+microm/i
        ],
        [VERSION, [NAME, "WeChat(Win) Desktop"]],
        [
          /micromessenger\/([\w\.]+)/i
          // WeChat
        ],
        [VERSION, [NAME, "WeChat"]],
        [
          /konqueror\/([\w\.]+)/i
          // Konqueror
        ],
        [VERSION, [NAME, "Konqueror"]],
        [
          /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
          // IE11
        ],
        [VERSION, [NAME, "IE"]],
        [
          /ya(?:search)?browser\/([\w\.]+)/i
          // Yandex
        ],
        [VERSION, [NAME, "Yandex"]],
        [
          /(avast|avg)\/([\w\.]+)/i
          // Avast/AVG Secure Browser
        ],
        [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
        [
          /\bfocus\/([\w\.]+)/i
          // Firefox Focus
        ],
        [VERSION, [NAME, FIREFOX + " Focus"]],
        [
          /\bopt\/([\w\.]+)/i
          // Opera Touch
        ],
        [VERSION, [NAME, OPERA + " Touch"]],
        [
          /coc_coc\w+\/([\w\.]+)/i
          // Coc Coc Browser
        ],
        [VERSION, [NAME, "Coc Coc"]],
        [
          /dolfin\/([\w\.]+)/i
          // Dolphin
        ],
        [VERSION, [NAME, "Dolphin"]],
        [
          /coast\/([\w\.]+)/i
          // Opera Coast
        ],
        [VERSION, [NAME, OPERA + " Coast"]],
        [
          /miuibrowser\/([\w\.]+)/i
          // MIUI Browser
        ],
        [VERSION, [NAME, "MIUI " + BROWSER]],
        [
          /fxios\/([-\w\.]+)/i
          // Firefox for iOS
        ],
        [VERSION, [NAME, FIREFOX]],
        [
          /\bqihu|(qi?ho?o?|360)browser/i
          // 360
        ],
        [[NAME, "360 " + BROWSER]],
        [
          /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i
        ],
        [[NAME, /(.+)/, "$1 " + BROWSER], VERSION],
        [
          // Oculus/Samsung/Sailfish/Huawei Browser
          /(comodo_dragon)\/([\w\.]+)/i
          // Comodo Dragon
        ],
        [[NAME, /_/g, " "], VERSION],
        [
          /(electron)\/([\w\.]+) safari/i,
          // Electron-based App
          /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
          // Tesla
          /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
          // QQBrowser/Baidu App/2345 Browser
        ],
        [NAME, VERSION],
        [
          /(metasr)[\/ ]?([\w\.]+)/i,
          // SouGouBrowser
          /(lbbrowser)/i,
          // LieBao Browser
          /\[(linkedin)app\]/i
          // LinkedIn App for iOS & Android
        ],
        [NAME],
        [
          // WebView
          /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
          // Facebook App for iOS & Android
        ],
        [[NAME, FACEBOOK], VERSION],
        [
          /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
          // Kakao App
          /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
          // Naver InApp
          /safari (line)\/([\w\.]+)/i,
          // Line App for iOS
          /\b(line)\/([\w\.]+)\/iab/i,
          // Line App for Android
          /(chromium|instagram)[\/ ]([-\w\.]+)/i
          // Chromium/Instagram
        ],
        [NAME, VERSION],
        [
          /\bgsa\/([\w\.]+) .*safari\//i
          // Google Search Appliance on iOS
        ],
        [VERSION, [NAME, "GSA"]],
        [
          /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
          // TikTok
        ],
        [VERSION, [NAME, "TikTok"]],
        [
          /headlesschrome(?:\/([\w\.]+)| )/i
          // Chrome Headless
        ],
        [VERSION, [NAME, CHROME + " Headless"]],
        [
          / wv\).+(chrome)\/([\w\.]+)/i
          // Chrome WebView
        ],
        [[NAME, CHROME + " WebView"], VERSION],
        [
          /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
          // Android Browser
        ],
        [VERSION, [NAME, "Android " + BROWSER]],
        [
          /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
          // Chrome/OmniWeb/Arora/Tizen/Nokia
        ],
        [NAME, VERSION],
        [
          /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
          // Mobile Safari
        ],
        [VERSION, [NAME, "Mobile Safari"]],
        [
          /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
          // Safari & Safari Mobile
        ],
        [VERSION, NAME],
        [
          /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
          // Safari < 3.0
        ],
        [NAME, [VERSION, strMapper, oldSafariMap]],
        [
          /(webkit|khtml)\/([\w\.]+)/i
        ],
        [NAME, VERSION],
        [
          // Gecko based
          /(navigator|netscape\d?)\/([-\w\.]+)/i
          // Netscape
        ],
        [[NAME, "Netscape"], VERSION],
        [
          /mobile vr; rv:([\w\.]+)\).+firefox/i
          // Firefox Reality
        ],
        [VERSION, [NAME, FIREFOX + " Reality"]],
        [
          /ekiohf.+(flow)\/([\w\.]+)/i,
          // Flow
          /(swiftfox)/i,
          // Swiftfox
          /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
          // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
          /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
          // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
          /(firefox)\/([\w\.]+)/i,
          // Other Firefox-based
          /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
          // Mozilla
          // Other
          /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
          // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
          /(links) \(([\w\.]+)/i,
          // Links
          /panasonic;(viera)/i
          // Panasonic Viera
        ],
        [NAME, VERSION],
        [
          /(cobalt)\/([\w\.]+)/i
          // Cobalt
        ],
        [NAME, [VERSION, /master.|lts./, ""]]
      ],
      cpu: [
        [
          /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
          // AMD64 (x64)
        ],
        [[ARCHITECTURE, "amd64"]],
        [
          /(ia32(?=;))/i
          // IA32 (quicktime)
        ],
        [[ARCHITECTURE, lowerize]],
        [
          /((?:i[346]|x)86)[;\)]/i
          // IA32 (x86)
        ],
        [[ARCHITECTURE, "ia32"]],
        [
          /\b(aarch64|arm(v?8e?l?|_?64))\b/i
          // ARM64
        ],
        [[ARCHITECTURE, "arm64"]],
        [
          /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
          // ARMHF
        ],
        [[ARCHITECTURE, "armhf"]],
        [
          // PocketPC mistakenly identified as PowerPC
          /windows (ce|mobile); ppc;/i
        ],
        [[ARCHITECTURE, "arm"]],
        [
          /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
          // PowerPC
        ],
        [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
        [
          /(sun4\w)[;\)]/i
          // SPARC
        ],
        [[ARCHITECTURE, "sparc"]],
        [
          /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
          // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
        ],
        [[ARCHITECTURE, lowerize]]
      ],
      device: [
        [
          //////////////////////////
          // MOBILES & TABLETS
          /////////////////////////
          // Samsung
          /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
        ],
        [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
        [
          /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
          /samsung[- ]([-\w]+)/i,
          /sec-(sgh\w+)/i
        ],
        [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
        [
          // Apple
          /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
          // iPod/iPhone
        ],
        [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
        [
          /\((ipad);[-\w\),; ]+apple/i,
          // iPad
          /applecoremedia\/[\w\.]+ \((ipad)/i,
          /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
        ],
        [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
        [
          /(macintosh);/i
        ],
        [MODEL, [VENDOR, APPLE]],
        [
          // Sharp
          /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
        ],
        [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
        [
          // Huawei
          /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
        ],
        [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
        [
          /(?:huawei|honor)([-\w ]+)[;\)]/i,
          /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
        ],
        [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
        [
          // Xiaomi
          /\b(poco[\w ]+)(?: bui|\))/i,
          // Xiaomi POCO
          /\b; (\w+) build\/hm\1/i,
          // Xiaomi Hongmi 'numeric' models
          /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
          // Xiaomi Hongmi
          /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
          // Xiaomi Redmi
          /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
          // Xiaomi Mi
        ],
        [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
        [
          /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
          // Mi Pad tablets
        ],
        [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
        [
          // OPPO
          /; (\w+) bui.+ oppo/i,
          /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
        ],
        [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
        [
          // Vivo
          /vivo (\w+)(?: bui|\))/i,
          /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
        ],
        [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
        [
          // Realme
          /\b(rmx[12]\d{3})(?: bui|;|\))/i
        ],
        [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
        [
          // Motorola
          /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
          /\bmot(?:orola)?[- ](\w*)/i,
          /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
        ],
        [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
        [
          /\b(mz60\d|xoom[2 ]{0,2}) build\//i
        ],
        [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
        [
          // LG
          /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
        ],
        [MODEL, [VENDOR, LG], [TYPE, TABLET]],
        [
          /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
          /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
          /\blg-?([\d\w]+) bui/i
        ],
        [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
        [
          // Lenovo
          /(ideatab[-\w ]+)/i,
          /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
        ],
        [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
        [
          // Nokia
          /(?:maemo|nokia).*(n900|lumia \d+)/i,
          /nokia[-_ ]?([-\w\.]*)/i
        ],
        [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
        [
          // Google
          /(pixel c)\b/i
          // Google Pixel C
        ],
        [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
        [
          /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
          // Google Pixel
        ],
        [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
        [
          // Sony
          /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
        ],
        [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
        [
          /sony tablet [ps]/i,
          /\b(?:sony)?sgp\w+(?: bui|\))/i
        ],
        [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
        [
          // OnePlus
          / (kb2005|in20[12]5|be20[12][59])\b/i,
          /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
        ],
        [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
        [
          // Amazon
          /(alexa)webm/i,
          /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
          // Kindle Fire without Silk / Echo Show
          /(kf[a-z]+)( bui|\)).+silk\//i
          // Kindle Fire HD
        ],
        [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
        [
          /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
          // Fire Phone
        ],
        [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
        [
          // BlackBerry
          /(playbook);[-\w\),; ]+(rim)/i
          // BlackBerry PlayBook
        ],
        [MODEL, VENDOR, [TYPE, TABLET]],
        [
          /\b((?:bb[a-f]|st[hv])100-\d)/i,
          /\(bb10; (\w+)/i
          // BlackBerry 10
        ],
        [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
        [
          // Asus
          /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
        ],
        [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
        [
          / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
        ],
        [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
        [
          // HTC
          /(nexus 9)/i
          // HTC Nexus 9
        ],
        [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
        [
          /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
          // HTC
          // ZTE
          /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
          /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
          // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
        ],
        [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
        [
          // Acer
          /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
        ],
        [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
        [
          // Meizu
          /droid.+; (m[1-5] note) bui/i,
          /\bmz-([-\w]{2,})/i
        ],
        [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
        [
          // MIXED
          /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
          // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
          /(hp) ([\w ]+\w)/i,
          // HP iPAQ
          /(asus)-?(\w+)/i,
          // Asus
          /(microsoft); (lumia[\w ]+)/i,
          // Microsoft Lumia
          /(lenovo)[-_ ]?([-\w]+)/i,
          // Lenovo
          /(jolla)/i,
          // Jolla
          /(oppo) ?([\w ]+) bui/i
          // OPPO
        ],
        [VENDOR, MODEL, [TYPE, MOBILE]],
        [
          /(kobo)\s(ereader|touch)/i,
          // Kobo
          /(archos) (gamepad2?)/i,
          // Archos
          /(hp).+(touchpad(?!.+tablet)|tablet)/i,
          // HP TouchPad
          /(kindle)\/([\w\.]+)/i,
          // Kindle
          /(nook)[\w ]+build\/(\w+)/i,
          // Nook
          /(dell) (strea[kpr\d ]*[\dko])/i,
          // Dell Streak
          /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
          // Le Pan Tablets
          /(trinity)[- ]*(t\d{3}) bui/i,
          // Trinity Tablets
          /(gigaset)[- ]+(q\w{1,9}) bui/i,
          // Gigaset Tablets
          /(vodafone) ([\w ]+)(?:\)| bui)/i
          // Vodafone
        ],
        [VENDOR, MODEL, [TYPE, TABLET]],
        [
          /(surface duo)/i
          // Surface Duo
        ],
        [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
        [
          /droid [\d\.]+; (fp\du?)(?: b|\))/i
          // Fairphone
        ],
        [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
        [
          /(u304aa)/i
          // AT&T
        ],
        [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
        [
          /\bsie-(\w*)/i
          // Siemens
        ],
        [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
        [
          /\b(rct\w+) b/i
          // RCA Tablets
        ],
        [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
        [
          /\b(venue[\d ]{2,7}) b/i
          // Dell Venue Tablets
        ],
        [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
        [
          /\b(q(?:mv|ta)\w+) b/i
          // Verizon Tablet
        ],
        [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
        [
          /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
          // Barnes & Noble Tablet
        ],
        [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
        [
          /\b(tm\d{3}\w+) b/i
        ],
        [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
        [
          /\b(k88) b/i
          // ZTE K Series Tablet
        ],
        [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
        [
          /\b(nx\d{3}j) b/i
          // ZTE Nubia
        ],
        [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
        [
          /\b(gen\d{3}) b.+49h/i
          // Swiss GEN Mobile
        ],
        [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
        [
          /\b(zur\d{3}) b/i
          // Swiss ZUR Tablet
        ],
        [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
        [
          /\b((zeki)?tb.*\b) b/i
          // Zeki Tablets
        ],
        [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
        [
          /\b([yr]\d{2}) b/i,
          /\b(dragon[- ]+touch |dt)(\w{5}) b/i
          // Dragon Touch Tablet
        ],
        [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
        [
          /\b(ns-?\w{0,9}) b/i
          // Insignia Tablets
        ],
        [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
        [
          /\b((nxa|next)-?\w{0,9}) b/i
          // NextBook Tablets
        ],
        [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
        [
          /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
          // Voice Xtreme Phones
        ],
        [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
        [
          /\b(lvtel\-)?(v1[12]) b/i
          // LvTel Phones
        ],
        [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
        [
          /\b(ph-1) /i
          // Essential PH-1
        ],
        [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
        [
          /\b(v(100md|700na|7011|917g).*\b) b/i
          // Envizen Tablets
        ],
        [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
        [
          /\b(trio[-\w\. ]+) b/i
          // MachSpeed Tablets
        ],
        [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
        [
          /\btu_(1491) b/i
          // Rotor Tablets
        ],
        [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
        [
          /(shield[\w ]+) b/i
          // Nvidia Shield Tablets
        ],
        [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
        [
          /(sprint) (\w+)/i
          // Sprint Phones
        ],
        [VENDOR, MODEL, [TYPE, MOBILE]],
        [
          /(kin\.[onetw]{3})/i
          // Microsoft Kin
        ],
        [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
        [
          /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
          // Zebra
        ],
        [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
        [
          /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
        ],
        [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
        [
          ///////////////////
          // SMARTTVS
          ///////////////////
          /smart-tv.+(samsung)/i
          // Samsung
        ],
        [VENDOR, [TYPE, SMARTTV]],
        [
          /hbbtv.+maple;(\d+)/i
        ],
        [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
        [
          /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
          // LG SmartTV
        ],
        [[VENDOR, LG], [TYPE, SMARTTV]],
        [
          /(apple) ?tv/i
          // Apple TV
        ],
        [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
        [
          /crkey/i
          // Google Chromecast
        ],
        [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
        [
          /droid.+aft(\w)( bui|\))/i
          // Fire TV
        ],
        [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
        [
          /\(dtv[\);].+(aquos)/i,
          /(aquos-tv[\w ]+)\)/i
          // Sharp
        ],
        [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
        [
          /(bravia[\w ]+)( bui|\))/i
          // Sony
        ],
        [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
        [
          /(mitv-\w{5}) bui/i
          // Xiaomi
        ],
        [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
        [
          /Hbbtv.*(technisat) (.*);/i
          // TechniSAT
        ],
        [VENDOR, MODEL, [TYPE, SMARTTV]],
        [
          /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
          // Roku
          /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
          // HbbTV devices
        ],
        [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
        [
          /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
          // SmartTV from Unidentified Vendors
        ],
        [[TYPE, SMARTTV]],
        [
          ///////////////////
          // CONSOLES
          ///////////////////
          /(ouya)/i,
          // Ouya
          /(nintendo) ([wids3utch]+)/i
          // Nintendo
        ],
        [VENDOR, MODEL, [TYPE, CONSOLE]],
        [
          /droid.+; (shield) bui/i
          // Nvidia
        ],
        [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
        [
          /(playstation [345portablevi]+)/i
          // Playstation
        ],
        [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
        [
          /\b(xbox(?: one)?(?!; xbox))[\); ]/i
          // Microsoft Xbox
        ],
        [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
        [
          ///////////////////
          // WEARABLES
          ///////////////////
          /((pebble))app/i
          // Pebble
        ],
        [VENDOR, MODEL, [TYPE, WEARABLE]],
        [
          /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
          // Apple Watch
        ],
        [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
        [
          /droid.+; (glass) \d/i
          // Google Glass
        ],
        [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
        [
          /droid.+; (wt63?0{2,3})\)/i
        ],
        [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
        [
          /(quest( 2| pro)?)/i
          // Oculus Quest
        ],
        [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
        [
          ///////////////////
          // EMBEDDED
          ///////////////////
          /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
          // Tesla
        ],
        [VENDOR, [TYPE, EMBEDDED]],
        [
          /(aeobc)\b/i
          // Echo Dot
        ],
        [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
        [
          ////////////////////
          // MIXED (GENERIC)
          ///////////////////
          /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i
          // Android Phones from Unidentified Vendors
        ],
        [MODEL, [TYPE, MOBILE]],
        [
          /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
          // Android Tablets from Unidentified Vendors
        ],
        [MODEL, [TYPE, TABLET]],
        [
          /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
          // Unidentifiable Tablet
        ],
        [[TYPE, TABLET]],
        [
          /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
          // Unidentifiable Mobile
        ],
        [[TYPE, MOBILE]],
        [
          /(android[-\w\. ]{0,9});.+buil/i
          // Generic Android Device
        ],
        [MODEL, [VENDOR, "Generic"]]
      ],
      engine: [
        [
          /windows.+ edge\/([\w\.]+)/i
          // EdgeHTML
        ],
        [VERSION, [NAME, EDGE + "HTML"]],
        [
          /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
          // Blink
        ],
        [VERSION, [NAME, "Blink"]],
        [
          /(presto)\/([\w\.]+)/i,
          // Presto
          /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
          // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
          /ekioh(flow)\/([\w\.]+)/i,
          // Flow
          /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
          // KHTML/Tasman/Links
          /(icab)[\/ ]([23]\.[\d\.]+)/i,
          // iCab
          /\b(libweb)/i
        ],
        [NAME, VERSION],
        [
          /rv\:([\w\.]{1,9})\b.+(gecko)/i
          // Gecko
        ],
        [VERSION, NAME]
      ],
      os: [
        [
          // Windows
          /microsoft (windows) (vista|xp)/i
          // Windows (iTunes)
        ],
        [NAME, VERSION],
        [
          /(windows) nt 6\.2; (arm)/i,
          // Windows RT
          /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
          // Windows Phone
          /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
        ],
        [NAME, [VERSION, strMapper, windowsVersionMap]],
        [
          /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
        ],
        [[NAME, "Windows"], [VERSION, strMapper, windowsVersionMap]],
        [
          // iOS/macOS
          /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
          // iOS
          /ios;fbsv\/([\d\.]+)/i,
          /cfnetwork\/.+darwin/i
        ],
        [[VERSION, /_/g, "."], [NAME, "iOS"]],
        [
          /(mac os x) ?([\w\. ]*)/i,
          /(macintosh|mac_powerpc\b)(?!.+haiku)/i
          // Mac OS
        ],
        [[NAME, MAC_OS], [VERSION, /_/g, "."]],
        [
          // Mobile OSes
          /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
          // Android-x86/HarmonyOS
        ],
        [VERSION, NAME],
        [
          // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
          /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
          /(blackberry)\w*\/([\w\.]*)/i,
          // Blackberry
          /(tizen|kaios)[\/ ]([\w\.]+)/i,
          // Tizen/KaiOS
          /\((series40);/i
          // Series 40
        ],
        [NAME, VERSION],
        [
          /\(bb(10);/i
          // BlackBerry 10
        ],
        [VERSION, [NAME, BLACKBERRY]],
        [
          /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
          // Symbian
        ],
        [VERSION, [NAME, "Symbian"]],
        [
          /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
          // Firefox OS
        ],
        [VERSION, [NAME, FIREFOX + " OS"]],
        [
          /web0s;.+rt(tv)/i,
          /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
          // WebOS
        ],
        [VERSION, [NAME, "webOS"]],
        [
          /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
          // watchOS
        ],
        [VERSION, [NAME, "watchOS"]],
        [
          // Google Chromecast
          /crkey\/([\d\.]+)/i
          // Google Chromecast
        ],
        [VERSION, [NAME, CHROME + "cast"]],
        [
          /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
          // Chromium OS
        ],
        [[NAME, CHROMIUM_OS], VERSION],
        [
          // Smart TVs
          /panasonic;(viera)/i,
          // Panasonic Viera
          /(netrange)mmh/i,
          // Netrange
          /(nettv)\/(\d+\.[\w\.]+)/i,
          // NetTV
          // Console
          /(nintendo|playstation) ([wids345portablevuch]+)/i,
          // Nintendo/Playstation
          /(xbox); +xbox ([^\);]+)/i,
          // Microsoft Xbox (360, One, X, S, Series X, Series S)
          // Other
          /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
          // Joli/Palm
          /(mint)[\/\(\) ]?(\w*)/i,
          // Mint
          /(mageia|vectorlinux)[; ]/i,
          // Mageia/VectorLinux
          /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
          // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
          /(hurd|linux) ?([\w\.]*)/i,
          // Hurd/Linux
          /(gnu) ?([\w\.]*)/i,
          // GNU
          /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
          // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
          /(haiku) (\w+)/i
          // Haiku
        ],
        [NAME, VERSION],
        [
          /(sunos) ?([\w\.\d]*)/i
          // Solaris
        ],
        [[NAME, "Solaris"], VERSION],
        [
          /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
          // Solaris
          /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
          // AIX
          /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
          // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
          /(unix) ?([\w\.]*)/i
          // UNIX
        ],
        [NAME, VERSION]
      ]
    };
    var UAParser = function(ua2, extensions2) {
      if (typeof ua2 === OBJ_TYPE) {
        extensions2 = ua2;
        ua2 = undefined$1;
      }
      if (!(this instanceof UAParser)) {
        return new UAParser(ua2, extensions2).getResult();
      }
      var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined$1;
      var _ua = ua2 || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
      var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined$1;
      var _rgxmap = extensions2 ? extend(regexes, extensions2) : regexes;
      var _isSelfNav = _navigator && _navigator.userAgent == _ua;
      this.getBrowser = function() {
        var _browser = {};
        _browser[NAME] = undefined$1;
        _browser[VERSION] = undefined$1;
        rgxMapper.call(_browser, _ua, _rgxmap.browser);
        _browser[MAJOR] = majorize(_browser[VERSION]);
        if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
          _browser[NAME] = "Brave";
        }
        return _browser;
      };
      this.getCPU = function() {
        var _cpu = {};
        _cpu[ARCHITECTURE] = undefined$1;
        rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
        return _cpu;
      };
      this.getDevice = function() {
        var _device = {};
        _device[VENDOR] = undefined$1;
        _device[MODEL] = undefined$1;
        _device[TYPE] = undefined$1;
        rgxMapper.call(_device, _ua, _rgxmap.device);
        if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
          _device[TYPE] = MOBILE;
        }
        if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
          _device[MODEL] = "iPad";
          _device[TYPE] = TABLET;
        }
        return _device;
      };
      this.getEngine = function() {
        var _engine = {};
        _engine[NAME] = undefined$1;
        _engine[VERSION] = undefined$1;
        rgxMapper.call(_engine, _ua, _rgxmap.engine);
        return _engine;
      };
      this.getOS = function() {
        var _os = {};
        _os[NAME] = undefined$1;
        _os[VERSION] = undefined$1;
        rgxMapper.call(_os, _ua, _rgxmap.os);
        if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != "Unknown") {
          _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
        }
        return _os;
      };
      this.getResult = function() {
        return {
          ua: this.getUA(),
          browser: this.getBrowser(),
          engine: this.getEngine(),
          os: this.getOS(),
          device: this.getDevice(),
          cpu: this.getCPU()
        };
      };
      this.getUA = function() {
        return _ua;
      };
      this.setUA = function(ua3) {
        _ua = typeof ua3 === STR_TYPE && ua3.length > UA_MAX_LENGTH ? trim(ua3, UA_MAX_LENGTH) : ua3;
        return this;
      };
      this.setUA(_ua);
      return this;
    };
    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
    {
      if (module.exports) {
        exports = module.exports = UAParser;
      }
      exports.UAParser = UAParser;
    }
    var $2 = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
    if ($2 && !$2.ua) {
      var parser = new UAParser();
      $2.ua = parser.getResult();
      $2.ua.get = function() {
        return parser.getUA();
      };
      $2.ua.set = function(ua2) {
        parser.setUA(ua2);
        var result = parser.getResult();
        for (var prop2 in result) {
          $2.ua[prop2] = result[prop2];
        }
      };
    }
  })(typeof window === "object" ? window : commonjsGlobal);
})(uaParser, uaParser.exports);
var uaParserExports = uaParser.exports;
let fingerprintAgent;
const getFingerprintAgent = async () => {
  if (!fingerprintAgent) {
    fingerprintAgent = await load();
  }
  return fingerprintAgent;
};
const isElectron = () => {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if ("electron" in window) {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
    return true;
  }
  if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
};
const isE = isElectron();
const ua = () => uaParserExports.UAParser(navigator.userAgent);
const os = () => ua().os;
const loadingVariants = cva(["animate-spin", "duration-300"]);
const loadMap = {
  default: RiLoader3Line,
  apple: RiLoader2Line,
  "apple-small": RiLoaderLine,
  "material-small": RiLoader5Line,
  material: RiLoader4Line
};
const Loading = ({
  children,
  type = !isElectron() || window.electron.process.platform === "darwin" ? "apple" : "default",
  ...props
}) => {
  const LoadIcon = loadMap[type];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    LoadIcon,
    {
      ...props,
      className: loadingVariants({ className: props.className }),
      children
    }
  );
};
const buttonVariants = cva(
  [
    "text-md",
    // "disabled:opacity-70",
    "flex",
    "flex-row",
    "justify-center",
    "items-center",
    "transition-all",
    "duration-150",
    "box-border",
    "border border-solid border-white/50",
    "font-semibold",
    "relative"
  ],
  {
    variants: {
      intent: {
        primary: [
          "text-white",
          "bg-gradient-to-r",
          "beacon-btn",
          "before:bg-fadedBg"
        ],
        secondary: ["neu", "text-faded", "bg-fadedBg"],
        destructive: ["bg-gradient-to-br from-red-500 to-red-700"],
        bare: null
      },
      size: {
        small: ["py-[4px] px-2 text-sm rounded-md leading-none"],
        default: ["py-2 px-4 rounded-lg"]
      },
      block: {
        true: ["w-full"],
        false: ["w-auto"]
      },
      disabled: {
        true: ["text-opacity-40 cursor-not-allowed"],
        false: ["cursor-pointer"]
      },
      Icon: {
        true: [],
        false: null
      }
    },
    defaultVariants: {
      intent: "primary",
      size: "default",
      block: false
    },
    compoundVariants: [
      {
        intent: "primary",
        className: "from-purple-one to-purple-two",
        Icon: false
      },
      {
        intent: "primary",
        disabled: true,
        className: "from-indigo-400/30 to-indigo-600/30",
        Icon: false
      },
      {
        intent: ["secondary", "bare"],
        disabled: true,
        className: "opacity-70",
        Icon: false
      },
      {
        intent: ["primary", "secondary"],
        disabled: false,
        className: "bg-base",
        Icon: true
      }
    ]
  }
);
const Button = ({
  intent = "primary",
  size,
  className,
  children,
  block,
  buttonRef,
  loading = false,
  loadingText,
  disabled,
  Icon,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: buttonVariants({
        intent,
        size,
        block,
        disabled,
        Icon: !!Icon,
        className
      }),
      ref: buttonRef,
      disabled: disabled || loading,
      ...props,
      children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 22 }),
        loadingText
      ] }) : children
    }
  );
};
const container = "";
const containerClasses = cva(["relative"], {
  variants: {
    type: {
      default: [
        "border border-white border-opacity-50",
        "bg-blue-200 bg-opacity-10",
        "rounded-[10px]"
      ],
      neu: ["neu", "rounded-[12px]", "bg-base"],
      list: [
        "container-list",
        "rounded-[10px]",
        "border-solid border-2 border-white/50 dark:border-white/5",
        "bg-list/10"
      ],
      dropdown: ["dropdown", "bg-base", "rounded-[10px]"]
    },
    padding: {
      xs: ["px-[10px]", "py-[5px]"],
      sm: ["px-4", "py-3"],
      md: ["p-5"],
      lg: ["p-[40px]"]
    },
    block: {
      true: ["w-full"],
      false: null
    }
  },
  defaultVariants: {
    block: true,
    type: "default",
    padding: "md"
  }
});
const Container = ({
  title = null,
  children,
  className,
  block,
  type,
  padding,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    type !== "neu" && title,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: containerClasses({ className, block, type, padding }),
        ...props,
        children
      }
    )
  ] });
};
var i$6 = Object.defineProperty;
var d$5 = (t2, e2, n2) => e2 in t2 ? i$6(t2, e2, { enumerable: true, configurable: true, writable: true, value: n2 }) : t2[e2] = n2;
var r$3 = (t2, e2, n2) => (d$5(t2, typeof e2 != "symbol" ? e2 + "" : e2, n2), n2);
let o$6 = class o {
  constructor() {
    r$3(this, "current", this.detect());
    r$3(this, "handoffState", "pending");
    r$3(this, "currentId", 0);
  }
  set(e2) {
    this.current !== e2 && (this.handoffState = "pending", this.currentId = 0, this.current = e2);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
let s$8 = new o$6();
let l$4 = (e2, f2) => {
  s$8.isServer ? reactExports.useEffect(e2, f2) : reactExports.useLayoutEffect(e2, f2);
};
function s$7(e2) {
  let r2 = reactExports.useRef(e2);
  return l$4(() => {
    r2.current = e2;
  }, [e2]), r2;
}
function i$5(e2, o3) {
  let [u2, t2] = reactExports.useState(e2), r2 = s$7(e2);
  return l$4(() => t2(r2.current), [r2, t2, ...o3]), u2;
}
function t$9(e2) {
  typeof queueMicrotask == "function" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o3) => setTimeout(() => {
    throw o3;
  }));
}
function o$5() {
  let n2 = [], r2 = { addEventListener(e2, t2, s2, a2) {
    return e2.addEventListener(t2, s2, a2), r2.add(() => e2.removeEventListener(t2, s2, a2));
  }, requestAnimationFrame(...e2) {
    let t2 = requestAnimationFrame(...e2);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e2) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));
  }, setTimeout(...e2) {
    let t2 = setTimeout(...e2);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e2) {
    let t2 = { current: true };
    return t$9(() => {
      t2.current && e2[0]();
    }), r2.add(() => {
      t2.current = false;
    });
  }, style(e2, t2, s2) {
    let a2 = e2.style.getPropertyValue(t2);
    return Object.assign(e2.style, { [t2]: s2 }), this.add(() => {
      Object.assign(e2.style, { [t2]: a2 });
    });
  }, group(e2) {
    let t2 = o$5();
    return e2(t2), this.add(() => t2.dispose());
  }, add(e2) {
    return n2.push(e2), () => {
      let t2 = n2.indexOf(e2);
      if (t2 >= 0)
        for (let s2 of n2.splice(t2, 1))
          s2();
    };
  }, dispose() {
    for (let e2 of n2.splice(0))
      e2();
  } };
  return r2;
}
function p$4() {
  let [e2] = reactExports.useState(o$5);
  return reactExports.useEffect(() => () => e2.dispose(), [e2]), e2;
}
let o$4 = function(t2) {
  let e2 = s$7(t2);
  return React.useCallback((...r2) => e2.current(...r2), [e2]);
};
function s$6() {
  let r2 = typeof document == "undefined";
  return "useSyncExternalStore" in React$1 ? ((o3) => o3.useSyncExternalStore)(React$1)(() => () => {
  }, () => false, () => !r2) : false;
}
function l$3() {
  let r2 = s$6(), [e2, n2] = reactExports.useState(s$8.isHandoffComplete);
  return e2 && s$8.isHandoffComplete === false && n2(false), reactExports.useEffect(() => {
    e2 !== true && n2(true);
  }, [e2]), reactExports.useEffect(() => s$8.handoff(), []), r2 ? false : e2;
}
var o$3;
let I$3 = (o$3 = React.useId) != null ? o$3 : function() {
  let n2 = l$3(), [e2, u2] = React.useState(n2 ? () => s$8.nextId() : null);
  return l$4(() => {
    e2 === null && u2(s$8.nextId());
  }, [e2]), e2 != null ? "" + e2 : void 0;
};
function u$5(r2, n2, ...a2) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a2) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$5), t2;
}
function e$2(r2) {
  return s$8.isServer ? null : r2 instanceof Node ? r2.ownerDocument : r2 != null && r2.hasOwnProperty("current") && r2.current instanceof Node ? r2.current.ownerDocument : document;
}
let c$7 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
var M$6 = ((n2) => (n2[n2.First = 1] = "First", n2[n2.Previous = 2] = "Previous", n2[n2.Next = 4] = "Next", n2[n2.Last = 8] = "Last", n2[n2.WrapAround = 16] = "WrapAround", n2[n2.NoScroll = 32] = "NoScroll", n2))(M$6 || {}), N$2 = ((o3) => (o3[o3.Error = 0] = "Error", o3[o3.Overflow = 1] = "Overflow", o3[o3.Success = 2] = "Success", o3[o3.Underflow = 3] = "Underflow", o3))(N$2 || {}), F$2 = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(F$2 || {});
function f$6(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(c$7)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$3 = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(T$3 || {});
function h$6(e2, r2 = 0) {
  var t2;
  return e2 === ((t2 = e$2(e2)) == null ? void 0 : t2.body) ? false : u$5(r2, { [0]() {
    return e2.matches(c$7);
  }, [1]() {
    let l2 = e2;
    for (; l2 !== null; ) {
      if (l2.matches(c$7))
        return true;
      l2 = l2.parentElement;
    }
    return false;
  } });
}
var w$3 = ((t2) => (t2[t2.Keyboard = 0] = "Keyboard", t2[t2.Mouse = 1] = "Mouse", t2))(w$3 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e2) => {
  e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e2) => {
  e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function y$4(e2) {
  e2 == null || e2.focus({ preventScroll: true });
}
let S$6 = ["textarea", "input"].join(",");
function H$2(e2) {
  var r2, t2;
  return (t2 = (r2 = e2 == null ? void 0 : e2.matches) == null ? void 0 : r2.call(e2, S$6)) != null ? t2 : false;
}
function I$2(e2, r2 = (t2) => t2) {
  return e2.slice().sort((t2, l2) => {
    let o3 = r2(t2), i2 = r2(l2);
    if (o3 === null || i2 === null)
      return 0;
    let n2 = o3.compareDocumentPosition(i2);
    return n2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function O(e2, r2, { sorted: t2 = true, relativeTo: l2 = null, skipElements: o3 = [] } = {}) {
  let i2 = Array.isArray(e2) ? e2.length > 0 ? e2[0].ownerDocument : document : e2.ownerDocument, n2 = Array.isArray(e2) ? t2 ? I$2(e2) : e2 : f$6(e2);
  o3.length > 0 && n2.length > 1 && (n2 = n2.filter((s2) => !o3.includes(s2))), l2 = l2 != null ? l2 : i2.activeElement;
  let E2 = (() => {
    if (r2 & 5)
      return 1;
    if (r2 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x2 = (() => {
    if (r2 & 1)
      return 0;
    if (r2 & 2)
      return Math.max(0, n2.indexOf(l2)) - 1;
    if (r2 & 4)
      return Math.max(0, n2.indexOf(l2)) + 1;
    if (r2 & 8)
      return n2.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p2 = r2 & 32 ? { preventScroll: true } : {}, d2 = 0, a2 = n2.length, u2;
  do {
    if (d2 >= a2 || d2 + a2 <= 0)
      return 0;
    let s2 = x2 + d2;
    if (r2 & 16)
      s2 = (s2 + a2) % a2;
    else {
      if (s2 < 0)
        return 3;
      if (s2 >= a2)
        return 1;
    }
    u2 = n2[s2], u2 == null || u2.focus(p2), d2 += E2;
  } while (u2 !== i2.activeElement);
  return r2 & 6 && H$2(u2) && u2.select(), 2;
}
function d$4(e2, r2, n2) {
  let o3 = s$7(r2);
  reactExports.useEffect(() => {
    function t2(u2) {
      o3.current(u2);
    }
    return document.addEventListener(e2, t2, n2), () => document.removeEventListener(e2, t2, n2);
  }, [e2, n2]);
}
function s$5(e2, r2, n2) {
  let o3 = s$7(r2);
  reactExports.useEffect(() => {
    function t2(i2) {
      o3.current(i2);
    }
    return window.addEventListener(e2, t2, n2), () => window.removeEventListener(e2, t2, n2);
  }, [e2, n2]);
}
function h$5(s2, m2, a2 = true) {
  let i2 = reactExports.useRef(false);
  reactExports.useEffect(() => {
    requestAnimationFrame(() => {
      i2.current = a2;
    });
  }, [a2]);
  function c2(e2, r2) {
    if (!i2.current || e2.defaultPrevented)
      return;
    let t2 = r2(e2);
    if (t2 === null || !t2.getRootNode().contains(t2) || !t2.isConnected)
      return;
    let E2 = function u2(n2) {
      return typeof n2 == "function" ? u2(n2()) : Array.isArray(n2) || n2 instanceof Set ? n2 : [n2];
    }(s2);
    for (let u2 of E2) {
      if (u2 === null)
        continue;
      let n2 = u2 instanceof HTMLElement ? u2 : u2.current;
      if (n2 != null && n2.contains(t2) || e2.composed && e2.composedPath().includes(n2))
        return;
    }
    return !h$6(t2, T$3.Loose) && t2.tabIndex !== -1 && e2.preventDefault(), m2(e2, t2);
  }
  let o3 = reactExports.useRef(null);
  d$4("pointerdown", (e2) => {
    var r2, t2;
    i2.current && (o3.current = ((t2 = (r2 = e2.composedPath) == null ? void 0 : r2.call(e2)) == null ? void 0 : t2[0]) || e2.target);
  }, true), d$4("mousedown", (e2) => {
    var r2, t2;
    i2.current && (o3.current = ((t2 = (r2 = e2.composedPath) == null ? void 0 : r2.call(e2)) == null ? void 0 : t2[0]) || e2.target);
  }, true), d$4("click", (e2) => {
    o3.current && (c2(e2, () => o3.current), o3.current = null);
  }, true), d$4("touchend", (e2) => c2(e2, () => e2.target instanceof HTMLElement ? e2.target : null), true), s$5("blur", (e2) => c2(e2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
function i$4(t2) {
  var n2;
  if (t2.type)
    return t2.type;
  let e2 = (n2 = t2.as) != null ? n2 : "button";
  if (typeof e2 == "string" && e2.toLowerCase() === "button")
    return "button";
}
function s$4(t2, e2) {
  let [n2, u2] = reactExports.useState(() => i$4(t2));
  return l$4(() => {
    u2(i$4(t2));
  }, [t2.type, t2.as]), l$4(() => {
    n2 || e2.current && e2.current instanceof HTMLButtonElement && !e2.current.hasAttribute("type") && u2("button");
  }, [n2, e2]), n2;
}
let u$4 = Symbol();
function T$2(t2, n2 = true) {
  return Object.assign(t2, { [u$4]: n2 });
}
function y$3(...t2) {
  let n2 = reactExports.useRef(t2);
  reactExports.useEffect(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o$4((e2) => {
    for (let o3 of n2.current)
      o3 != null && (typeof o3 == "function" ? o3(e2) : o3.current = e2);
  });
  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u$4])) ? void 0 : c2;
}
function F$1({ container: e2, accept: t2, walk: r2, enabled: c2 = true }) {
  let o3 = reactExports.useRef(t2), l2 = reactExports.useRef(r2);
  reactExports.useEffect(() => {
    o3.current = t2, l2.current = r2;
  }, [t2, r2]), l$4(() => {
    if (!e2 || !c2)
      return;
    let n2 = e$2(e2);
    if (!n2)
      return;
    let f2 = o3.current, p2 = l2.current, d2 = Object.assign((i2) => f2(i2), { acceptNode: f2 }), u2 = n2.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, d2, false);
    for (; u2.nextNode(); )
      p2(u2.currentNode);
  }, [e2, c2, o3, l2]);
}
function f$5(r2) {
  throw new Error("Unexpected object: " + r2);
}
var a$8 = ((e2) => (e2[e2.First = 0] = "First", e2[e2.Previous = 1] = "Previous", e2[e2.Next = 2] = "Next", e2[e2.Last = 3] = "Last", e2[e2.Specific = 4] = "Specific", e2[e2.Nothing = 5] = "Nothing", e2))(a$8 || {});
function x$1(r2, n2) {
  let t2 = n2.resolveItems();
  if (t2.length <= 0)
    return null;
  let l2 = n2.resolveActiveIndex(), s2 = l2 != null ? l2 : -1, d2 = (() => {
    switch (r2.focus) {
      case 0:
        return t2.findIndex((e2) => !n2.resolveDisabled(e2));
      case 1: {
        let e2 = t2.slice().reverse().findIndex((i2, c2, u2) => s2 !== -1 && u2.length - c2 - 1 >= s2 ? false : !n2.resolveDisabled(i2));
        return e2 === -1 ? e2 : t2.length - 1 - e2;
      }
      case 2:
        return t2.findIndex((e2, i2) => i2 <= s2 ? false : !n2.resolveDisabled(e2));
      case 3: {
        let e2 = t2.slice().reverse().findIndex((i2) => !n2.resolveDisabled(i2));
        return e2 === -1 ? e2 : t2.length - 1 - e2;
      }
      case 4:
        return t2.findIndex((e2) => n2.resolveId(e2) === r2.id);
      case 5:
        return null;
      default:
        f$5(r2);
    }
  })();
  return d2 === -1 ? l2 : d2;
}
function t$8(...r2) {
  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
var S$5 = ((a2) => (a2[a2.None = 0] = "None", a2[a2.RenderStrategy = 1] = "RenderStrategy", a2[a2.Static = 2] = "Static", a2))(S$5 || {}), j$2 = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(j$2 || {});
function X$1({ ourProps: r2, theirProps: t2, slot: e2, defaultTag: a2, features: s2, visible: n2 = true, name: f2 }) {
  let o3 = N$1(t2, r2);
  if (n2)
    return c$6(o3, e2, a2, f2);
  let u2 = s2 != null ? s2 : 0;
  if (u2 & 2) {
    let { static: l2 = false, ...p2 } = o3;
    if (l2)
      return c$6(p2, e2, a2, f2);
  }
  if (u2 & 1) {
    let { unmount: l2 = true, ...p2 } = o3;
    return u$5(l2 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return c$6({ ...p2, hidden: true, style: { display: "none" } }, e2, a2, f2);
    } });
  }
  return c$6(o3, e2, a2, f2);
}
function c$6(r2, t2 = {}, e2, a2) {
  let { as: s2 = e2, children: n2, refName: f2 = "ref", ...o3 } = g$1(r2, ["unmount", "static"]), u2 = r2.ref !== void 0 ? { [f2]: r2.ref } : {}, l2 = typeof n2 == "function" ? n2(t2) : n2;
  "className" in o3 && o3.className && typeof o3.className == "function" && (o3.className = o3.className(t2));
  let p2 = {};
  if (t2) {
    let i2 = false, m2 = [];
    for (let [y2, d2] of Object.entries(t2))
      typeof d2 == "boolean" && (i2 = true), d2 === true && m2.push(y2);
    i2 && (p2["data-headlessui-state"] = m2.join(" "));
  }
  if (s2 === reactExports.Fragment && Object.keys(R(o3)).length > 0) {
    if (!reactExports.isValidElement(l2) || Array.isArray(l2) && l2.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${a2} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o3).map((d2) => `  - ${d2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d2) => `  - ${d2}`).join(`
`)].join(`
`));
    let i2 = l2.props, m2 = typeof (i2 == null ? void 0 : i2.className) == "function" ? (...d2) => t$8(i2 == null ? void 0 : i2.className(...d2), o3.className) : t$8(i2 == null ? void 0 : i2.className, o3.className), y2 = m2 ? { className: m2 } : {};
    return reactExports.cloneElement(l2, Object.assign({}, N$1(l2.props, R(g$1(o3, ["ref"]))), p2, u2, w$2(l2.ref, u2.ref), y2));
  }
  return reactExports.createElement(s2, Object.assign({}, g$1(o3, ["ref"]), s2 !== reactExports.Fragment && u2, s2 !== reactExports.Fragment && p2), l2);
}
function w$2(...r2) {
  return { ref: r2.every((t2) => t2 == null) ? void 0 : (t2) => {
    for (let e2 of r2)
      e2 != null && (typeof e2 == "function" ? e2(t2) : e2.current = t2);
  } };
}
function N$1(...r2) {
  if (r2.length === 0)
    return {};
  if (r2.length === 1)
    return r2[0];
  let t2 = {}, e2 = {};
  for (let s2 of r2)
    for (let n2 in s2)
      n2.startsWith("on") && typeof s2[n2] == "function" ? (e2[n2] != null || (e2[n2] = []), e2[n2].push(s2[n2])) : t2[n2] = s2[n2];
  if (t2.disabled || t2["aria-disabled"])
    return Object.assign(t2, Object.fromEntries(Object.keys(e2).map((s2) => [s2, void 0])));
  for (let s2 in e2)
    Object.assign(t2, { [s2](n2, ...f2) {
      let o3 = e2[s2];
      for (let u2 of o3) {
        if ((n2 instanceof Event || (n2 == null ? void 0 : n2.nativeEvent) instanceof Event) && n2.defaultPrevented)
          return;
        u2(n2, ...f2);
      }
    } });
  return t2;
}
function D$2(r2) {
  var t2;
  return Object.assign(reactExports.forwardRef(r2), { displayName: (t2 = r2.displayName) != null ? t2 : r2.name });
}
function R(r2) {
  let t2 = Object.assign({}, r2);
  for (let e2 in t2)
    t2[e2] === void 0 && delete t2[e2];
  return t2;
}
function g$1(r2, t2 = []) {
  let e2 = Object.assign({}, r2);
  for (let a2 of t2)
    a2 in e2 && delete e2[a2];
  return e2;
}
function r$2(n2) {
  let e2 = n2.parentElement, l2 = null;
  for (; e2 && !(e2 instanceof HTMLFieldSetElement); )
    e2 instanceof HTMLLegendElement && (l2 = e2), e2 = e2.parentElement;
  let t2 = (e2 == null ? void 0 : e2.getAttribute("disabled")) === "";
  return t2 && i$3(l2) ? false : t2;
}
function i$3(n2) {
  if (!n2)
    return false;
  let e2 = n2.previousElementSibling;
  for (; e2 !== null; ) {
    if (e2 instanceof HTMLLegendElement)
      return false;
    e2 = e2.previousElementSibling;
  }
  return true;
}
function e$1(i2 = {}, s2 = null, t2 = []) {
  for (let [r2, n2] of Object.entries(i2))
    o$2(t2, f$4(s2, r2), n2);
  return t2;
}
function f$4(i2, s2) {
  return i2 ? i2 + "[" + s2 + "]" : s2;
}
function o$2(i2, s2, t2) {
  if (Array.isArray(t2))
    for (let [r2, n2] of t2.entries())
      o$2(i2, f$4(s2, r2.toString()), n2);
  else
    t2 instanceof Date ? i2.push([s2, t2.toISOString()]) : typeof t2 == "boolean" ? i2.push([s2, t2 ? "1" : "0"]) : typeof t2 == "string" ? i2.push([s2, t2]) : typeof t2 == "number" ? i2.push([s2, `${t2}`]) : t2 == null ? i2.push([s2, ""]) : e$1(t2, s2, i2);
}
function p$3(i2) {
  var t2, r2;
  let s2 = (t2 = i2 == null ? void 0 : i2.form) != null ? t2 : i2.closest("form");
  if (s2) {
    for (let n2 of s2.elements)
      if (n2 !== i2 && (n2.tagName === "INPUT" && n2.type === "submit" || n2.tagName === "BUTTON" && n2.type === "submit" || n2.nodeName === "INPUT" && n2.type === "image")) {
        n2.click();
        return;
      }
    (r2 = s2.requestSubmit) == null || r2.call(s2);
  }
}
let a$7 = "div";
var p$2 = ((e2) => (e2[e2.None = 1] = "None", e2[e2.Focusable = 2] = "Focusable", e2[e2.Hidden = 4] = "Hidden", e2))(p$2 || {});
function s$3(t2, o3) {
  let { features: n2 = 1, ...e2 } = t2, d2 = { ref: o3, "aria-hidden": (n2 & 2) === 2 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(n2 & 4) === 4 && (n2 & 2) !== 2 && { display: "none" } } };
  return X$1({ ourProps: d2, theirProps: e2, slot: {}, defaultTag: a$7, name: "Hidden" });
}
let c$5 = D$2(s$3);
let n$5 = reactExports.createContext(null);
n$5.displayName = "OpenClosedContext";
var d$3 = ((e2) => (e2[e2.Open = 1] = "Open", e2[e2.Closed = 2] = "Closed", e2[e2.Closing = 4] = "Closing", e2[e2.Opening = 8] = "Opening", e2))(d$3 || {});
function C() {
  return reactExports.useContext(n$5);
}
function c$4({ value: o3, children: r2 }) {
  return React.createElement(n$5.Provider, { value: o3 }, r2);
}
var o$1 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$1 || {});
function T$1(l2, r2, c2) {
  let [i2, s2] = reactExports.useState(c2), e2 = l2 !== void 0, t2 = reactExports.useRef(e2), u2 = reactExports.useRef(false), d2 = reactExports.useRef(false);
  return e2 && !t2.current && !u2.current ? (u2.current = true, t2.current = e2, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e2 && t2.current && !d2.current && (d2.current = true, t2.current = e2, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e2 ? l2 : i2, o$4((n2) => (e2 || s2(n2), r2 == null ? void 0 : r2(n2)))];
}
function m$1(u2, t2) {
  let e2 = reactExports.useRef([]), r2 = o$4(u2);
  reactExports.useEffect(() => {
    let o3 = [...e2.current];
    for (let [n2, a2] of t2.entries())
      if (e2.current[n2] !== a2) {
        let l2 = r2(t2, o3);
        return e2.current = t2, l2;
      }
  }, [r2, ...t2]);
}
function t$7(e2) {
  return [e2.screenX, e2.screenY];
}
function u$3() {
  let e2 = reactExports.useRef([-1, -1]);
  return { wasMoved(r2) {
    let n2 = t$7(r2);
    return e2.current[0] === n2[0] && e2.current[1] === n2[1] ? false : (e2.current = n2, true);
  }, update(r2) {
    e2.current = t$7(r2);
  } };
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$2() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$4() {
  return t$6() || i$2();
}
function n$3(...e2) {
  return reactExports.useMemo(() => e$2(...e2), [...e2]);
}
var we$3 = ((e2) => (e2[e2.Open = 0] = "Open", e2[e2.Closed = 1] = "Closed", e2))(we$3 || {}), Ue$2 = ((e2) => (e2[e2.Single = 0] = "Single", e2[e2.Multi = 1] = "Multi", e2))(Ue$2 || {}), Ne$3 = ((e2) => (e2[e2.Pointer = 0] = "Pointer", e2[e2.Other = 1] = "Other", e2))(Ne$3 || {}), He$3 = ((n2) => (n2[n2.OpenCombobox = 0] = "OpenCombobox", n2[n2.CloseCombobox = 1] = "CloseCombobox", n2[n2.GoToOption = 2] = "GoToOption", n2[n2.RegisterOption = 3] = "RegisterOption", n2[n2.UnregisterOption = 4] = "UnregisterOption", n2[n2.RegisterLabel = 5] = "RegisterLabel", n2))(He$3 || {});
function ae$2(t2, a2 = (e2) => e2) {
  let e2 = t2.activeOptionIndex !== null ? t2.options[t2.activeOptionIndex] : null, r2 = I$2(a2(t2.options.slice()), (b2) => b2.dataRef.current.domRef.current), l2 = e2 ? r2.indexOf(e2) : null;
  return l2 === -1 && (l2 = null), { options: r2, activeOptionIndex: l2 };
}
let Ge$3 = { [1](t2) {
  var a2;
  return (a2 = t2.dataRef.current) != null && a2.disabled || t2.comboboxState === 1 ? t2 : { ...t2, activeOptionIndex: null, comboboxState: 1 };
}, [0](t2) {
  var e2;
  if ((e2 = t2.dataRef.current) != null && e2.disabled || t2.comboboxState === 0)
    return t2;
  let a2 = t2.activeOptionIndex;
  if (t2.dataRef.current) {
    let { isSelected: r2 } = t2.dataRef.current, l2 = t2.options.findIndex((b2) => r2(b2.dataRef.current.value));
    l2 !== -1 && (a2 = l2);
  }
  return { ...t2, comboboxState: 0, activeOptionIndex: a2 };
}, [2](t2, a2) {
  var l2, b2, n2, d2;
  if ((l2 = t2.dataRef.current) != null && l2.disabled || (b2 = t2.dataRef.current) != null && b2.optionsRef.current && !((n2 = t2.dataRef.current) != null && n2.optionsPropsRef.current.static) && t2.comboboxState === 1)
    return t2;
  let e2 = ae$2(t2);
  if (e2.activeOptionIndex === null) {
    let o3 = e2.options.findIndex((i2) => !i2.dataRef.current.disabled);
    o3 !== -1 && (e2.activeOptionIndex = o3);
  }
  let r2 = x$1(a2, { resolveItems: () => e2.options, resolveActiveIndex: () => e2.activeOptionIndex, resolveId: (o3) => o3.id, resolveDisabled: (o3) => o3.dataRef.current.disabled });
  return { ...t2, ...e2, activeOptionIndex: r2, activationTrigger: (d2 = a2.trigger) != null ? d2 : 1 };
}, [3]: (t2, a2) => {
  var b2, n2;
  let e2 = { id: a2.id, dataRef: a2.dataRef }, r2 = ae$2(t2, (d2) => [...d2, e2]);
  t2.activeOptionIndex === null && (b2 = t2.dataRef.current) != null && b2.isSelected(a2.dataRef.current.value) && (r2.activeOptionIndex = r2.options.indexOf(e2));
  let l2 = { ...t2, ...r2, activationTrigger: 1 };
  return (n2 = t2.dataRef.current) != null && n2.__demoMode && t2.dataRef.current.value === void 0 && (l2.activeOptionIndex = 0), l2;
}, [4]: (t2, a2) => {
  let e2 = ae$2(t2, (r2) => {
    let l2 = r2.findIndex((b2) => b2.id === a2.id);
    return l2 !== -1 && r2.splice(l2, 1), r2;
  });
  return { ...t2, ...e2, activationTrigger: 1 };
}, [5]: (t2, a2) => ({ ...t2, labelId: a2.id }) }, le$2 = reactExports.createContext(null);
le$2.displayName = "ComboboxActionsContext";
function Z$2(t2) {
  let a2 = reactExports.useContext(le$2);
  if (a2 === null) {
    let e2 = new Error(`<${t2} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e2, Z$2), e2;
  }
  return a2;
}
let ie$3 = reactExports.createContext(null);
ie$3.displayName = "ComboboxDataContext";
function J$1(t2) {
  let a2 = reactExports.useContext(ie$3);
  if (a2 === null) {
    let e2 = new Error(`<${t2} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e2, J$1), e2;
  }
  return a2;
}
function Xe$3(t2, a2) {
  return u$5(a2.type, Ge$3, t2, a2);
}
let je$3 = reactExports.Fragment;
function Je$2(t2, a2) {
  let { value: e2, defaultValue: r2, onChange: l2, form: b2, name: n2, by: d2 = (u2, T2) => u2 === T2, disabled: o3 = false, __demoMode: i2 = false, nullable: A2 = false, multiple: O2 = false, ...C3 } = t2, [f2 = O2 ? [] : void 0, g2] = T$1(e2, l2, r2), [m2, c2] = reactExports.useReducer(Xe$3, { dataRef: reactExports.createRef(), comboboxState: i2 ? 0 : 1, options: [], activeOptionIndex: null, activationTrigger: 1, labelId: null }), D2 = reactExports.useRef(false), _2 = reactExports.useRef({ static: false, hold: false }), w2 = reactExports.useRef(null), U2 = reactExports.useRef(null), N3 = reactExports.useRef(null), K2 = reactExports.useRef(null), h2 = o$4(typeof d2 == "string" ? (u2, T2) => {
    let v2 = d2;
    return (u2 == null ? void 0 : u2[v2]) === (T2 == null ? void 0 : T2[v2]);
  } : d2), H2 = reactExports.useCallback((u2) => u$5(p2.mode, { [1]: () => f2.some((T2) => h2(T2, u2)), [0]: () => h2(f2, u2) }), [f2]), p2 = reactExports.useMemo(() => ({ ...m2, optionsPropsRef: _2, labelRef: w2, inputRef: U2, buttonRef: N3, optionsRef: K2, value: f2, defaultValue: r2, disabled: o3, mode: O2 ? 1 : 0, get activeOptionIndex() {
    if (D2.current && m2.activeOptionIndex === null && m2.options.length > 0) {
      let u2 = m2.options.findIndex((T2) => !T2.dataRef.current.disabled);
      if (u2 !== -1)
        return u2;
    }
    return m2.activeOptionIndex;
  }, compare: h2, isSelected: H2, nullable: A2, __demoMode: i2 }), [f2, r2, o3, O2, A2, i2, m2]), y2 = reactExports.useRef(p2.activeOptionIndex !== null ? p2.options[p2.activeOptionIndex] : null);
  reactExports.useEffect(() => {
    let u2 = p2.activeOptionIndex !== null ? p2.options[p2.activeOptionIndex] : null;
    y2.current !== u2 && (y2.current = u2);
  }), l$4(() => {
    m2.dataRef.current = p2;
  }, [p2]), h$5([p2.buttonRef, p2.inputRef, p2.optionsRef], () => te2.closeCombobox(), p2.comboboxState === 0);
  let E2 = reactExports.useMemo(() => ({ open: p2.comboboxState === 0, disabled: o3, activeIndex: p2.activeOptionIndex, activeOption: p2.activeOptionIndex === null ? null : p2.options[p2.activeOptionIndex].dataRef.current.value, value: f2 }), [p2, o3, f2]), B2 = o$4((u2) => {
    let T2 = p2.options.find((v2) => v2.id === u2);
    T2 && V2(T2.dataRef.current.value);
  }), s2 = o$4(() => {
    if (p2.activeOptionIndex !== null) {
      let { dataRef: u2, id: T2 } = p2.options[p2.activeOptionIndex];
      V2(u2.current.value), te2.goToOption(a$8.Specific, T2);
    }
  }), W2 = o$4(() => {
    c2({ type: 0 }), D2.current = true;
  }), L2 = o$4(() => {
    c2({ type: 1 }), D2.current = false;
  }), $2 = o$4((u2, T2, v2) => (D2.current = false, u2 === a$8.Specific ? c2({ type: 2, focus: a$8.Specific, id: T2, trigger: v2 }) : c2({ type: 2, focus: u2, trigger: v2 }))), P2 = o$4((u2, T2) => (c2({ type: 3, id: u2, dataRef: T2 }), () => {
    var v2;
    ((v2 = y2.current) == null ? void 0 : v2.id) === u2 && (D2.current = true), c2({ type: 4, id: u2 });
  })), F3 = o$4((u2) => (c2({ type: 5, id: u2 }), () => c2({ type: 5, id: null }))), V2 = o$4((u2) => u$5(p2.mode, { [0]() {
    return g2 == null ? void 0 : g2(u2);
  }, [1]() {
    let T2 = p2.value.slice(), v2 = T2.findIndex((q2) => h2(q2, u2));
    return v2 === -1 ? T2.push(u2) : T2.splice(v2, 1), g2 == null ? void 0 : g2(T2);
  } })), te2 = reactExports.useMemo(() => ({ onChange: V2, registerOption: P2, registerLabel: F3, goToOption: $2, closeCombobox: L2, openCombobox: W2, selectActiveOption: s2, selectOption: B2 }), []), Te2 = a2 === null ? {} : { ref: a2 }, z2 = reactExports.useRef(null), me2 = p$4();
  return reactExports.useEffect(() => {
    z2.current && r2 !== void 0 && me2.addEventListener(z2.current, "reset", () => {
      g2 == null || g2(r2);
    });
  }, [z2, g2]), React.createElement(le$2.Provider, { value: te2 }, React.createElement(ie$3.Provider, { value: p2 }, React.createElement(c$4, { value: u$5(p2.comboboxState, { [0]: d$3.Open, [1]: d$3.Closed }) }, n2 != null && f2 != null && e$1({ [n2]: f2 }).map(([u2, T2], v2) => React.createElement(c$5, { features: p$2.Hidden, ref: v2 === 0 ? (q2) => {
    var ue2;
    z2.current = (ue2 = q2 == null ? void 0 : q2.closest("form")) != null ? ue2 : null;
  } : void 0, ...R({ key: u2, as: "input", type: "hidden", hidden: true, readOnly: true, form: b2, name: u2, value: T2 }) })), X$1({ ourProps: Te2, theirProps: C3, slot: E2, defaultTag: je$3, name: "Combobox" }))));
}
let Ke$3 = "input";
function We$2(t2, a2) {
  var p2, y2, E2, B2;
  let e2 = I$3(), { id: r2 = `headlessui-combobox-input-${e2}`, onChange: l2, displayValue: b2, type: n2 = "text", ...d2 } = t2, o3 = J$1("Combobox.Input"), i2 = Z$2("Combobox.Input"), A2 = y$3(o3.inputRef, a2), O2 = n$3(o3.inputRef), C3 = reactExports.useRef(false), f2 = p$4(), g2 = o$4(() => {
    i2.onChange(null), o3.optionsRef.current && (o3.optionsRef.current.scrollTop = 0), i2.goToOption(a$8.Nothing);
  }), m2 = function() {
    var s2;
    return typeof b2 == "function" && o3.value !== void 0 ? (s2 = b2(o3.value)) != null ? s2 : "" : typeof o3.value == "string" ? o3.value : "";
  }();
  m$1(([s2, W2], [L2, $2]) => {
    if (C3.current)
      return;
    let P2 = o3.inputRef.current;
    P2 && (($2 === 0 && W2 === 1 || s2 !== L2) && (P2.value = s2), requestAnimationFrame(() => {
      if (C3.current || !P2 || (O2 == null ? void 0 : O2.activeElement) !== P2)
        return;
      let { selectionStart: F3, selectionEnd: V2 } = P2;
      Math.abs((V2 != null ? V2 : 0) - (F3 != null ? F3 : 0)) === 0 && F3 === 0 && P2.setSelectionRange(P2.value.length, P2.value.length);
    }));
  }, [m2, o3.comboboxState, O2]), m$1(([s2], [W2]) => {
    if (s2 === 0 && W2 === 1) {
      if (C3.current)
        return;
      let L2 = o3.inputRef.current;
      if (!L2)
        return;
      let $2 = L2.value, { selectionStart: P2, selectionEnd: F3, selectionDirection: V2 } = L2;
      L2.value = "", L2.value = $2, V2 !== null ? L2.setSelectionRange(P2, F3, V2) : L2.setSelectionRange(P2, F3);
    }
  }, [o3.comboboxState]);
  let c2 = reactExports.useRef(false), D2 = o$4(() => {
    c2.current = true;
  }), _2 = o$4(() => {
    f2.nextFrame(() => {
      c2.current = false;
    });
  }), w2 = o$4((s2) => {
    switch (C3.current = true, s2.key) {
      case o$1.Enter:
        if (C3.current = false, o3.comboboxState !== 0 || c2.current)
          return;
        if (s2.preventDefault(), s2.stopPropagation(), o3.activeOptionIndex === null) {
          i2.closeCombobox();
          return;
        }
        i2.selectActiveOption(), o3.mode === 0 && i2.closeCombobox();
        break;
      case o$1.ArrowDown:
        return C3.current = false, s2.preventDefault(), s2.stopPropagation(), u$5(o3.comboboxState, { [0]: () => {
          i2.goToOption(a$8.Next);
        }, [1]: () => {
          i2.openCombobox();
        } });
      case o$1.ArrowUp:
        return C3.current = false, s2.preventDefault(), s2.stopPropagation(), u$5(o3.comboboxState, { [0]: () => {
          i2.goToOption(a$8.Previous);
        }, [1]: () => {
          i2.openCombobox(), f2.nextFrame(() => {
            o3.value || i2.goToOption(a$8.Last);
          });
        } });
      case o$1.Home:
        if (s2.shiftKey)
          break;
        return C3.current = false, s2.preventDefault(), s2.stopPropagation(), i2.goToOption(a$8.First);
      case o$1.PageUp:
        return C3.current = false, s2.preventDefault(), s2.stopPropagation(), i2.goToOption(a$8.First);
      case o$1.End:
        if (s2.shiftKey)
          break;
        return C3.current = false, s2.preventDefault(), s2.stopPropagation(), i2.goToOption(a$8.Last);
      case o$1.PageDown:
        return C3.current = false, s2.preventDefault(), s2.stopPropagation(), i2.goToOption(a$8.Last);
      case o$1.Escape:
        return C3.current = false, o3.comboboxState !== 0 ? void 0 : (s2.preventDefault(), o3.optionsRef.current && !o3.optionsPropsRef.current.static && s2.stopPropagation(), o3.nullable && o3.mode === 0 && o3.value === null && g2(), i2.closeCombobox());
      case o$1.Tab:
        if (C3.current = false, o3.comboboxState !== 0)
          return;
        o3.mode === 0 && i2.selectActiveOption(), i2.closeCombobox();
        break;
    }
  }), U2 = o$4((s2) => {
    l2 == null || l2(s2), o3.nullable && o3.mode === 0 && s2.target.value === "" && g2(), i2.openCombobox();
  }), N3 = o$4(() => {
    C3.current = false;
  }), K2 = i$5(() => {
    if (o3.labelId)
      return [o3.labelId].join(" ");
  }, [o3.labelId]), h2 = reactExports.useMemo(() => ({ open: o3.comboboxState === 0, disabled: o3.disabled }), [o3]), H2 = { ref: A2, id: r2, role: "combobox", type: n2, "aria-controls": (p2 = o3.optionsRef.current) == null ? void 0 : p2.id, "aria-expanded": o3.comboboxState === 0, "aria-activedescendant": o3.activeOptionIndex === null || (y2 = o3.options[o3.activeOptionIndex]) == null ? void 0 : y2.id, "aria-labelledby": K2, "aria-autocomplete": "list", defaultValue: (B2 = (E2 = t2.defaultValue) != null ? E2 : o3.defaultValue !== void 0 ? b2 == null ? void 0 : b2(o3.defaultValue) : null) != null ? B2 : o3.defaultValue, disabled: o3.disabled, onCompositionStart: D2, onCompositionEnd: _2, onKeyDown: w2, onChange: U2, onBlur: N3 };
  return X$1({ ourProps: H2, theirProps: d2, slot: h2, defaultTag: Ke$3, name: "Combobox.Input" });
}
let $e$2 = "button";
function qe$2(t2, a2) {
  var g2;
  let e2 = J$1("Combobox.Button"), r2 = Z$2("Combobox.Button"), l2 = y$3(e2.buttonRef, a2), b2 = I$3(), { id: n2 = `headlessui-combobox-button-${b2}`, ...d2 } = t2, o3 = p$4(), i2 = o$4((m2) => {
    switch (m2.key) {
      case o$1.ArrowDown:
        return m2.preventDefault(), m2.stopPropagation(), e2.comboboxState === 1 && r2.openCombobox(), o3.nextFrame(() => {
          var c2;
          return (c2 = e2.inputRef.current) == null ? void 0 : c2.focus({ preventScroll: true });
        });
      case o$1.ArrowUp:
        return m2.preventDefault(), m2.stopPropagation(), e2.comboboxState === 1 && (r2.openCombobox(), o3.nextFrame(() => {
          e2.value || r2.goToOption(a$8.Last);
        })), o3.nextFrame(() => {
          var c2;
          return (c2 = e2.inputRef.current) == null ? void 0 : c2.focus({ preventScroll: true });
        });
      case o$1.Escape:
        return e2.comboboxState !== 0 ? void 0 : (m2.preventDefault(), e2.optionsRef.current && !e2.optionsPropsRef.current.static && m2.stopPropagation(), r2.closeCombobox(), o3.nextFrame(() => {
          var c2;
          return (c2 = e2.inputRef.current) == null ? void 0 : c2.focus({ preventScroll: true });
        }));
      default:
        return;
    }
  }), A2 = o$4((m2) => {
    if (r$2(m2.currentTarget))
      return m2.preventDefault();
    e2.comboboxState === 0 ? r2.closeCombobox() : (m2.preventDefault(), r2.openCombobox()), o3.nextFrame(() => {
      var c2;
      return (c2 = e2.inputRef.current) == null ? void 0 : c2.focus({ preventScroll: true });
    });
  }), O2 = i$5(() => {
    if (e2.labelId)
      return [e2.labelId, n2].join(" ");
  }, [e2.labelId, n2]), C3 = reactExports.useMemo(() => ({ open: e2.comboboxState === 0, disabled: e2.disabled, value: e2.value }), [e2]), f2 = { ref: l2, id: n2, type: s$4(t2, e2.buttonRef), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": (g2 = e2.optionsRef.current) == null ? void 0 : g2.id, "aria-expanded": e2.comboboxState === 0, "aria-labelledby": O2, disabled: e2.disabled, onClick: A2, onKeyDown: i2 };
  return X$1({ ourProps: f2, theirProps: d2, slot: C3, defaultTag: $e$2, name: "Combobox.Button" });
}
let Qe$2 = "label";
function Ye$2(t2, a2) {
  let e2 = I$3(), { id: r2 = `headlessui-combobox-label-${e2}`, ...l2 } = t2, b2 = J$1("Combobox.Label"), n2 = Z$2("Combobox.Label"), d2 = y$3(b2.labelRef, a2);
  l$4(() => n2.registerLabel(r2), [r2]);
  let o3 = o$4(() => {
    var O2;
    return (O2 = b2.inputRef.current) == null ? void 0 : O2.focus({ preventScroll: true });
  }), i2 = reactExports.useMemo(() => ({ open: b2.comboboxState === 0, disabled: b2.disabled }), [b2]);
  return X$1({ ourProps: { ref: d2, id: r2, onClick: o3 }, theirProps: l2, slot: i2, defaultTag: Qe$2, name: "Combobox.Label" });
}
let Ze$2 = "ul", ze$2 = S$5.RenderStrategy | S$5.Static;
function eo(t2, a2) {
  let e2 = I$3(), { id: r2 = `headlessui-combobox-options-${e2}`, hold: l2 = false, ...b2 } = t2, n2 = J$1("Combobox.Options"), d2 = y$3(n2.optionsRef, a2), o3 = C(), i2 = (() => o3 !== null ? (o3 & d$3.Open) === d$3.Open : n2.comboboxState === 0)();
  l$4(() => {
    var f2;
    n2.optionsPropsRef.current.static = (f2 = t2.static) != null ? f2 : false;
  }, [n2.optionsPropsRef, t2.static]), l$4(() => {
    n2.optionsPropsRef.current.hold = l2;
  }, [n2.optionsPropsRef, l2]), F$1({ container: n2.optionsRef.current, enabled: n2.comboboxState === 0, accept(f2) {
    return f2.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : f2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(f2) {
    f2.setAttribute("role", "none");
  } });
  let A2 = i$5(() => {
    var f2, g2;
    return (g2 = n2.labelId) != null ? g2 : (f2 = n2.buttonRef.current) == null ? void 0 : f2.id;
  }, [n2.labelId, n2.buttonRef.current]), O2 = reactExports.useMemo(() => ({ open: n2.comboboxState === 0 }), [n2]), C$12 = { "aria-labelledby": A2, role: "listbox", "aria-multiselectable": n2.mode === 1 ? true : void 0, id: r2, ref: d2 };
  return X$1({ ourProps: C$12, theirProps: b2, slot: O2, defaultTag: Ze$2, features: ze$2, visible: i2, name: "Combobox.Options" });
}
let oo = "li";
function to(t2, a2) {
  var H2, p2;
  let e2 = I$3(), { id: r2 = `headlessui-combobox-option-${e2}`, disabled: l2 = false, value: b2, ...n2 } = t2, d2 = J$1("Combobox.Option"), o3 = Z$2("Combobox.Option"), i2 = d2.activeOptionIndex !== null ? d2.options[d2.activeOptionIndex].id === r2 : false, A2 = d2.isSelected(b2), O2 = reactExports.useRef(null), C3 = s$7({ disabled: l2, value: b2, domRef: O2, textValue: (p2 = (H2 = O2.current) == null ? void 0 : H2.textContent) == null ? void 0 : p2.toLowerCase() }), f2 = y$3(a2, O2), g2 = o$4(() => o3.selectOption(r2));
  l$4(() => o3.registerOption(r2, C3), [C3, r2]);
  let m2 = reactExports.useRef(!d2.__demoMode);
  l$4(() => {
    if (!d2.__demoMode)
      return;
    let y2 = o$5();
    return y2.requestAnimationFrame(() => {
      m2.current = true;
    }), y2.dispose;
  }, []), l$4(() => {
    if (d2.comboboxState !== 0 || !i2 || !m2.current || d2.activationTrigger === 0)
      return;
    let y2 = o$5();
    return y2.requestAnimationFrame(() => {
      var E2, B2;
      (B2 = (E2 = O2.current) == null ? void 0 : E2.scrollIntoView) == null || B2.call(E2, { block: "nearest" });
    }), y2.dispose;
  }, [O2, i2, d2.comboboxState, d2.activationTrigger, d2.activeOptionIndex]);
  let c2 = o$4((y2) => {
    if (l2)
      return y2.preventDefault();
    g2(), d2.mode === 0 && o3.closeCombobox(), n$4() || requestAnimationFrame(() => {
      var E2;
      return (E2 = d2.inputRef.current) == null ? void 0 : E2.focus();
    });
  }), D2 = o$4(() => {
    if (l2)
      return o3.goToOption(a$8.Nothing);
    o3.goToOption(a$8.Specific, r2);
  }), _2 = u$3(), w2 = o$4((y2) => _2.update(y2)), U2 = o$4((y2) => {
    _2.wasMoved(y2) && (l2 || i2 || o3.goToOption(a$8.Specific, r2, 0));
  }), N3 = o$4((y2) => {
    _2.wasMoved(y2) && (l2 || i2 && (d2.optionsPropsRef.current.hold || o3.goToOption(a$8.Nothing)));
  }), K2 = reactExports.useMemo(() => ({ active: i2, selected: A2, disabled: l2 }), [i2, A2, l2]);
  return X$1({ ourProps: { id: r2, ref: f2, role: "option", tabIndex: l2 === true ? void 0 : -1, "aria-disabled": l2 === true ? true : void 0, "aria-selected": A2, disabled: void 0, onClick: c2, onFocus: D2, onPointerEnter: w2, onMouseEnter: w2, onPointerMove: U2, onMouseMove: U2, onPointerLeave: N3, onMouseLeave: N3 }, theirProps: n2, slot: K2, defaultTag: oo, name: "Combobox.Option" });
}
let no = D$2(Je$2), ro = D$2(qe$2), ao = D$2(We$2), lo = D$2(Ye$2), io = D$2(eo), uo = D$2(to), qo = Object.assign(no, { Input: ao, Button: ro, Label: lo, Options: io, Option: uo });
var s$2 = ((r2) => (r2[r2.Forwards = 0] = "Forwards", r2[r2.Backwards = 1] = "Backwards", r2))(s$2 || {});
function n$2() {
  let e2 = reactExports.useRef(0);
  return s$5("keydown", (o3) => {
    o3.key === "Tab" && (e2.current = o3.shiftKey ? 1 : 0);
  }, true), e2;
}
function f$3() {
  let e2 = reactExports.useRef(false);
  return l$4(() => (e2.current = true, () => {
    e2.current = false;
  }), []), e2;
}
function E$1(n2, e2, a2, t2) {
  let i2 = s$7(a2);
  reactExports.useEffect(() => {
    n2 = n2 != null ? n2 : window;
    function r2(o3) {
      i2.current(o3);
    }
    return n2.addEventListener(e2, r2, t2), () => n2.removeEventListener(e2, r2, t2);
  }, [n2, e2, t2]);
}
function t$5(n2) {
  function e2() {
    document.readyState !== "loading" && (n2(), document.removeEventListener("DOMContentLoaded", e2));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e2), e2());
}
function c$3(t2) {
  let r2 = o$4(t2), e2 = reactExports.useRef(false);
  reactExports.useEffect(() => (e2.current = false, () => {
    e2.current = true, t$9(() => {
      e2.current && r2();
    });
  }), [r2]);
}
function P$1(t2) {
  if (!t2)
    return /* @__PURE__ */ new Set();
  if (typeof t2 == "function")
    return new Set(t2());
  let r2 = /* @__PURE__ */ new Set();
  for (let e2 of t2.current)
    e2.current instanceof HTMLElement && r2.add(e2.current);
  return r2;
}
let J = "div";
var h$4 = ((n2) => (n2[n2.None = 1] = "None", n2[n2.InitialFocus = 2] = "InitialFocus", n2[n2.TabLock = 4] = "TabLock", n2[n2.FocusLock = 8] = "FocusLock", n2[n2.RestoreFocus = 16] = "RestoreFocus", n2[n2.All = 30] = "All", n2))(h$4 || {});
function X(t2, r2) {
  let e2 = reactExports.useRef(null), o3 = y$3(e2, r2), { initialFocus: u2, containers: i2, features: n2 = 30, ...l2 } = t2;
  l$3() || (n2 = 1);
  let m2 = n$3(e2);
  Y$1({ ownerDocument: m2 }, Boolean(n2 & 16));
  let c2 = Z$1({ ownerDocument: m2, container: e2, initialFocus: u2 }, Boolean(n2 & 2));
  $$1({ ownerDocument: m2, container: e2, containers: i2, previousActiveElement: c2 }, Boolean(n2 & 8));
  let v2 = n$2(), y2 = o$4((s2) => {
    let T2 = e2.current;
    if (!T2)
      return;
    ((B2) => B2())(() => {
      u$5(v2.current, { [s$2.Forwards]: () => {
        O(T2, M$6.First, { skipElements: [s2.relatedTarget] });
      }, [s$2.Backwards]: () => {
        O(T2, M$6.Last, { skipElements: [s2.relatedTarget] });
      } });
    });
  }), _2 = p$4(), b2 = reactExports.useRef(false), j2 = { ref: o3, onKeyDown(s2) {
    s2.key == "Tab" && (b2.current = true, _2.requestAnimationFrame(() => {
      b2.current = false;
    }));
  }, onBlur(s2) {
    let T2 = P$1(i2);
    e2.current instanceof HTMLElement && T2.add(e2.current);
    let d2 = s2.relatedTarget;
    d2 instanceof HTMLElement && d2.dataset.headlessuiFocusGuard !== "true" && (S$4(T2, d2) || (b2.current ? O(e2.current, u$5(v2.current, { [s$2.Forwards]: () => M$6.Next, [s$2.Backwards]: () => M$6.Previous }) | M$6.WrapAround, { relativeTo: s2.target }) : s2.target instanceof HTMLElement && y$4(s2.target)));
  } };
  return React.createElement(React.Fragment, null, Boolean(n2 & 4) && React.createElement(c$5, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: y2, features: p$2.Focusable }), X$1({ ourProps: j2, theirProps: l2, defaultTag: J, name: "FocusTrap" }), Boolean(n2 & 4) && React.createElement(c$5, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: y2, features: p$2.Focusable }));
}
let z$2 = D$2(X), ge = Object.assign(z$2, { features: h$4 }), a$6 = [];
t$5(() => {
  function t2(r2) {
    r2.target instanceof HTMLElement && r2.target !== document.body && a$6[0] !== r2.target && (a$6.unshift(r2.target), a$6 = a$6.filter((e2) => e2 != null && e2.isConnected), a$6.splice(10));
  }
  window.addEventListener("click", t2, { capture: true }), window.addEventListener("mousedown", t2, { capture: true }), window.addEventListener("focus", t2, { capture: true }), document.body.addEventListener("click", t2, { capture: true }), document.body.addEventListener("mousedown", t2, { capture: true }), document.body.addEventListener("focus", t2, { capture: true });
});
function Q$1(t2 = true) {
  let r2 = reactExports.useRef(a$6.slice());
  return m$1(([e2], [o3]) => {
    o3 === true && e2 === false && t$9(() => {
      r2.current.splice(0);
    }), o3 === false && e2 === true && (r2.current = a$6.slice());
  }, [t2, a$6, r2]), o$4(() => {
    var e2;
    return (e2 = r2.current.find((o3) => o3 != null && o3.isConnected)) != null ? e2 : null;
  });
}
function Y$1({ ownerDocument: t2 }, r2) {
  let e2 = Q$1(r2);
  m$1(() => {
    r2 || (t2 == null ? void 0 : t2.activeElement) === (t2 == null ? void 0 : t2.body) && y$4(e2());
  }, [r2]), c$3(() => {
    r2 && y$4(e2());
  });
}
function Z$1({ ownerDocument: t2, container: r2, initialFocus: e2 }, o3) {
  let u2 = reactExports.useRef(null), i2 = f$3();
  return m$1(() => {
    if (!o3)
      return;
    let n2 = r2.current;
    n2 && t$9(() => {
      if (!i2.current)
        return;
      let l2 = t2 == null ? void 0 : t2.activeElement;
      if (e2 != null && e2.current) {
        if ((e2 == null ? void 0 : e2.current) === l2) {
          u2.current = l2;
          return;
        }
      } else if (n2.contains(l2)) {
        u2.current = l2;
        return;
      }
      e2 != null && e2.current ? y$4(e2.current) : O(n2, M$6.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), u2.current = t2 == null ? void 0 : t2.activeElement;
    });
  }, [o3]), u2;
}
function $$1({ ownerDocument: t2, container: r2, containers: e2, previousActiveElement: o3 }, u2) {
  let i2 = f$3();
  E$1(t2 == null ? void 0 : t2.defaultView, "focus", (n2) => {
    if (!u2 || !i2.current)
      return;
    let l2 = P$1(e2);
    r2.current instanceof HTMLElement && l2.add(r2.current);
    let m2 = o3.current;
    if (!m2)
      return;
    let c2 = n2.target;
    c2 && c2 instanceof HTMLElement ? S$4(l2, c2) ? (o3.current = c2, y$4(c2)) : (n2.preventDefault(), n2.stopPropagation(), y$4(m2)) : y$4(o3.current);
  }, true);
}
function S$4(t2, r2) {
  for (let e2 of t2)
    if (e2.contains(r2))
      return true;
  return false;
}
let e = reactExports.createContext(false);
function l$2() {
  return reactExports.useContext(e);
}
function P(o3) {
  return React.createElement(e.Provider, { value: o3.force }, o3.children);
}
function F(p2) {
  let l2 = l$2(), n2 = reactExports.useContext(v$3), e2 = n$3(p2), [a2, o3] = reactExports.useState(() => {
    if (!l2 && n2 !== null || s$8.isServer)
      return null;
    let t2 = e2 == null ? void 0 : e2.getElementById("headlessui-portal-root");
    if (t2)
      return t2;
    if (e2 === null)
      return null;
    let r2 = e2.createElement("div");
    return r2.setAttribute("id", "headlessui-portal-root"), e2.body.appendChild(r2);
  });
  return reactExports.useEffect(() => {
    a2 !== null && (e2 != null && e2.body.contains(a2) || e2 == null || e2.body.appendChild(a2));
  }, [a2, e2]), reactExports.useEffect(() => {
    l2 || n2 !== null && o3(n2.current);
  }, [n2, o3, l2]), a2;
}
let U$1 = reactExports.Fragment;
function N(p2, l2) {
  let n2 = p2, e2 = reactExports.useRef(null), a2 = y$3(T$2((u2) => {
    e2.current = u2;
  }), l2), o3 = n$3(e2), t2 = F(e2), [r2] = reactExports.useState(() => {
    var u2;
    return s$8.isServer ? null : (u2 = o3 == null ? void 0 : o3.createElement("div")) != null ? u2 : null;
  }), i2 = reactExports.useContext(f$2), C3 = l$3();
  return l$4(() => {
    !t2 || !r2 || t2.contains(r2) || (r2.setAttribute("data-headlessui-portal", ""), t2.appendChild(r2));
  }, [t2, r2]), l$4(() => {
    if (r2 && i2)
      return i2.register(r2);
  }, [i2, r2]), c$3(() => {
    var u2;
    !t2 || !r2 || (r2 instanceof Node && t2.contains(r2) && t2.removeChild(r2), t2.childNodes.length <= 0 && ((u2 = t2.parentElement) == null || u2.removeChild(t2)));
  }), C3 ? !t2 || !r2 ? null : reactDomExports.createPortal(X$1({ ourProps: { ref: a2 }, theirProps: n2, defaultTag: U$1, name: "Portal" }), r2) : null;
}
let S$3 = reactExports.Fragment, v$3 = reactExports.createContext(null);
function j$1(p2, l2) {
  let { target: n2, ...e2 } = p2, o3 = { ref: y$3(l2) };
  return React.createElement(v$3.Provider, { value: n2 }, X$1({ ourProps: o3, theirProps: e2, defaultTag: S$3, name: "Popover.Group" }));
}
let f$2 = reactExports.createContext(null);
function ae$1() {
  let p2 = reactExports.useContext(f$2), l2 = reactExports.useRef([]), n2 = o$4((o3) => (l2.current.push(o3), p2 && p2.register(o3), () => e2(o3))), e2 = o$4((o3) => {
    let t2 = l2.current.indexOf(o3);
    t2 !== -1 && l2.current.splice(t2, 1), p2 && p2.unregister(o3);
  }), a2 = reactExports.useMemo(() => ({ register: n2, unregister: e2, portals: l2 }), [n2, e2, l2]);
  return [l2, reactExports.useMemo(() => function({ children: t2 }) {
    return React.createElement(f$2.Provider, { value: a2 }, t2);
  }, [a2])];
}
let D$1 = D$2(N), I$1 = D$2(j$1), pe = Object.assign(D$1, { Group: I$1 });
let d$2 = reactExports.createContext(null);
function f$1() {
  let r2 = reactExports.useContext(d$2);
  if (r2 === null) {
    let t2 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t2, f$1), t2;
  }
  return r2;
}
function M$5() {
  let [r2, t2] = reactExports.useState([]);
  return [r2.length > 0 ? r2.join(" ") : void 0, reactExports.useMemo(() => function(e2) {
    let i2 = o$4((s2) => (t2((o3) => [...o3, s2]), () => t2((o3) => {
      let p2 = o3.slice(), c2 = p2.indexOf(s2);
      return c2 !== -1 && p2.splice(c2, 1), p2;
    }))), n2 = reactExports.useMemo(() => ({ register: i2, slot: e2.slot, name: e2.name, props: e2.props }), [i2, e2.slot, e2.name, e2.props]);
    return React.createElement(d$2.Provider, { value: n2 }, e2.children);
  }, [t2])];
}
let S$2 = "p";
function h$3(r2, t2) {
  let a2 = I$3(), { id: e2 = `headlessui-description-${a2}`, ...i2 } = r2, n2 = f$1(), s2 = y$3(t2);
  l$4(() => n2.register(e2), [e2, n2.register]);
  let o3 = { ref: s2, ...n2.props, id: e2 };
  return X$1({ ourProps: o3, theirProps: i2, slot: n2.slot || {}, defaultTag: S$2, name: n2.name || "Description" });
}
let y$2 = D$2(h$3), b$2 = Object.assign(y$2, {});
let a$5 = reactExports.createContext(() => {
});
a$5.displayName = "StackContext";
var s$1 = ((e2) => (e2[e2.Add = 0] = "Add", e2[e2.Remove = 1] = "Remove", e2))(s$1 || {});
function x() {
  return reactExports.useContext(a$5);
}
function M$4({ children: i2, onUpdate: r2, type: e2, element: n2, enabled: u2 }) {
  let l2 = x(), o3 = o$4((...t2) => {
    r2 == null || r2(...t2), l2(...t2);
  });
  return l$4(() => {
    let t2 = u2 === void 0 || u2 === true;
    return t2 && o3(0, e2, n2), () => {
      t2 && o3(1, e2, n2);
    };
  }, [o3, e2, n2, u2]), React.createElement(a$5.Provider, { value: o3 }, i2);
}
function i$1(e2, t2) {
  return e2 === t2 && (e2 !== 0 || 1 / e2 === 1 / t2) || e2 !== e2 && t2 !== t2;
}
const d$1 = typeof Object.is == "function" ? Object.is : i$1, { useState: u$2, useEffect: h$2, useLayoutEffect: f, useDebugValue: p$1 } = React$1;
function y$1(e2, t2, c2) {
  const a2 = t2(), [{ inst: n2 }, o3] = u$2({ inst: { value: a2, getSnapshot: t2 } });
  return f(() => {
    n2.value = a2, n2.getSnapshot = t2, r$1(n2) && o3({ inst: n2 });
  }, [e2, a2, t2]), h$2(() => (r$1(n2) && o3({ inst: n2 }), e2(() => {
    r$1(n2) && o3({ inst: n2 });
  })), [e2]), p$1(a2), a2;
}
function r$1(e2) {
  const t2 = e2.getSnapshot, c2 = e2.value;
  try {
    const a2 = t2();
    return !d$1(c2, a2);
  } catch {
    return true;
  }
}
function t$4(r2, e2, n2) {
  return e2();
}
const r = typeof window != "undefined" && typeof window.document != "undefined" && typeof window.document.createElement != "undefined", s = !r, c$2 = s ? t$4 : y$1, a$4 = "useSyncExternalStore" in React$1 ? ((n2) => n2.useSyncExternalStore)(React$1) : c$2;
function S$1(t2) {
  return a$4(t2.subscribe, t2.getSnapshot, t2.getSnapshot);
}
function a$3(o3, r2) {
  let t2 = o3(), n2 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t2;
  }, subscribe(e2) {
    return n2.add(e2), () => n2.delete(e2);
  }, dispatch(e2, ...s2) {
    let i2 = r2[e2].call(t2, ...s2);
    i2 && (t2 = i2, n2.forEach((c2) => c2()));
  } };
}
function c$1() {
  let o3;
  return { before({ doc: e2 }) {
    var l2;
    let n2 = e2.documentElement;
    o3 = ((l2 = e2.defaultView) != null ? l2 : window).innerWidth - n2.clientWidth;
  }, after({ doc: e2, d: n2 }) {
    let t2 = e2.documentElement, l2 = t2.clientWidth - t2.offsetWidth, r2 = o3 - l2;
    n2.style(t2, "paddingRight", `${r2}px`);
  } };
}
function T() {
  if (!t$6())
    return {};
  let l2;
  return { before() {
    l2 = window.pageYOffset;
  }, after({ doc: o3, d: t2, meta: s2 }) {
    function i2(n2) {
      return s2.containers.flatMap((e2) => e2()).some((e2) => e2.contains(n2));
    }
    t2.microTask(() => {
      if (window.getComputedStyle(o3.documentElement).scrollBehavior !== "auto") {
        let e2 = o$5();
        e2.style(o3.documentElement, "scroll-behavior", "auto"), t2.add(() => t2.microTask(() => e2.dispose()));
      }
      t2.style(o3.body, "marginTop", `-${l2}px`), window.scrollTo(0, 0);
      let n2 = null;
      t2.addEventListener(o3, "click", (e2) => {
        if (e2.target instanceof HTMLElement)
          try {
            let r2 = e2.target.closest("a");
            if (!r2)
              return;
            let { hash: c2 } = new URL(r2.href), a2 = o3.querySelector(c2);
            a2 && !i2(a2) && (n2 = a2);
          } catch {
          }
      }, true), t2.addEventListener(o3, "touchmove", (e2) => {
        e2.target instanceof HTMLElement && !i2(e2.target) && e2.preventDefault();
      }, { passive: false }), t2.add(() => {
        window.scrollTo(0, window.pageYOffset + l2), n2 && n2.isConnected && (n2.scrollIntoView({ block: "nearest" }), n2 = null);
      });
    });
  } };
}
function l$1() {
  return { before({ doc: e2, d: o3 }) {
    o3.style(e2.documentElement, "overflow", "hidden");
  } };
}
function m(e2) {
  let n2 = {};
  for (let t2 of e2)
    Object.assign(n2, t2(n2));
  return n2;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(e2, n2) {
  var o3;
  let t2 = (o3 = this.get(e2)) != null ? o3 : { doc: e2, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return t2.count++, t2.meta.add(n2), this.set(e2, t2), this;
}, POP(e2, n2) {
  let t2 = this.get(e2);
  return t2 && (t2.count--, t2.meta.delete(n2)), this;
}, SCROLL_PREVENT({ doc: e2, d: n2, meta: t2 }) {
  let o3 = { doc: e2, d: n2, meta: m(t2) }, c2 = [T(), c$1(), l$1()];
  c2.forEach(({ before: r2 }) => r2 == null ? void 0 : r2(o3)), c2.forEach(({ after: r2 }) => r2 == null ? void 0 : r2(o3));
}, SCROLL_ALLOW({ d: e2 }) {
  e2.dispose();
}, TEARDOWN({ doc: e2 }) {
  this.delete(e2);
} });
a$2.subscribe(() => {
  let e2 = a$2.getSnapshot(), n2 = /* @__PURE__ */ new Map();
  for (let [t2] of e2)
    n2.set(t2, t2.documentElement.style.overflow);
  for (let t2 of e2.values()) {
    let o3 = n2.get(t2.doc) === "hidden", c2 = t2.count !== 0;
    (c2 && !o3 || !c2 && o3) && a$2.dispatch(t2.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t2), t2.count === 0 && a$2.dispatch("TEARDOWN", t2);
  }
});
function p(e2, r2, n2) {
  let f2 = S$1(a$2), o3 = e2 ? f2.get(e2) : void 0, i2 = o3 ? o3.count > 0 : false;
  return l$4(() => {
    if (!(!e2 || !r2))
      return a$2.dispatch("PUSH", e2, n2), () => a$2.dispatch("POP", e2, n2);
  }, [r2, e2]), i2;
}
let u$1 = /* @__PURE__ */ new Map(), t$3 = /* @__PURE__ */ new Map();
function h$1(r2, l2 = true) {
  l$4(() => {
    var o3;
    if (!l2)
      return;
    let e2 = typeof r2 == "function" ? r2() : r2.current;
    if (!e2)
      return;
    function a2() {
      var d2;
      if (!e2)
        return;
      let i2 = (d2 = t$3.get(e2)) != null ? d2 : 1;
      if (i2 === 1 ? t$3.delete(e2) : t$3.set(e2, i2 - 1), i2 !== 1)
        return;
      let n2 = u$1.get(e2);
      n2 && (n2["aria-hidden"] === null ? e2.removeAttribute("aria-hidden") : e2.setAttribute("aria-hidden", n2["aria-hidden"]), e2.inert = n2.inert, u$1.delete(e2));
    }
    let f2 = (o3 = t$3.get(e2)) != null ? o3 : 0;
    return t$3.set(e2, f2 + 1), f2 !== 0 || (u$1.set(e2, { "aria-hidden": e2.getAttribute("aria-hidden"), inert: e2.inert }), e2.setAttribute("aria-hidden", "true"), e2.inert = true), a2;
  }, [r2, l2]);
}
function j({ defaultContainers: t2 = [], portals: r2, mainTreeNodeRef: u2 } = {}) {
  var c2;
  let o3 = reactExports.useRef((c2 = u2 == null ? void 0 : u2.current) != null ? c2 : null), l2 = n$3(o3), f2 = o$4(() => {
    var i2;
    let n2 = [];
    for (let e2 of t2)
      e2 !== null && (e2 instanceof HTMLElement ? n2.push(e2) : "current" in e2 && e2.current instanceof HTMLElement && n2.push(e2.current));
    if (r2 != null && r2.current)
      for (let e2 of r2.current)
        n2.push(e2);
    for (let e2 of (i2 = l2 == null ? void 0 : l2.querySelectorAll("html > *, body > *")) != null ? i2 : [])
      e2 !== document.body && e2 !== document.head && e2 instanceof HTMLElement && e2.id !== "headlessui-portal-root" && (e2.contains(o3.current) || n2.some((T2) => e2.contains(T2)) || n2.push(e2));
    return n2;
  });
  return { resolveContainers: f2, contains: o$4((n2) => f2().some((i2) => i2.contains(n2))), mainTreeNodeRef: o3, MainTreeNode: reactExports.useMemo(() => function() {
    return u2 != null ? null : React.createElement(c$5, { features: p$2.Hidden, ref: o3 });
  }, [o3, u2]) };
}
function y() {
  let t2 = reactExports.useRef(null);
  return { mainTreeNodeRef: t2, MainTreeNode: reactExports.useMemo(() => function() {
    return React.createElement(c$5, { features: p$2.Hidden, ref: t2 });
  }, [t2]) };
}
var _e$3 = ((o3) => (o3[o3.Open = 0] = "Open", o3[o3.Closed = 1] = "Closed", o3))(_e$3 || {}), Ie$1 = ((e2) => (e2[e2.SetTitleId = 0] = "SetTitleId", e2))(Ie$1 || {});
let Me = { [0](t2, e2) {
  return t2.titleId === e2.id ? t2 : { ...t2, titleId: e2.id };
} }, I = reactExports.createContext(null);
I.displayName = "DialogContext";
function b$1(t2) {
  let e2 = reactExports.useContext(I);
  if (e2 === null) {
    let o3 = new Error(`<${t2} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, b$1), o3;
  }
  return e2;
}
function we$2(t2, e2, o3 = () => [document.body]) {
  p(t2, e2, (i2) => {
    var n2;
    return { containers: [...(n2 = i2.containers) != null ? n2 : [], o3] };
  });
}
function Be(t2, e2) {
  return u$5(e2.type, Me, t2, e2);
}
let He$2 = "div", Ge$2 = S$5.RenderStrategy | S$5.Static;
function Ne$2(t2, e2) {
  var X2;
  let o3 = I$3(), { id: i2 = `headlessui-dialog-${o3}`, open: n2, onClose: l2, initialFocus: s2, __demoMode: g2 = false, ...T2 } = t2, [m2, h2] = reactExports.useState(0), a2 = C();
  n2 === void 0 && a2 !== null && (n2 = (a2 & d$3.Open) === d$3.Open);
  let D2 = reactExports.useRef(null), Q2 = y$3(D2, e2), f2 = n$3(D2), N3 = t2.hasOwnProperty("open") || a2 !== null, U2 = t2.hasOwnProperty("onClose");
  if (!N3 && !U2)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!N3)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!U2)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof n2 != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${n2}`);
  if (typeof l2 != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${l2}`);
  let p2 = n2 ? 0 : 1, [S2, Z2] = reactExports.useReducer(Be, { titleId: null, descriptionId: null, panelRef: reactExports.createRef() }), P$12 = o$4(() => l2(false)), W2 = o$4((r2) => Z2({ type: 0, id: r2 })), L2 = l$3() ? g2 ? false : p2 === 0 : false, F3 = m2 > 1, Y2 = reactExports.useContext(I) !== null, [ee2, te2] = ae$1(), { resolveContainers: M2, mainTreeNodeRef: k2, MainTreeNode: oe2 } = j({ portals: ee2, defaultContainers: [(X2 = S2.panelRef.current) != null ? X2 : D2.current] }), re2 = F3 ? "parent" : "leaf", $2 = a2 !== null ? (a2 & d$3.Closing) === d$3.Closing : false, ne2 = (() => Y2 || $2 ? false : L2)(), le2 = reactExports.useCallback(() => {
    var r2, c2;
    return (c2 = Array.from((r2 = f2 == null ? void 0 : f2.querySelectorAll("body > *")) != null ? r2 : []).find((d2) => d2.id === "headlessui-portal-root" ? false : d2.contains(k2.current) && d2 instanceof HTMLElement)) != null ? c2 : null;
  }, [k2]);
  h$1(le2, ne2);
  let ae2 = (() => F3 ? true : L2)(), ie2 = reactExports.useCallback(() => {
    var r2, c2;
    return (c2 = Array.from((r2 = f2 == null ? void 0 : f2.querySelectorAll("[data-headlessui-portal]")) != null ? r2 : []).find((d2) => d2.contains(k2.current) && d2 instanceof HTMLElement)) != null ? c2 : null;
  }, [k2]);
  h$1(ie2, ae2);
  let se2 = (() => !(!L2 || F3))();
  h$5(M2, P$12, se2);
  let pe$12 = (() => !(F3 || p2 !== 0))();
  E$1(f2 == null ? void 0 : f2.defaultView, "keydown", (r2) => {
    pe$12 && (r2.defaultPrevented || r2.key === o$1.Escape && (r2.preventDefault(), r2.stopPropagation(), P$12()));
  });
  let de2 = (() => !($2 || p2 !== 0 || Y2))();
  we$2(f2, de2, M2), reactExports.useEffect(() => {
    if (p2 !== 0 || !D2.current)
      return;
    let r2 = new ResizeObserver((c2) => {
      for (let d2 of c2) {
        let x2 = d2.target.getBoundingClientRect();
        x2.x === 0 && x2.y === 0 && x2.width === 0 && x2.height === 0 && P$12();
      }
    });
    return r2.observe(D2.current), () => r2.disconnect();
  }, [p2, D2, P$12]);
  let [ue2, fe2] = M$5(), ge$12 = reactExports.useMemo(() => [{ dialogState: p2, close: P$12, setTitleId: W2 }, S2], [p2, S2, P$12, W2]), J2 = reactExports.useMemo(() => ({ open: p2 === 0 }), [p2]), Te2 = { ref: Q2, id: i2, role: "dialog", "aria-modal": p2 === 0 ? true : void 0, "aria-labelledby": S2.titleId, "aria-describedby": ue2 };
  return React.createElement(M$4, { type: "Dialog", enabled: p2 === 0, element: D2, onUpdate: o$4((r2, c2) => {
    c2 === "Dialog" && u$5(r2, { [s$1.Add]: () => h2((d2) => d2 + 1), [s$1.Remove]: () => h2((d2) => d2 - 1) });
  }) }, React.createElement(P, { force: true }, React.createElement(pe, null, React.createElement(I.Provider, { value: ge$12 }, React.createElement(pe.Group, { target: D2 }, React.createElement(P, { force: false }, React.createElement(fe2, { slot: J2, name: "Dialog.Description" }, React.createElement(ge, { initialFocus: s2, containers: M2, features: L2 ? u$5(re2, { parent: ge.features.RestoreFocus, leaf: ge.features.All & ~ge.features.FocusLock }) : ge.features.None }, React.createElement(te2, null, X$1({ ourProps: Te2, theirProps: T2, slot: J2, defaultTag: He$2, features: Ge$2, visible: p2 === 0, name: "Dialog" }))))))))), React.createElement(oe2, null));
}
let Ue$1 = "div";
function We$1(t2, e2) {
  let o3 = I$3(), { id: i2 = `headlessui-dialog-overlay-${o3}`, ...n2 } = t2, [{ dialogState: l2, close: s2 }] = b$1("Dialog.Overlay"), g2 = y$3(e2), T2 = o$4((a2) => {
    if (a2.target === a2.currentTarget) {
      if (r$2(a2.currentTarget))
        return a2.preventDefault();
      a2.preventDefault(), a2.stopPropagation(), s2();
    }
  }), m2 = reactExports.useMemo(() => ({ open: l2 === 0 }), [l2]);
  return X$1({ ourProps: { ref: g2, id: i2, "aria-hidden": true, onClick: T2 }, theirProps: n2, slot: m2, defaultTag: Ue$1, name: "Dialog.Overlay" });
}
let Ye$1 = "div";
function $e$1(t2, e2) {
  let o3 = I$3(), { id: i2 = `headlessui-dialog-backdrop-${o3}`, ...n2 } = t2, [{ dialogState: l2 }, s2] = b$1("Dialog.Backdrop"), g2 = y$3(e2);
  reactExports.useEffect(() => {
    if (s2.panelRef.current === null)
      throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [s2.panelRef]);
  let T2 = reactExports.useMemo(() => ({ open: l2 === 0 }), [l2]);
  return React.createElement(P, { force: true }, React.createElement(pe, null, X$1({ ourProps: { ref: g2, id: i2, "aria-hidden": true }, theirProps: n2, slot: T2, defaultTag: Ye$1, name: "Dialog.Backdrop" })));
}
let Je$1 = "div";
function Xe$2(t2, e2) {
  let o3 = I$3(), { id: i2 = `headlessui-dialog-panel-${o3}`, ...n2 } = t2, [{ dialogState: l2 }, s2] = b$1("Dialog.Panel"), g2 = y$3(e2, s2.panelRef), T2 = reactExports.useMemo(() => ({ open: l2 === 0 }), [l2]), m2 = o$4((a2) => {
    a2.stopPropagation();
  });
  return X$1({ ourProps: { ref: g2, id: i2, onClick: m2 }, theirProps: n2, slot: T2, defaultTag: Je$1, name: "Dialog.Panel" });
}
let je$2 = "h2";
function Ke$2(t2, e2) {
  let o3 = I$3(), { id: i2 = `headlessui-dialog-title-${o3}`, ...n2 } = t2, [{ dialogState: l2, setTitleId: s2 }] = b$1("Dialog.Title"), g2 = y$3(e2);
  reactExports.useEffect(() => (s2(i2), () => s2(null)), [i2, s2]);
  let T2 = reactExports.useMemo(() => ({ open: l2 === 0 }), [l2]);
  return X$1({ ourProps: { ref: g2, id: i2 }, theirProps: n2, slot: T2, defaultTag: je$2, name: "Dialog.Title" });
}
let Ve$1 = D$2(Ne$2), qe$1 = D$2($e$1), ze$1 = D$2(Xe$2), Qe$1 = D$2(We$1), Ze$1 = D$2(Ke$2), _t = Object.assign(Ve$1, { Backdrop: qe$1, Panel: ze$1, Overlay: Qe$1, Title: Ze$1, Description: b$2 });
var t$2;
let a$1 = (t$2 = React.startTransition) != null ? t$2 : function(i2) {
  i2();
};
var q = ((o3) => (o3[o3.Open = 0] = "Open", o3[o3.Closed = 1] = "Closed", o3))(q || {}), z$1 = ((t2) => (t2[t2.ToggleDisclosure = 0] = "ToggleDisclosure", t2[t2.CloseDisclosure = 1] = "CloseDisclosure", t2[t2.SetButtonId = 2] = "SetButtonId", t2[t2.SetPanelId = 3] = "SetPanelId", t2[t2.LinkPanel = 4] = "LinkPanel", t2[t2.UnlinkPanel = 5] = "UnlinkPanel", t2))(z$1 || {});
let Q = { [0]: (e2) => ({ ...e2, disclosureState: u$5(e2.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e2) => e2.disclosureState === 1 ? e2 : { ...e2, disclosureState: 1 }, [4](e2) {
  return e2.linkedPanel === true ? e2 : { ...e2, linkedPanel: true };
}, [5](e2) {
  return e2.linkedPanel === false ? e2 : { ...e2, linkedPanel: false };
}, [2](e2, n2) {
  return e2.buttonId === n2.buttonId ? e2 : { ...e2, buttonId: n2.buttonId };
}, [3](e2, n2) {
  return e2.panelId === n2.panelId ? e2 : { ...e2, panelId: n2.panelId };
} }, k = reactExports.createContext(null);
k.displayName = "DisclosureContext";
function M$3(e2) {
  let n2 = reactExports.useContext(k);
  if (n2 === null) {
    let o3 = new Error(`<${e2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, M$3), o3;
  }
  return n2;
}
let v$2 = reactExports.createContext(null);
v$2.displayName = "DisclosureAPIContext";
function w$1(e2) {
  let n2 = reactExports.useContext(v$2);
  if (n2 === null) {
    let o3 = new Error(`<${e2} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, w$1), o3;
  }
  return n2;
}
let H$1 = reactExports.createContext(null);
H$1.displayName = "DisclosurePanelContext";
function V() {
  return reactExports.useContext(H$1);
}
function Y(e2, n2) {
  return u$5(n2.type, Q, e2, n2);
}
let Z = reactExports.Fragment;
function ee(e2, n2) {
  let { defaultOpen: o3 = false, ...u2 } = e2, T2 = reactExports.useRef(null), l2 = y$3(n2, T$2((a2) => {
    T2.current = a2;
  }, e2.as === void 0 || e2.as === reactExports.Fragment)), t2 = reactExports.useRef(null), f2 = reactExports.useRef(null), s2 = reactExports.useReducer(Y, { disclosureState: o3 ? 0 : 1, linkedPanel: false, buttonRef: f2, panelRef: t2, buttonId: null, panelId: null }), [{ disclosureState: i2, buttonId: c2 }, D2] = s2, d2 = o$4((a2) => {
    D2({ type: 1 });
    let r2 = e$2(T2);
    if (!r2 || !c2)
      return;
    let p2 = (() => a2 ? a2 instanceof HTMLElement ? a2 : a2.current instanceof HTMLElement ? a2.current : r2.getElementById(c2) : r2.getElementById(c2))();
    p2 == null || p2.focus();
  }), P2 = reactExports.useMemo(() => ({ close: d2 }), [d2]), b2 = reactExports.useMemo(() => ({ open: i2 === 0, close: d2 }), [i2, d2]), y2 = { ref: l2 };
  return React.createElement(k.Provider, { value: s2 }, React.createElement(v$2.Provider, { value: P2 }, React.createElement(c$4, { value: u$5(i2, { [0]: d$3.Open, [1]: d$3.Closed }) }, X$1({ ourProps: y2, theirProps: u2, slot: b2, defaultTag: Z, name: "Disclosure" }))));
}
let te = "button";
function ne$1(e2, n2) {
  let o3 = I$3(), { id: u2 = `headlessui-disclosure-button-${o3}`, ...T2 } = e2, [l2, t2] = M$3("Disclosure.Button"), f2 = V(), s2 = f2 === null ? false : f2 === l2.panelId, i2 = reactExports.useRef(null), c2 = y$3(i2, n2, s2 ? null : l2.buttonRef);
  reactExports.useEffect(() => {
    if (!s2)
      return t2({ type: 2, buttonId: u2 }), () => {
        t2({ type: 2, buttonId: null });
      };
  }, [u2, t2, s2]);
  let D2 = o$4((r2) => {
    var p2;
    if (s2) {
      if (l2.disclosureState === 1)
        return;
      switch (r2.key) {
        case o$1.Space:
        case o$1.Enter:
          r2.preventDefault(), r2.stopPropagation(), t2({ type: 0 }), (p2 = l2.buttonRef.current) == null || p2.focus();
          break;
      }
    } else
      switch (r2.key) {
        case o$1.Space:
        case o$1.Enter:
          r2.preventDefault(), r2.stopPropagation(), t2({ type: 0 });
          break;
      }
  }), d2 = o$4((r2) => {
    switch (r2.key) {
      case o$1.Space:
        r2.preventDefault();
        break;
    }
  }), P2 = o$4((r2) => {
    var p2;
    r$2(r2.currentTarget) || e2.disabled || (s2 ? (t2({ type: 0 }), (p2 = l2.buttonRef.current) == null || p2.focus()) : t2({ type: 0 }));
  }), b2 = reactExports.useMemo(() => ({ open: l2.disclosureState === 0 }), [l2]), y2 = s$4(e2, i2), a2 = s2 ? { ref: c2, type: y2, onKeyDown: D2, onClick: P2 } : { ref: c2, id: u2, type: y2, "aria-expanded": l2.disclosureState === 0, "aria-controls": l2.linkedPanel ? l2.panelId : void 0, onKeyDown: D2, onKeyUp: d2, onClick: P2 };
  return X$1({ ourProps: a2, theirProps: T2, slot: b2, defaultTag: te, name: "Disclosure.Button" });
}
let le$1 = "div", oe$3 = S$5.RenderStrategy | S$5.Static;
function re$1(e2, n2) {
  let o3 = I$3(), { id: u2 = `headlessui-disclosure-panel-${o3}`, ...T2 } = e2, [l2, t2] = M$3("Disclosure.Panel"), { close: f2 } = w$1("Disclosure.Panel"), s2 = y$3(n2, l2.panelRef, (P2) => {
    a$1(() => t2({ type: P2 ? 4 : 5 }));
  });
  reactExports.useEffect(() => (t2({ type: 3, panelId: u2 }), () => {
    t2({ type: 3, panelId: null });
  }), [u2, t2]);
  let i2 = C(), c2 = (() => i2 !== null ? (i2 & d$3.Open) === d$3.Open : l2.disclosureState === 0)(), D2 = reactExports.useMemo(() => ({ open: l2.disclosureState === 0, close: f2 }), [l2, f2]), d2 = { ref: s2, id: u2 };
  return React.createElement(H$1.Provider, { value: l2.panelId }, X$1({ ourProps: d2, theirProps: T2, slot: D2, defaultTag: le$1, features: oe$3, visible: c2, name: "Disclosure.Panel" }));
}
let se$1 = D$2(ee), ue$1 = D$2(ne$1), ie$2 = D$2(re$1), ve = Object.assign(se$1, { Button: ue$1, Panel: ie$2 });
var he$1 = ((u2) => (u2[u2.Open = 0] = "Open", u2[u2.Closed = 1] = "Closed", u2))(he$1 || {}), He$1 = ((e2) => (e2[e2.TogglePopover = 0] = "TogglePopover", e2[e2.ClosePopover = 1] = "ClosePopover", e2[e2.SetButton = 2] = "SetButton", e2[e2.SetButtonId = 3] = "SetButtonId", e2[e2.SetPanel = 4] = "SetPanel", e2[e2.SetPanelId = 5] = "SetPanelId", e2))(He$1 || {});
let _e$2 = { [0]: (t2) => {
  let o3 = { ...t2, popoverState: u$5(t2.popoverState, { [0]: 1, [1]: 0 }) };
  return o3.popoverState === 0 && (o3.__demoMode = false), o3;
}, [1](t2) {
  return t2.popoverState === 1 ? t2 : { ...t2, popoverState: 1 };
}, [2](t2, o3) {
  return t2.button === o3.button ? t2 : { ...t2, button: o3.button };
}, [3](t2, o3) {
  return t2.buttonId === o3.buttonId ? t2 : { ...t2, buttonId: o3.buttonId };
}, [4](t2, o3) {
  return t2.panel === o3.panel ? t2 : { ...t2, panel: o3.panel };
}, [5](t2, o3) {
  return t2.panelId === o3.panelId ? t2 : { ...t2, panelId: o3.panelId };
} }, ue = reactExports.createContext(null);
ue.displayName = "PopoverContext";
function oe$2(t2) {
  let o3 = reactExports.useContext(ue);
  if (o3 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, oe$2), u2;
  }
  return o3;
}
let ie$1 = reactExports.createContext(null);
ie$1.displayName = "PopoverAPIContext";
function fe(t2) {
  let o3 = reactExports.useContext(ie$1);
  if (o3 === null) {
    let u2 = new Error(`<${t2} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(u2, fe), u2;
  }
  return o3;
}
let Pe$2 = reactExports.createContext(null);
Pe$2.displayName = "PopoverGroupContext";
function Ee() {
  return reactExports.useContext(Pe$2);
}
let re = reactExports.createContext(null);
re.displayName = "PopoverPanelContext";
function Ge$1() {
  return reactExports.useContext(re);
}
function Ne$1(t2, o3) {
  return u$5(o3.type, _e$2, t2, o3);
}
let ke$1 = "div";
function we$1(t2, o3) {
  var D2;
  let { __demoMode: u2 = false, ...R2 } = t2, O2 = reactExports.useRef(null), n2 = y$3(o3, T$2((l2) => {
    O2.current = l2;
  })), e2 = reactExports.useRef([]), v2 = reactExports.useReducer(Ne$1, { __demoMode: u2, popoverState: u2 ? 0 : 1, buttons: e2, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: reactExports.createRef(), afterPanelSentinel: reactExports.createRef() }), [{ popoverState: P2, button: s2, buttonId: I2, panel: p2, panelId: T2, beforePanelSentinel: m2, afterPanelSentinel: S2 }, i2] = v2, a2 = n$3((D2 = O2.current) != null ? D2 : s2), E2 = reactExports.useMemo(() => {
    if (!s2 || !p2)
      return false;
    for (let K2 of document.querySelectorAll("body > *"))
      if (Number(K2 == null ? void 0 : K2.contains(s2)) ^ Number(K2 == null ? void 0 : K2.contains(p2)))
        return true;
    let l2 = f$6(), F3 = l2.indexOf(s2), q2 = (F3 + l2.length - 1) % l2.length, W2 = (F3 + 1) % l2.length, z2 = l2[q2], be2 = l2[W2];
    return !p2.contains(z2) && !p2.contains(be2);
  }, [s2, p2]), C3 = s$7(I2), H2 = s$7(T2), x2 = reactExports.useMemo(() => ({ buttonId: C3, panelId: H2, close: () => i2({ type: 1 }) }), [C3, H2, i2]), M2 = Ee(), h2 = M2 == null ? void 0 : M2.registerPopover, f2 = o$4(() => {
    var l2;
    return (l2 = M2 == null ? void 0 : M2.isFocusWithinPopoverGroup()) != null ? l2 : (a2 == null ? void 0 : a2.activeElement) && ((s2 == null ? void 0 : s2.contains(a2.activeElement)) || (p2 == null ? void 0 : p2.contains(a2.activeElement)));
  });
  reactExports.useEffect(() => h2 == null ? void 0 : h2(x2), [h2, x2]);
  let [y2, b2] = ae$1(), d2 = j({ mainTreeNodeRef: M2 == null ? void 0 : M2.mainTreeNodeRef, portals: y2, defaultContainers: [s2, p2] });
  E$1(a2 == null ? void 0 : a2.defaultView, "focus", (l2) => {
    var F3, q2, W2, z2;
    l2.target !== window && l2.target instanceof HTMLElement && P2 === 0 && (f2() || s2 && p2 && (d2.contains(l2.target) || (q2 = (F3 = m2.current) == null ? void 0 : F3.contains) != null && q2.call(F3, l2.target) || (z2 = (W2 = S2.current) == null ? void 0 : W2.contains) != null && z2.call(W2, l2.target) || i2({ type: 1 })));
  }, true), h$5(d2.resolveContainers, (l2, F3) => {
    i2({ type: 1 }), h$6(F3, T$3.Loose) || (l2.preventDefault(), s2 == null || s2.focus());
  }, P2 === 0);
  let L2 = o$4((l2) => {
    i2({ type: 1 });
    let F3 = (() => l2 ? l2 instanceof HTMLElement ? l2 : "current" in l2 && l2.current instanceof HTMLElement ? l2.current : s2 : s2)();
    F3 == null || F3.focus();
  }), r2 = reactExports.useMemo(() => ({ close: L2, isPortalled: E2 }), [L2, E2]), c2 = reactExports.useMemo(() => ({ open: P2 === 0, close: L2 }), [P2, L2]), B2 = { ref: n2 };
  return React.createElement(re.Provider, { value: null }, React.createElement(ue.Provider, { value: v2 }, React.createElement(ie$1.Provider, { value: r2 }, React.createElement(c$4, { value: u$5(P2, { [0]: d$3.Open, [1]: d$3.Closed }) }, React.createElement(b2, null, X$1({ ourProps: B2, theirProps: R2, slot: c2, defaultTag: ke$1, name: "Popover" }), React.createElement(d2.MainTreeNode, null))))));
}
let Ue = "button";
function We(t2, o3) {
  let u2 = I$3(), { id: R2 = `headlessui-popover-button-${u2}`, ...O$12 } = t2, [n2, e2] = oe$2("Popover.Button"), { isPortalled: v2 } = fe("Popover.Button"), P2 = reactExports.useRef(null), s2 = `headlessui-focus-sentinel-${I$3()}`, I2 = Ee(), p2 = I2 == null ? void 0 : I2.closeOthers, m2 = Ge$1() !== null;
  reactExports.useEffect(() => {
    if (!m2)
      return e2({ type: 3, buttonId: R2 }), () => {
        e2({ type: 3, buttonId: null });
      };
  }, [m2, R2, e2]);
  let [S2] = reactExports.useState(() => Symbol()), i2 = y$3(P2, o3, m2 ? null : (r2) => {
    if (r2)
      n2.buttons.current.push(S2);
    else {
      let c2 = n2.buttons.current.indexOf(S2);
      c2 !== -1 && n2.buttons.current.splice(c2, 1);
    }
    n2.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), r2 && e2({ type: 2, button: r2 });
  }), a2 = y$3(P2, o3), E2 = n$3(P2), C3 = o$4((r2) => {
    var c2, B2, D2;
    if (m2) {
      if (n2.popoverState === 1)
        return;
      switch (r2.key) {
        case o$1.Space:
        case o$1.Enter:
          r2.preventDefault(), (B2 = (c2 = r2.target).click) == null || B2.call(c2), e2({ type: 1 }), (D2 = n2.button) == null || D2.focus();
          break;
      }
    } else
      switch (r2.key) {
        case o$1.Space:
        case o$1.Enter:
          r2.preventDefault(), r2.stopPropagation(), n2.popoverState === 1 && (p2 == null || p2(n2.buttonId)), e2({ type: 0 });
          break;
        case o$1.Escape:
          if (n2.popoverState !== 0)
            return p2 == null ? void 0 : p2(n2.buttonId);
          if (!P2.current || E2 != null && E2.activeElement && !P2.current.contains(E2.activeElement))
            return;
          r2.preventDefault(), r2.stopPropagation(), e2({ type: 1 });
          break;
      }
  }), H2 = o$4((r2) => {
    m2 || r2.key === o$1.Space && r2.preventDefault();
  }), x2 = o$4((r2) => {
    var c2, B2;
    r$2(r2.currentTarget) || t2.disabled || (m2 ? (e2({ type: 1 }), (c2 = n2.button) == null || c2.focus()) : (r2.preventDefault(), r2.stopPropagation(), n2.popoverState === 1 && (p2 == null || p2(n2.buttonId)), e2({ type: 0 }), (B2 = n2.button) == null || B2.focus()));
  }), M2 = o$4((r2) => {
    r2.preventDefault(), r2.stopPropagation();
  }), h2 = n2.popoverState === 0, f2 = reactExports.useMemo(() => ({ open: h2 }), [h2]), y2 = s$4(t2, P2), b2 = m2 ? { ref: a2, type: y2, onKeyDown: C3, onClick: x2 } : { ref: i2, id: n2.buttonId, type: y2, "aria-expanded": n2.popoverState === 0, "aria-controls": n2.panel ? n2.panelId : void 0, onKeyDown: C3, onKeyUp: H2, onClick: x2, onMouseDown: M2 }, d2 = n$2(), L2 = o$4(() => {
    let r2 = n2.panel;
    if (!r2)
      return;
    function c2() {
      u$5(d2.current, { [s$2.Forwards]: () => O(r2, M$6.First), [s$2.Backwards]: () => O(r2, M$6.Last) }) === N$2.Error && O(f$6().filter((D2) => D2.dataset.headlessuiFocusGuard !== "true"), u$5(d2.current, { [s$2.Forwards]: M$6.Next, [s$2.Backwards]: M$6.Previous }), { relativeTo: n2.button });
    }
    c2();
  });
  return React.createElement(React.Fragment, null, X$1({ ourProps: b2, theirProps: O$12, slot: f2, defaultTag: Ue, name: "Popover.Button" }), h2 && !m2 && v2 && React.createElement(c$5, { id: s2, features: p$2.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: L2 }));
}
let Ke$1 = "div", je$1 = S$5.RenderStrategy | S$5.Static;
function Ve(t2, o3) {
  let u2 = I$3(), { id: R2 = `headlessui-popover-overlay-${u2}`, ...O2 } = t2, [{ popoverState: n2 }, e2] = oe$2("Popover.Overlay"), v2 = y$3(o3), P2 = C(), s2 = (() => P2 !== null ? (P2 & d$3.Open) === d$3.Open : n2 === 0)(), I2 = o$4((m2) => {
    if (r$2(m2.currentTarget))
      return m2.preventDefault();
    e2({ type: 1 });
  }), p2 = reactExports.useMemo(() => ({ open: n2 === 0 }), [n2]);
  return X$1({ ourProps: { ref: v2, id: R2, "aria-hidden": true, onClick: I2 }, theirProps: O2, slot: p2, defaultTag: Ke$1, features: je$1, visible: s2, name: "Popover.Overlay" });
}
let $e = "div", Je = S$5.RenderStrategy | S$5.Static;
function Xe$1(t2, o3) {
  let u2 = I$3(), { id: R2 = `headlessui-popover-panel-${u2}`, focus: O$12 = false, ...n2 } = t2, [e2, v2] = oe$2("Popover.Panel"), { close: P2, isPortalled: s2 } = fe("Popover.Panel"), I2 = `headlessui-focus-sentinel-before-${I$3()}`, p2 = `headlessui-focus-sentinel-after-${I$3()}`, T2 = reactExports.useRef(null), m2 = y$3(T2, o3, (f2) => {
    v2({ type: 4, panel: f2 });
  }), S2 = n$3(T2);
  l$4(() => (v2({ type: 5, panelId: R2 }), () => {
    v2({ type: 5, panelId: null });
  }), [R2, v2]);
  let i2 = C(), a2 = (() => i2 !== null ? (i2 & d$3.Open) === d$3.Open : e2.popoverState === 0)(), E2 = o$4((f2) => {
    var y2;
    switch (f2.key) {
      case o$1.Escape:
        if (e2.popoverState !== 0 || !T2.current || S2 != null && S2.activeElement && !T2.current.contains(S2.activeElement))
          return;
        f2.preventDefault(), f2.stopPropagation(), v2({ type: 1 }), (y2 = e2.button) == null || y2.focus();
        break;
    }
  });
  reactExports.useEffect(() => {
    var f2;
    t2.static || e2.popoverState === 1 && ((f2 = t2.unmount) == null || f2) && v2({ type: 4, panel: null });
  }, [e2.popoverState, t2.unmount, t2.static, v2]), reactExports.useEffect(() => {
    if (e2.__demoMode || !O$12 || e2.popoverState !== 0 || !T2.current)
      return;
    let f2 = S2 == null ? void 0 : S2.activeElement;
    T2.current.contains(f2) || O(T2.current, M$6.First);
  }, [e2.__demoMode, O$12, T2, e2.popoverState]);
  let C$12 = reactExports.useMemo(() => ({ open: e2.popoverState === 0, close: P2 }), [e2, P2]), H2 = { ref: m2, id: R2, onKeyDown: E2, onBlur: O$12 && e2.popoverState === 0 ? (f2) => {
    var b2, d2, L2, r2, c2;
    let y2 = f2.relatedTarget;
    y2 && T2.current && ((b2 = T2.current) != null && b2.contains(y2) || (v2({ type: 1 }), ((L2 = (d2 = e2.beforePanelSentinel.current) == null ? void 0 : d2.contains) != null && L2.call(d2, y2) || (c2 = (r2 = e2.afterPanelSentinel.current) == null ? void 0 : r2.contains) != null && c2.call(r2, y2)) && y2.focus({ preventScroll: true })));
  } : void 0, tabIndex: -1 }, x2 = n$2(), M2 = o$4(() => {
    let f2 = T2.current;
    if (!f2)
      return;
    function y2() {
      u$5(x2.current, { [s$2.Forwards]: () => {
        var d2;
        O(f2, M$6.First) === N$2.Error && ((d2 = e2.afterPanelSentinel.current) == null || d2.focus());
      }, [s$2.Backwards]: () => {
        var b2;
        (b2 = e2.button) == null || b2.focus({ preventScroll: true });
      } });
    }
    y2();
  }), h2 = o$4(() => {
    let f2 = T2.current;
    if (!f2)
      return;
    function y2() {
      u$5(x2.current, { [s$2.Forwards]: () => {
        var B2;
        if (!e2.button)
          return;
        let b2 = f$6(), d2 = b2.indexOf(e2.button), L2 = b2.slice(0, d2 + 1), c2 = [...b2.slice(d2 + 1), ...L2];
        for (let D2 of c2.slice())
          if (D2.dataset.headlessuiFocusGuard === "true" || (B2 = e2.panel) != null && B2.contains(D2)) {
            let l2 = c2.indexOf(D2);
            l2 !== -1 && c2.splice(l2, 1);
          }
        O(c2, M$6.First, { sorted: false });
      }, [s$2.Backwards]: () => {
        var d2;
        O(f2, M$6.Previous) === N$2.Error && ((d2 = e2.button) == null || d2.focus());
      } });
    }
    y2();
  });
  return React.createElement(re.Provider, { value: R2 }, a2 && s2 && React.createElement(c$5, { id: I2, ref: e2.beforePanelSentinel, features: p$2.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: M2 }), X$1({ ourProps: H2, theirProps: n2, slot: C$12, defaultTag: $e, features: Je, visible: a2, name: "Popover.Panel" }), a2 && s2 && React.createElement(c$5, { id: p2, ref: e2.afterPanelSentinel, features: p$2.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: h2 }));
}
let Ye = "div";
function qe(t2, o3) {
  let u2 = reactExports.useRef(null), R2 = y$3(u2, o3), [O2, n2] = reactExports.useState([]), e2 = y(), v2 = o$4((i2) => {
    n2((a2) => {
      let E2 = a2.indexOf(i2);
      if (E2 !== -1) {
        let C3 = a2.slice();
        return C3.splice(E2, 1), C3;
      }
      return a2;
    });
  }), P2 = o$4((i2) => (n2((a2) => [...a2, i2]), () => v2(i2))), s2 = o$4(() => {
    var E2;
    let i2 = e$2(u2);
    if (!i2)
      return false;
    let a2 = i2.activeElement;
    return (E2 = u2.current) != null && E2.contains(a2) ? true : O2.some((C3) => {
      var H2, x2;
      return ((H2 = i2.getElementById(C3.buttonId.current)) == null ? void 0 : H2.contains(a2)) || ((x2 = i2.getElementById(C3.panelId.current)) == null ? void 0 : x2.contains(a2));
    });
  }), I2 = o$4((i2) => {
    for (let a2 of O2)
      a2.buttonId.current !== i2 && a2.close();
  }), p2 = reactExports.useMemo(() => ({ registerPopover: P2, unregisterPopover: v2, isFocusWithinPopoverGroup: s2, closeOthers: I2, mainTreeNodeRef: e2.mainTreeNodeRef }), [P2, v2, s2, I2, e2.mainTreeNodeRef]), T2 = reactExports.useMemo(() => ({}), []), m2 = t2, S2 = { ref: R2 };
  return React.createElement(Pe$2.Provider, { value: p2 }, X$1({ ourProps: S2, theirProps: m2, slot: T2, defaultTag: Ye, name: "Popover.Group" }), React.createElement(e2.MainTreeNode, null));
}
let ze = D$2(we$1), Qe = D$2(We), Ze = D$2(Ve), et$1 = D$2(Xe$1), tt$2 = D$2(qe), kt = Object.assign(ze, { Button: Qe, Overlay: Ze, Panel: et$1, Group: tt$2 });
function c(a2 = 0) {
  let [l2, r2] = reactExports.useState(a2), t2 = f$3(), o3 = reactExports.useCallback((e2) => {
    t2.current && r2((u2) => u2 | e2);
  }, [l2, t2]), m2 = reactExports.useCallback((e2) => Boolean(l2 & e2), [l2]), s2 = reactExports.useCallback((e2) => {
    t2.current && r2((u2) => u2 & ~e2);
  }, [r2, t2]), g2 = reactExports.useCallback((e2) => {
    t2.current && r2((u2) => u2 ^ e2);
  }, [r2]);
  return { flags: l2, addFlag: o3, hasFlag: m2, removeFlag: s2, toggleFlag: g2 };
}
let d = reactExports.createContext(null);
function u() {
  let o3 = reactExports.useContext(d);
  if (o3 === null) {
    let t2 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t2, u), t2;
  }
  return o3;
}
function H() {
  let [o3, t2] = reactExports.useState([]);
  return [o3.length > 0 ? o3.join(" ") : void 0, reactExports.useMemo(() => function(e2) {
    let s2 = o$4((r2) => (t2((l2) => [...l2, r2]), () => t2((l2) => {
      let n2 = l2.slice(), p2 = n2.indexOf(r2);
      return p2 !== -1 && n2.splice(p2, 1), n2;
    }))), a2 = reactExports.useMemo(() => ({ register: s2, slot: e2.slot, name: e2.name, props: e2.props }), [s2, e2.slot, e2.name, e2.props]);
    return React.createElement(d.Provider, { value: a2 }, e2.children);
  }, [t2])];
}
let A = "label";
function h(o3, t2) {
  let i2 = I$3(), { id: e2 = `headlessui-label-${i2}`, passive: s2 = false, ...a2 } = o3, r2 = u(), l2 = y$3(t2);
  l$4(() => r2.register(e2), [e2, r2.register]);
  let n2 = { ref: l2, ...r2.props, id: e2 };
  return s2 && ("onClick" in n2 && (delete n2.htmlFor, delete n2.onClick), "onClick" in a2 && delete a2.onClick), X$1({ ourProps: n2, theirProps: a2, slot: r2.slot || {}, defaultTag: A, name: r2.name || "Label" });
}
let v$1 = D$2(h), M$2 = Object.assign(v$1, {});
var Ce = ((t2) => (t2[t2.RegisterOption = 0] = "RegisterOption", t2[t2.UnregisterOption = 1] = "UnregisterOption", t2))(Ce || {});
let ke = { [0](r2, o3) {
  let t2 = [...r2.options, { id: o3.id, element: o3.element, propsRef: o3.propsRef }];
  return { ...r2, options: I$2(t2, (p2) => p2.element.current) };
}, [1](r2, o3) {
  let t2 = r2.options.slice(), p2 = r2.options.findIndex((T2) => T2.id === o3.id);
  return p2 === -1 ? r2 : (t2.splice(p2, 1), { ...r2, options: t2 });
} }, B = reactExports.createContext(null);
B.displayName = "RadioGroupDataContext";
function oe$1(r2) {
  let o3 = reactExports.useContext(B);
  if (o3 === null) {
    let t2 = new Error(`<${r2} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t2, oe$1), t2;
  }
  return o3;
}
let $ = reactExports.createContext(null);
$.displayName = "RadioGroupActionsContext";
function ne(r2) {
  let o3 = reactExports.useContext($);
  if (o3 === null) {
    let t2 = new Error(`<${r2} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t2, ne), t2;
  }
  return o3;
}
function Le$1(r2, o3) {
  return u$5(o3.type, ke, r2, o3);
}
let he = "div";
function Fe$1(r2, o3) {
  let t2 = I$3(), { id: p2 = `headlessui-radiogroup-${t2}`, value: T2, defaultValue: v2, form: S2, name: m2, onChange: M2, by: G2 = (e2, i2) => e2 === i2, disabled: C3 = false, ...H$12 } = r2, y2 = o$4(typeof G2 == "string" ? (e2, i2) => {
    let n2 = G2;
    return (e2 == null ? void 0 : e2[n2]) === (i2 == null ? void 0 : i2[n2]);
  } : G2), [P2, h2] = reactExports.useReducer(Le$1, { options: [] }), a2 = P2.options, [N3, R$12] = H(), [k2, U2] = M$5(), L2 = reactExports.useRef(null), W2 = y$3(L2, o3), [l2, s2] = T$1(T2, M2, v2), b2 = reactExports.useMemo(() => a2.find((e2) => !e2.propsRef.current.disabled), [a2]), F3 = reactExports.useMemo(() => a2.some((e2) => y2(e2.propsRef.current.value, l2)), [a2, l2]), d2 = o$4((e2) => {
    var n2;
    if (C3 || y2(e2, l2))
      return false;
    let i2 = (n2 = a2.find((f2) => y2(f2.propsRef.current.value, e2))) == null ? void 0 : n2.propsRef.current;
    return i2 != null && i2.disabled ? false : (s2 == null || s2(e2), true);
  });
  F$1({ container: L2.current, accept(e2) {
    return e2.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : e2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(e2) {
    e2.setAttribute("role", "none");
  } });
  let x2 = o$4((e2) => {
    let i2 = L2.current;
    if (!i2)
      return;
    let n2 = e$2(i2), f2 = a2.filter((u2) => u2.propsRef.current.disabled === false).map((u2) => u2.element.current);
    switch (e2.key) {
      case o$1.Enter:
        p$3(e2.currentTarget);
        break;
      case o$1.ArrowLeft:
      case o$1.ArrowUp:
        if (e2.preventDefault(), e2.stopPropagation(), O(f2, M$6.Previous | M$6.WrapAround) === N$2.Success) {
          let g2 = a2.find((K2) => K2.element.current === (n2 == null ? void 0 : n2.activeElement));
          g2 && d2(g2.propsRef.current.value);
        }
        break;
      case o$1.ArrowRight:
      case o$1.ArrowDown:
        if (e2.preventDefault(), e2.stopPropagation(), O(f2, M$6.Next | M$6.WrapAround) === N$2.Success) {
          let g2 = a2.find((K2) => K2.element.current === (n2 == null ? void 0 : n2.activeElement));
          g2 && d2(g2.propsRef.current.value);
        }
        break;
      case o$1.Space:
        {
          e2.preventDefault(), e2.stopPropagation();
          let u2 = a2.find((g2) => g2.element.current === (n2 == null ? void 0 : n2.activeElement));
          u2 && d2(u2.propsRef.current.value);
        }
        break;
    }
  }), c2 = o$4((e2) => (h2({ type: 0, ...e2 }), () => h2({ type: 1, id: e2.id }))), _2 = reactExports.useMemo(() => ({ value: l2, firstOption: b2, containsCheckedOption: F3, disabled: C3, compare: y2, ...P2 }), [l2, b2, F3, C3, y2, P2]), ie2 = reactExports.useMemo(() => ({ registerOption: c2, change: d2 }), [c2, d2]), ae2 = { ref: W2, id: p2, role: "radiogroup", "aria-labelledby": N3, "aria-describedby": k2, onKeyDown: x2 }, pe2 = reactExports.useMemo(() => ({ value: l2 }), [l2]), w2 = reactExports.useRef(null), le2 = p$4();
  return reactExports.useEffect(() => {
    w2.current && v2 !== void 0 && le2.addEventListener(w2.current, "reset", () => {
      d2(v2);
    });
  }, [w2, d2]), React.createElement(U2, { name: "RadioGroup.Description" }, React.createElement(R$12, { name: "RadioGroup.Label" }, React.createElement($.Provider, { value: ie2 }, React.createElement(B.Provider, { value: _2 }, m2 != null && l2 != null && e$1({ [m2]: l2 }).map(([e2, i2], n2) => React.createElement(c$5, { features: p$2.Hidden, ref: n2 === 0 ? (f2) => {
    var u2;
    w2.current = (u2 = f2 == null ? void 0 : f2.closest("form")) != null ? u2 : null;
  } : void 0, ...R({ key: e2, as: "input", type: "radio", checked: i2 != null, hidden: true, readOnly: true, form: S2, name: e2, value: i2 }) })), X$1({ ourProps: ae2, theirProps: H$12, slot: pe2, defaultTag: he, name: "RadioGroup" })))));
}
var xe$1 = ((t2) => (t2[t2.Empty = 1] = "Empty", t2[t2.Active = 2] = "Active", t2))(xe$1 || {});
let _e$1 = "div";
function we(r2, o3) {
  var x2;
  let t2 = I$3(), { id: p2 = `headlessui-radiogroup-option-${t2}`, value: T2, disabled: v2 = false, ...S2 } = r2, m2 = reactExports.useRef(null), M2 = y$3(m2, o3), [G2, C3] = H(), [H$12, y2] = M$5(), { addFlag: P2, removeFlag: h2, hasFlag: a2 } = c(1), N3 = s$7({ value: T2, disabled: v2 }), R2 = oe$1("RadioGroup.Option"), k2 = ne("RadioGroup.Option");
  l$4(() => k2.registerOption({ id: p2, element: m2, propsRef: N3 }), [p2, k2, m2, r2]);
  let U2 = o$4((c2) => {
    var _2;
    if (r$2(c2.currentTarget))
      return c2.preventDefault();
    k2.change(T2) && (P2(2), (_2 = m2.current) == null || _2.focus());
  }), L2 = o$4((c2) => {
    if (r$2(c2.currentTarget))
      return c2.preventDefault();
    P2(2);
  }), W2 = o$4(() => h2(2)), l2 = ((x2 = R2.firstOption) == null ? void 0 : x2.id) === p2, s2 = R2.disabled || v2, b2 = R2.compare(R2.value, T2), F3 = { ref: M2, id: p2, role: "radio", "aria-checked": b2 ? "true" : "false", "aria-labelledby": G2, "aria-describedby": H$12, "aria-disabled": s2 ? true : void 0, tabIndex: (() => s2 ? -1 : b2 || !R2.containsCheckedOption && l2 ? 0 : -1)(), onClick: s2 ? void 0 : U2, onFocus: s2 ? void 0 : L2, onBlur: s2 ? void 0 : W2 }, d2 = reactExports.useMemo(() => ({ checked: b2, disabled: s2, active: a2(2) }), [b2, s2, a2]);
  return React.createElement(y2, { name: "RadioGroup.Description" }, React.createElement(C3, { name: "RadioGroup.Label" }, X$1({ ourProps: F3, theirProps: S2, slot: d2, defaultTag: _e$1, name: "RadioGroup.Option" })));
}
let Ie = D$2(Fe$1), Se$2 = D$2(we), yt = Object.assign(Ie, { Option: Se$2, Label: M$2, Description: b$2 });
function l(r2) {
  let e2 = { called: false };
  return (...t2) => {
    if (!e2.called)
      return e2.called = true, r2(...t2);
  };
}
function g(t2, ...e2) {
  t2 && e2.length > 0 && t2.classList.add(...e2);
}
function v(t2, ...e2) {
  t2 && e2.length > 0 && t2.classList.remove(...e2);
}
function b(t2, e2) {
  let n2 = o$5();
  if (!t2)
    return n2.dispose;
  let { transitionDuration: m2, transitionDelay: a2 } = getComputedStyle(t2), [u2, p2] = [m2, a2].map((l2) => {
    let [r2 = 0] = l2.split(",").filter(Boolean).map((i2) => i2.includes("ms") ? parseFloat(i2) : parseFloat(i2) * 1e3).sort((i2, T2) => T2 - i2);
    return r2;
  }), o3 = u2 + p2;
  if (o3 !== 0) {
    n2.group((r2) => {
      r2.setTimeout(() => {
        e2(), r2.dispose();
      }, o3), r2.addEventListener(t2, "transitionrun", (i2) => {
        i2.target === i2.currentTarget && r2.dispose();
      });
    });
    let l2 = n2.addEventListener(t2, "transitionend", (r2) => {
      r2.target === r2.currentTarget && (e2(), l2());
    });
  } else
    e2();
  return n2.add(() => e2()), n2.dispose;
}
function M$1(t2, e2, n2, m2) {
  let a2 = n2 ? "enter" : "leave", u2 = o$5(), p2 = m2 !== void 0 ? l(m2) : () => {
  };
  a2 === "enter" && (t2.removeAttribute("hidden"), t2.style.display = "");
  let o3 = u$5(a2, { enter: () => e2.enter, leave: () => e2.leave }), l$12 = u$5(a2, { enter: () => e2.enterTo, leave: () => e2.leaveTo }), r2 = u$5(a2, { enter: () => e2.enterFrom, leave: () => e2.leaveFrom });
  return v(t2, ...e2.base, ...e2.enter, ...e2.enterTo, ...e2.enterFrom, ...e2.leave, ...e2.leaveFrom, ...e2.leaveTo, ...e2.entered), g(t2, ...e2.base, ...o3, ...r2), u2.nextFrame(() => {
    v(t2, ...e2.base, ...o3, ...r2), g(t2, ...e2.base, ...o3, ...l$12), b(t2, () => (v(t2, ...e2.base, ...o3), g(t2, ...e2.base, ...e2.entered), p2()));
  }), u2.dispose;
}
function E({ immediate: t2, container: s2, direction: n2, classes: u2, onStart: a2, onStop: c2 }) {
  let l2 = f$3(), d2 = p$4(), e2 = s$7(n2);
  l$4(() => {
    t2 && (e2.current = "enter");
  }, [t2]), l$4(() => {
    let r2 = o$5();
    d2.add(r2.dispose);
    let i2 = s2.current;
    if (i2 && e2.current !== "idle" && l2.current)
      return r2.dispose(), a2.current(e2.current), r2.add(M$1(i2, u2.current, e2.current === "enter", () => {
        r2.dispose(), c2.current(e2.current);
      })), r2.dispose;
  }, [n2]);
}
function S(t2 = "") {
  return t2.split(" ").filter((n2) => n2.trim().length > 1);
}
let _ = reactExports.createContext(null);
_.displayName = "TransitionContext";
var be = ((r2) => (r2.Visible = "visible", r2.Hidden = "hidden", r2))(be || {});
function Se$1() {
  let t2 = reactExports.useContext(_);
  if (t2 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t2;
}
function Ne() {
  let t2 = reactExports.useContext(M);
  if (t2 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return t2;
}
let M = reactExports.createContext(null);
M.displayName = "NestingContext";
function U(t2) {
  return "children" in t2 ? U(t2.children) : t2.current.filter(({ el: n2 }) => n2.current !== null).filter(({ state: n2 }) => n2 === "visible").length > 0;
}
function oe(t2, n2) {
  let r2 = s$7(t2), s2 = reactExports.useRef([]), y2 = f$3(), D2 = p$4(), c2 = o$4((i2, e2 = j$2.Hidden) => {
    let a2 = s2.current.findIndex(({ el: o3 }) => o3 === i2);
    a2 !== -1 && (u$5(e2, { [j$2.Unmount]() {
      s2.current.splice(a2, 1);
    }, [j$2.Hidden]() {
      s2.current[a2].state = "hidden";
    } }), D2.microTask(() => {
      var o3;
      !U(s2) && y2.current && ((o3 = r2.current) == null || o3.call(r2));
    }));
  }), x2 = o$4((i2) => {
    let e2 = s2.current.find(({ el: a2 }) => a2 === i2);
    return e2 ? e2.state !== "visible" && (e2.state = "visible") : s2.current.push({ el: i2, state: "visible" }), () => c2(i2, j$2.Unmount);
  }), p2 = reactExports.useRef([]), h2 = reactExports.useRef(Promise.resolve()), u2 = reactExports.useRef({ enter: [], leave: [], idle: [] }), v2 = o$4((i2, e2, a2) => {
    p2.current.splice(0), n2 && (n2.chains.current[e2] = n2.chains.current[e2].filter(([o3]) => o3 !== i2)), n2 == null || n2.chains.current[e2].push([i2, new Promise((o3) => {
      p2.current.push(o3);
    })]), n2 == null || n2.chains.current[e2].push([i2, new Promise((o3) => {
      Promise.all(u2.current[e2].map(([f2, P2]) => P2)).then(() => o3());
    })]), e2 === "enter" ? h2.current = h2.current.then(() => n2 == null ? void 0 : n2.wait.current).then(() => a2(e2)) : a2(e2);
  }), d2 = o$4((i2, e2, a2) => {
    Promise.all(u2.current[e2].splice(0).map(([o3, f2]) => f2)).then(() => {
      var o3;
      (o3 = p2.current.shift()) == null || o3();
    }).then(() => a2(e2));
  });
  return reactExports.useMemo(() => ({ children: s2, register: x2, unregister: c2, onStart: v2, onStop: d2, wait: h2, chains: u2 }), [x2, c2, s2, v2, d2, u2, h2]);
}
function xe() {
}
let Pe$1 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function se(t2) {
  var r2;
  let n2 = {};
  for (let s2 of Pe$1)
    n2[s2] = (r2 = t2[s2]) != null ? r2 : xe;
  return n2;
}
function Re(t2) {
  let n2 = reactExports.useRef(se(t2));
  return reactExports.useEffect(() => {
    n2.current = se(t2);
  }, [t2]), n2;
}
let ye = "div", ae = S$5.RenderStrategy;
function De(t2, n2) {
  var K2, Q2;
  let { beforeEnter: r2, afterEnter: s2, beforeLeave: y2, afterLeave: D2, enter: c$12, enterFrom: x2, enterTo: p2, entered: h2, leave: u2, leaveFrom: v2, leaveTo: d2, ...i2 } = t2, e2 = reactExports.useRef(null), a2 = y$3(e2, n2), o3 = (K2 = i2.unmount) == null || K2 ? j$2.Unmount : j$2.Hidden, { show: f2, appear: P2, initial: T2 } = Se$1(), [l2, j2] = reactExports.useState(f2 ? "visible" : "hidden"), q2 = Ne(), { register: O2, unregister: V2 } = q2;
  reactExports.useEffect(() => O2(e2), [O2, e2]), reactExports.useEffect(() => {
    if (o3 === j$2.Hidden && e2.current) {
      if (f2 && l2 !== "visible") {
        j2("visible");
        return;
      }
      return u$5(l2, { ["hidden"]: () => V2(e2), ["visible"]: () => O2(e2) });
    }
  }, [l2, e2, O2, V2, f2, o3]);
  let k2 = s$7({ base: S(i2.className), enter: S(c$12), enterFrom: S(x2), enterTo: S(p2), entered: S(h2), leave: S(u2), leaveFrom: S(v2), leaveTo: S(d2) }), w2 = Re({ beforeEnter: r2, afterEnter: s2, beforeLeave: y2, afterLeave: D2 }), G2 = l$3();
  reactExports.useEffect(() => {
    if (G2 && l2 === "visible" && e2.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [e2, l2, G2]);
  let ue2 = T2 && !P2, z2 = P2 && f2 && T2, Te2 = (() => !G2 || ue2 ? "idle" : f2 ? "enter" : "leave")(), H2 = c(0), de2 = o$4((g2) => u$5(g2, { enter: () => {
    H2.addFlag(d$3.Opening), w2.current.beforeEnter();
  }, leave: () => {
    H2.addFlag(d$3.Closing), w2.current.beforeLeave();
  }, idle: () => {
  } })), fe2 = o$4((g2) => u$5(g2, { enter: () => {
    H2.removeFlag(d$3.Opening), w2.current.afterEnter();
  }, leave: () => {
    H2.removeFlag(d$3.Closing), w2.current.afterLeave();
  }, idle: () => {
  } })), A2 = oe(() => {
    j2("hidden"), V2(e2);
  }, q2);
  E({ immediate: z2, container: e2, classes: k2, direction: Te2, onStart: s$7((g2) => {
    A2.onStart(e2, g2, de2);
  }), onStop: s$7((g2) => {
    A2.onStop(e2, g2, fe2), g2 === "leave" && !U(A2) && (j2("hidden"), V2(e2));
  }) });
  let R2 = i2, me2 = { ref: a2 };
  return z2 ? R2 = { ...R2, className: t$8(i2.className, ...k2.current.enter, ...k2.current.enterFrom) } : (R2.className = t$8(i2.className, (Q2 = e2.current) == null ? void 0 : Q2.className), R2.className === "" && delete R2.className), React.createElement(M.Provider, { value: A2 }, React.createElement(c$4, { value: u$5(l2, { ["visible"]: d$3.Open, ["hidden"]: d$3.Closed }) | H2.flags }, X$1({ ourProps: me2, theirProps: R2, defaultTag: ye, features: ae, visible: l2 === "visible", name: "Transition.Child" })));
}
function He(t2, n2) {
  let { show: r2, appear: s2 = false, unmount: y2 = true, ...D2 } = t2, c2 = reactExports.useRef(null), x2 = y$3(c2, n2);
  l$3();
  let p2 = C();
  if (r2 === void 0 && p2 !== null && (r2 = (p2 & d$3.Open) === d$3.Open), ![true, false].includes(r2))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [h2, u2] = reactExports.useState(r2 ? "visible" : "hidden"), v2 = oe(() => {
    u2("hidden");
  }), [d2, i2] = reactExports.useState(true), e2 = reactExports.useRef([r2]);
  l$4(() => {
    d2 !== false && e2.current[e2.current.length - 1] !== r2 && (e2.current.push(r2), i2(false));
  }, [e2, r2]);
  let a2 = reactExports.useMemo(() => ({ show: r2, appear: s2, initial: d2 }), [r2, s2, d2]);
  reactExports.useEffect(() => {
    if (r2)
      u2("visible");
    else if (!U(v2))
      u2("hidden");
    else {
      let T2 = c2.current;
      if (!T2)
        return;
      let l2 = T2.getBoundingClientRect();
      l2.x === 0 && l2.y === 0 && l2.width === 0 && l2.height === 0 && u2("hidden");
    }
  }, [r2, v2]);
  let o3 = { unmount: y2 }, f2 = o$4(() => {
    var T2;
    d2 && i2(false), (T2 = t2.beforeEnter) == null || T2.call(t2);
  }), P2 = o$4(() => {
    var T2;
    d2 && i2(false), (T2 = t2.beforeLeave) == null || T2.call(t2);
  });
  return React.createElement(M.Provider, { value: v2 }, React.createElement(_.Provider, { value: a2 }, X$1({ ourProps: { ...o3, as: reactExports.Fragment, children: React.createElement(le, { ref: x2, ...o3, ...D2, beforeEnter: f2, beforeLeave: P2 }) }, theirProps: {}, defaultTag: reactExports.Fragment, features: ae, visible: h2 === "visible", name: "Transition" })));
}
function Fe(t2, n2) {
  let r2 = reactExports.useContext(_) !== null, s2 = C() !== null;
  return React.createElement(React.Fragment, null, !r2 && s2 ? React.createElement(W, { ref: n2, ...t2 }) : React.createElement(le, { ref: n2, ...t2 }));
}
let W = D$2(He), le = D$2(De), Le = D$2(Fe), tt$1 = Object.assign(W, { Child: Le, Root: W });
const sides = ["top", "right", "bottom", "left"];
const alignments = ["start", "end"];
const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y: y2
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$1 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 + alignmentOffset
      }
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d2) => {
        const alignment2 = getAlignment(d2.placement);
        return [d2.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
        ) : (
          // Check only the mainAxis.
          d2.overflows[0]
        ), d2.overflows];
      }).sort((a2, b2) => a2[1] - b2[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d2[0]) ? 2 : 3
      ).every((v2) => v2 <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
const flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
const shift2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement$1(value) {
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement$1(value) {
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$1(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$1(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow$1(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$1(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentIFrame = getWindow$1(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$1(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el2) => isElement$1(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow$1(element);
  if (!isHTMLElement$1(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
const getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io2 && io2.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries2) {
      const ratio = entries2[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
const arrow = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow$1({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return arrow$1({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};
var index$2 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$1(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length, i2, keys2;
  if (a2 && b2 && typeof a2 == "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual$1(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual$1(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index$2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$1(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const [reference, _setReference] = reactExports.useState(null);
  const [floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (referenceRef.current !== node) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (floatingRef.current !== node) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config2 = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config2.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual$1(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index$2(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$2(() => {
    if (reference && floating) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(reference, floating, update);
      } else {
        update();
      }
    }
  }, [reference, floating, update, whileElementsMountedRef]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference,
    floating
  }), [reference, floating]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, elements, setReference, setFloating]);
}
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function createPubSub() {
  const map2 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map2.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map2.set(event, [...map2.get(event) || [], listener]);
    },
    off(event, listener) {
      map2.set(event, (map2.get(event) || []).filter((l2) => l2 !== listener));
    }
  };
}
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function getWindow(value) {
  return getDocument(value).defaultView || window;
}
function isElement(value) {
  return value ? value instanceof getWindow(value).Element : false;
}
const useInsertionEffect = React$1[/* @__PURE__ */ "useInsertionEffect".toString()];
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const position = useFloating$1(options);
  const tree = useFloatingTree();
  const domReferenceRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef({});
  const events = reactExports.useState(() => createPubSub())[0];
  const [domReference, setDomReference] = reactExports.useState(null);
  const setPositionReference = reactExports.useCallback((node) => {
    const positionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    position.refs.setReference(positionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const onOpenChange = useEvent(unstable_onOpenChange);
  const context = reactExports.useMemo(() => ({
    ...position,
    refs,
    elements,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange
  }), [position, nodeId, events, open, onOpenChange, refs, elements]);
  index$1(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context,
    refs,
    reference: setReference,
    positionReference: setPositionReference
  }), [position, refs, context, setReference, setPositionReference]);
}
var $t = Object.defineProperty;
var Dt = (t2, a2, o3) => a2 in t2 ? $t(t2, a2, { enumerable: true, configurable: true, writable: true, value: o3 }) : t2[a2] = o3;
var Xe = (t2, a2, o3) => (Dt(t2, typeof a2 != "symbol" ? a2 + "" : a2, o3), o3);
var _e = { exports: {} }, G = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ge;
function Jt() {
  if (Ge)
    return G;
  Ge = 1;
  var t2 = React, a2 = Symbol.for("react.element"), o3 = Symbol.for("react.fragment"), n2 = Object.prototype.hasOwnProperty, u2 = t2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, y2 = { key: true, ref: true, __self: true, __source: true };
  function d2(m2, v2, b2) {
    var s2, c2 = {}, R2 = null, l2 = null;
    b2 !== void 0 && (R2 = "" + b2), v2.key !== void 0 && (R2 = "" + v2.key), v2.ref !== void 0 && (l2 = v2.ref);
    for (s2 in v2)
      n2.call(v2, s2) && !y2.hasOwnProperty(s2) && (c2[s2] = v2[s2]);
    if (m2 && m2.defaultProps)
      for (s2 in v2 = m2.defaultProps, v2)
        c2[s2] === void 0 && (c2[s2] = v2[s2]);
    return { $$typeof: a2, type: m2, key: R2, ref: l2, props: c2, _owner: u2.current };
  }
  return G.Fragment = o3, G.jsx = d2, G.jsxs = d2, G;
}
_e.exports = Jt();
var w = _e.exports;
class Ht {
  constructor() {
    Xe(this, "current", this.detect());
  }
  set(a2) {
    this.current !== a2 && (this.current = a2);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}
const ie = new Ht();
function Kt(t2, a2, o3, n2) {
  reactExports.useEffect(() => {
    const u2 = [];
    (typeof n2.offset == "number" || typeof n2.offset == "object" || typeof n2.offset == "function") && u2.push(offset(n2.offset)), (n2.flip === true || typeof n2.flip == "number" || typeof n2.flip == "object") && u2.push(flip({
      padding: typeof n2.flip == "number" ? n2.flip : void 0,
      ...typeof n2.flip == "object" ? n2.flip : {}
    })), (n2.shift === true || typeof n2.shift == "number" || typeof n2.shift == "object") && u2.push(shift2({
      padding: typeof n2.shift == "number" ? n2.shift : void 0,
      ...typeof n2.shift == "object" ? n2.shift : {}
    })), (n2.autoPlacement === true || typeof n2.autoPlacement == "object") && u2.push(autoPlacement(
      typeof n2.autoPlacement == "object" ? n2.autoPlacement : void 0
    )), (n2.arrow === true || typeof n2.arrow == "number") && u2.push(arrow({
      element: o3,
      padding: n2.arrow === true ? 0 : n2.arrow
    })), u2.push(...typeof n2.middleware == "function" ? n2.middleware({
      referenceEl: a2.reference,
      floatingEl: a2.floating
    }) : n2.middleware || []), (n2.hide === true || typeof n2.hide == "object") && u2.push(hide(
      typeof n2.hide == "object" ? n2.hide : void 0
    )), t2(u2);
  }, [
    n2.offset,
    n2.shift,
    n2.flip,
    n2.arrow,
    n2.autoPlacement,
    n2.hide,
    n2.middleware
  ]);
}
function Zt(t2, a2, o3) {
  reactExports.useEffect(() => {
    if (t2 && ie.isClient && typeof ResizeObserver < "u" && a2.current && a2.current instanceof Element) {
      const n2 = new ResizeObserver(([u2]) => {
        const y2 = u2.borderBoxSize.reduce((d2, { inlineSize: m2 }) => d2 + m2, 0);
        o3(y2);
      });
      return n2.observe(a2.current), () => {
        n2.disconnect(), o3(null);
      };
    }
  }, []);
}
const Qt = (t2) => {
  switch (t2) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "";
  }
};
function er(t2, a2) {
  return reactExports.useMemo(() => typeof t2.originClass == "function" ? t2.originClass(a2) : typeof t2.originClass == "string" ? t2.originClass : t2.tailwindcssOriginClass ? Qt(a2) : "", [a2, t2.originClass, t2.tailwindcssOriginClass]);
}
function et(t2, a2, ...o3) {
  if (t2 in a2) {
    const u2 = a2[t2];
    return typeof u2 == "function" ? u2(...o3) : u2;
  }
  const n2 = new Error(
    `Tried to handle "${t2}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      a2
    ).map((u2) => `"${u2}"`).join(", ")}.`
  );
  throw Error.captureStackTrace && Error.captureStackTrace(n2, et), n2;
}
function tt(t2) {
  return ie.isServer ? null : t2 instanceof Node ? t2.ownerDocument : t2 && Object.prototype.hasOwnProperty.call(t2, "current") && t2.current instanceof Node ? t2.current.ownerDocument : document;
}
const Ke = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(
  // TODO: Remove this once JSDOM fixes the issue where an element that is
  // "hidden" can be the document.activeElement, because this is not possible
  // in real browsers.
  (t2) => `${t2}:not([tabindex='-1'])`
).join(",");
var rt = /* @__PURE__ */ ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(rt || {});
function tr(t2, a2 = 0) {
  var o3;
  return t2 === ((o3 = tt(t2)) == null ? void 0 : o3.body) ? false : et(a2, {
    [
      0
      /* Strict */
    ]() {
      return t2.matches(Ke);
    },
    [
      1
      /* Loose */
    ]() {
      let n2 = t2;
      for (; n2 !== null; ) {
        if (n2.matches(Ke))
          return true;
        n2 = n2.parentElement;
      }
      return false;
    }
  });
}
const rr = (t2, a2) => {
  ie.isServer ? reactExports.useEffect(t2, a2) : reactExports.useLayoutEffect(t2, a2);
};
function nr(t2) {
  const a2 = reactExports.useRef(t2);
  return rr(() => {
    a2.current = t2;
  }, [t2]), a2;
}
function D(t2, a2, o3) {
  const n2 = nr(a2);
  reactExports.useEffect(() => {
    function u2(y2) {
      n2.current(y2);
    }
    return document.addEventListener(t2, u2, o3), () => document.removeEventListener(t2, u2, o3);
  }, [t2, o3]);
}
function or(t2, a2, o3 = true) {
  const n2 = reactExports.useRef(false);
  reactExports.useEffect(
    () => {
      requestAnimationFrame(() => {
        n2.current = o3;
      });
    },
    [o3]
  );
  function u2(d2, m2) {
    if (!n2.current || d2.defaultPrevented)
      return;
    const v2 = function s2(c2) {
      return typeof c2 == "function" ? s2(c2()) : Array.isArray(c2) || c2 instanceof Set ? c2 : [c2];
    }(t2), b2 = m2(d2);
    if (b2 !== null && b2.getRootNode().contains(b2)) {
      for (const s2 of v2) {
        if (s2 === null)
          continue;
        const c2 = s2 instanceof HTMLElement ? s2 : s2.current;
        if (c2 != null && c2.contains(b2) || d2.composed && d2.composedPath().includes(c2))
          return;
      }
      return (
        // This check alllows us to know whether or not we clicked on a "focusable" element like a
        // button or an input. This is a backwards compatibility check so that you can open a <Menu
        // /> and click on another <Menu /> which should close Menu A and open Menu B. We might
        // revisit that so that you will require 2 clicks instead.
        !tr(b2, rt.Loose) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it
        // unfocusable via the keyboard so that tabbing to the next item from the input doesn't
        // first go to the button.
        b2.tabIndex !== -1 && d2.preventDefault(), a2(d2, b2)
      );
    }
  }
  const y2 = reactExports.useRef(null);
  D("mousedown", (d2) => {
    var m2, v2;
    n2.current && (y2.current = ((v2 = (m2 = d2.composedPath) == null ? void 0 : m2.call(d2)) == null ? void 0 : v2[0]) || d2.target);
  }, true), D(
    "click",
    (d2) => {
      y2.current && (u2(d2, () => y2.current), y2.current = null);
    },
    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`
    // don't "cancel" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`
    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,
    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.
    true
  ), D("blur", (d2) => u2(
    d2,
    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null
  ), true);
}
const je = reactExports.createContext(null);
je.displayName = "ReferenceContext";
const Pe = reactExports.createContext(null);
Pe.displayName = "FloatingContext";
const K = reactExports.createContext(null);
K.displayName = "ArrowContext";
function nt(t2) {
  const a2 = reactExports.useContext(je);
  if (a2 === null) {
    const o3 = new Error(`<${t2} /> is missing a parent <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, nt), o3;
  }
  return a2;
}
function ot(t2) {
  const a2 = reactExports.useContext(Pe);
  if (a2 === null) {
    const o3 = new Error(`<${t2} /> is missing a parent <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, ot), o3;
  }
  return a2;
}
function at(t2) {
  const a2 = reactExports.useContext(K);
  if (a2 === null) {
    const o3 = new Error(`<${t2} /> is missing a parent <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o3, at), o3;
  }
  return a2;
}
function it(t2, a2, o3, n2) {
  const { referenceRef: u2 } = n2, y2 = a2;
  if (y2.as === reactExports.Fragment)
    return /* @__PURE__ */ w.jsx(
      t2.type,
      {
        ...t2.props,
        ...o3,
        ref: u2
      }
    );
  const d2 = y2.as || "div";
  return /* @__PURE__ */ w.jsx(d2, { ...o3, ref: u2, children: /* @__PURE__ */ w.jsx(t2.type, { ...t2.props }) });
}
function Oe(t2, a2, o3, n2) {
  const { floatingRef: u2, props: y2, mounted: d2, setShow: m2, x: v2, y: b2, placement: s2, strategy: c2, referenceElWidth: R2 } = n2, l2 = {
    ...y2,
    ...a2
  }, O2 = er(l2, s2), A2 = {
    show: d2.current ? l2.show : false,
    enter: `${l2.enter || ""} ${O2}`,
    enterFrom: `${l2.enterFrom || ""}`,
    enterTo: `${l2.enterTo || ""}`,
    leave: `${l2.leave || ""} ${O2}`,
    leaveFrom: `${l2.leaveFrom || ""}`,
    leaveTo: `${l2.leaveTo || ""}`,
    beforeEnter: () => {
      m2(true);
    },
    afterLeave: () => {
      m2(false);
    }
  }, W2 = {
    style: {
      // If enable dialog mode, then set `transform` to false.
      ...!l2.dialog && (l2.transform || l2.transform === void 0) ? {
        position: c2,
        zIndex: l2.zIndex || 9999,
        top: "0px",
        left: "0px",
        right: "auto",
        bottom: "auto",
        transform: `translate(${Math.round(v2 || 0)}px,${Math.round(b2 || 0)}px)`
      } : {
        position: c2,
        zIndex: l2.zIndex || 9999,
        top: `${b2 || 0}px`,
        left: `${v2 || 0}px`
      },
      width: l2.adaptiveWidth && typeof R2 == "number" ? `${R2}px` : void 0
    }
  };
  function T2(S2) {
    return l2.portal ? /* @__PURE__ */ w.jsx(pe, { children: S2 }) : S2;
  }
  function x2(S2) {
    const L2 = {
      ...W2,
      ...o3,
      ref: u2
    };
    if (l2.as === reactExports.Fragment)
      return /* @__PURE__ */ w.jsx(
        S2.type,
        {
          ...S2.props,
          ...L2
        }
      );
    const N3 = l2.as || "div";
    return /* @__PURE__ */ w.jsx(N3, { ...L2, children: /* @__PURE__ */ w.jsx(S2.type, { ...S2.props }) });
  }
  function M2() {
    return ie.isServer ? d2.current && l2.show ? /* @__PURE__ */ w.jsx(t2.type, { ...t2.props }) : /* @__PURE__ */ w.jsx(reactExports.Fragment, {}) : l2.transitionChild ? /* @__PURE__ */ w.jsx(tt$1.Child, { as: reactExports.Fragment, ...A2, children: /* @__PURE__ */ w.jsx(t2.type, { ...t2.props }) }) : /* @__PURE__ */ w.jsx(tt$1, { as: reactExports.Fragment, ...A2, children: /* @__PURE__ */ w.jsx(t2.type, { ...t2.props }) });
  }
  return T2(
    x2(
      M2()
    )
  );
}
function ut([t2, a2], o3) {
  var N3, X2;
  const n2 = reactExports.useRef(false), [u2, y2] = reactExports.useState(), d2 = reactExports.useRef(null), m2 = reactExports.useMemo(() => ({
    show: o3.onShow || (() => {
    }),
    hide: o3.onHide || (() => {
    }),
    update: o3.onUpdate || (() => {
    })
  }), [o3.onShow, o3.onHide, o3.onUpdate]), { x: v2, y: b2, placement: s2, strategy: c2, update: R2, refs: l2, middlewareData: O2 } = useFloating({
    placement: o3.placement || "bottom-start",
    strategy: o3.strategy,
    middleware: u2
  }), [A2, W2] = reactExports.useState(null), T2 = reactExports.useCallback(() => {
    R2(), m2.update();
  }, [R2, m2]);
  reactExports.useEffect(T2, [o3.placement, o3.strategy, u2]), Kt(y2, l2, d2, o3), reactExports.useEffect(() => {
    n2.current = true;
  }, []), Zt(o3.adaptiveWidth, l2.reference, W2), reactExports.useEffect(() => {
    if (l2.reference.current && l2.floating.current && t2) {
      const Z2 = o3.autoUpdate !== false ? autoUpdate(
        l2.reference.current,
        l2.floating.current,
        T2,
        typeof o3.autoUpdate == "object" ? o3.autoUpdate : void 0
      ) : () => {
      };
      return m2.show(), () => {
        Z2(), m2.hide();
      };
    }
  }, [t2, T2, l2]);
  const x2 = reactExports.useRef(true);
  reactExports.useEffect(() => {
    !(l2.reference.current instanceof Element) && l2.reference.current && l2.floating.current && x2.current && (x2.current = false, T2(), window.requestAnimationFrame(() => {
      x2.current = true, T2();
    }));
  }, [l2]);
  const M2 = {
    referenceRef: l2.setReference,
    placement: s2
  }, S2 = {
    floatingRef: l2.setFloating,
    props: o3,
    mounted: n2,
    setShow: a2,
    x: v2,
    y: b2,
    placement: s2,
    strategy: c2,
    referenceElWidth: A2
  }, L2 = {
    arrowRef: d2,
    placement: s2,
    x: (N3 = O2.arrow) == null ? void 0 : N3.x,
    y: (X2 = O2.arrow) == null ? void 0 : X2.y
  };
  return { referenceApi: M2, floatingApi: S2, arrowApi: L2, x: v2, y: b2, placement: s2, strategy: c2, update: T2, refs: l2, middlewareData: O2 };
}
const ct = reactExports.forwardRef((t2, a2) => {
  const [o3, n2] = reactExports.useState(t2.show ?? false), {
    referenceApi: u2,
    floatingApi: y2,
    arrowApi: d2,
    placement: m2
  } = ut([o3, n2], t2), v2 = { placement: m2 }, [b2, s2] = typeof t2.children == "function" ? t2.children(v2) : t2.children;
  if (!reactExports.isValidElement(b2))
    return console.warn("<Float /> is missing a reference and floating element."), /* @__PURE__ */ w.jsx(reactExports.Fragment, {});
  function c2(O2) {
    if (t2.as === reactExports.Fragment || !t2.as)
      return /* @__PURE__ */ w.jsx(reactExports.Fragment, { children: O2 });
    const A2 = t2.as;
    return /* @__PURE__ */ w.jsx(A2, { ref: a2, className: t2.className, children: O2 });
  }
  if (t2.composable || t2.dialog)
    return c2(
      /* @__PURE__ */ w.jsx(je.Provider, { value: u2, children: /* @__PURE__ */ w.jsx(Pe.Provider, { value: y2, children: /* @__PURE__ */ w.jsx(K.Provider, { value: d2, children: typeof t2.children == "function" ? t2.children(v2) : t2.children }) }) }, "FloatingNode")
    );
  const R2 = it(
    b2,
    { as: reactExports.Fragment },
    { key: "reference-node" },
    u2
  ), l2 = Oe(
    s2,
    { as: t2.floatingAs || "div" },
    {},
    y2
  );
  return c2([
    R2,
    /* @__PURE__ */ w.jsx(K.Provider, { value: d2, children: l2 }, "floating-node")
  ]);
});
ct.displayName = "Float";
function ar(t2) {
  if (!t2.children)
    return /* @__PURE__ */ w.jsx(reactExports.Fragment, {});
  const a2 = reactExports.useMemo(() => {
    const { as: y2, children: d2, ...m2 } = t2;
    return m2;
  }, [t2]), o3 = nt("Float.Reference"), { placement: n2 } = o3, u2 = { placement: n2 };
  return it(
    typeof t2.children == "function" ? t2.children(u2) : t2.children,
    { ...t2, as: t2.as || reactExports.Fragment },
    a2,
    o3
  );
}
function ir(t2) {
  if (!t2.children)
    return /* @__PURE__ */ w.jsx(reactExports.Fragment, {});
  const a2 = reactExports.useMemo(() => {
    const { as: y2, enter: d2, enterFrom: m2, enterTo: v2, leave: b2, leaveFrom: s2, leaveTo: c2, originClass: R2, tailwindcssOriginClass: l2, transitionChild: O2, children: A2, ...W2 } = t2;
    return W2;
  }, [t2]), o3 = ot("Float.Content"), { placement: n2 } = o3, u2 = { placement: n2 };
  return Oe(
    typeof t2.children == "function" ? t2.children(u2) : t2.children,
    { ...t2, as: t2.as || "div" },
    a2,
    o3
  );
}
function ur(t2) {
  const { arrowRef: a2, placement: o3, x: n2, y: u2 } = at("Float.Arrow"), y2 = reactExports.useMemo(() => {
    const { as: b2, offset: s2, children: c2, ...R2 } = t2;
    return R2;
  }, [t2]), d2 = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }[o3.split("-")[0]], m2 = {
    left: typeof n2 == "number" ? `${n2}px` : void 0,
    top: typeof u2 == "number" ? `${u2}px` : void 0,
    right: void 0,
    bottom: void 0,
    [d2]: `${(t2.offset ?? 4) * -1}px`,
    ...y2.style
  };
  if (t2.as === reactExports.Fragment) {
    const b2 = { placement: o3 }, s2 = typeof t2.children == "function" ? t2.children(b2) : t2.children;
    return !s2 || !reactExports.isValidElement(s2) ? /* @__PURE__ */ w.jsx(reactExports.Fragment, {}) : /* @__PURE__ */ w.jsx(
      s2.type,
      {
        ...s2.props,
        ref: a2,
        style: m2
      }
    );
  }
  const v2 = t2.as || "div";
  return /* @__PURE__ */ w.jsx(
    v2,
    {
      ref: a2,
      ...y2,
      style: m2,
      children: t2.children
    }
  );
}
function Se({ onInitial: t2, children: a2, ...o3 }) {
  const [n2, u2] = reactExports.useState(o3.show ?? false), y2 = reactExports.useMemo(() => {
    const { as: l2, show: O2, placement: A2, strategy: W2, offset: T2, shift: x2, flip: M2, arrow: S2, autoPlacement: L2, hide: N3, autoUpdate: X2, zIndex: Z2, enter: ue2, enterFrom: Fe2, enterTo: ke2, leave: ce2, leaveFrom: $2, leaveTo: Y2, originClass: U2, tailwindcssOriginClass: se2, portal: le2, transform: fe2, middleware: de2, onShow: ve2, onHide: he2, onUpdate: me2, ...Q2 } = o3;
    return Q2;
  }, [o3]), {
    floatingApi: d2,
    arrowApi: m2,
    placement: v2,
    refs: b2
  } = ut([n2, u2], o3);
  reactExports.useEffect(() => {
    u2(o3.show ?? false);
  }, [o3.show]);
  function s2() {
    n2 && u2(false);
  }
  if (t2({ show: n2, setShow: u2, placement: v2, refs: b2 }), !a2)
    return /* @__PURE__ */ w.jsx(reactExports.Fragment, {});
  const R2 = Oe(
    typeof a2 == "function" ? a2({ placement: v2, close: s2 }) : a2,
    {
      ...o3,
      as: o3.as || reactExports.Fragment,
      show: n2
    },
    y2,
    d2
  );
  return /* @__PURE__ */ w.jsx(K.Provider, { value: m2, children: R2 });
}
function cr(t2) {
  function a2({ setShow: o3, refs: n2 }) {
    D("contextmenu", (u2) => {
      u2.preventDefault(), n2.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: u2.clientX,
            y: u2.clientY,
            top: u2.clientY,
            left: u2.clientX,
            right: u2.clientX,
            bottom: u2.clientY
          };
        }
      }), o3(true);
    }), or(n2.floating, () => {
      o3(false);
    });
  }
  return /* @__PURE__ */ w.jsx(
    Se,
    {
      flip: true,
      ...t2,
      show: false,
      portal: true,
      onInitial: a2
    }
  );
}
function sr({ globalHideCursor: t2, ...a2 }) {
  function o3({ setShow: n2, refs: u2 }) {
    function y2() {
      n2(true);
    }
    function d2() {
      n2(false);
    }
    function m2(c2) {
      u2.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: c2.clientX,
            y: c2.clientY,
            top: c2.clientY,
            left: c2.clientX,
            right: c2.clientX,
            bottom: c2.clientY
          };
        }
      });
    }
    function v2(c2) {
      y2(), m2(c2);
    }
    function b2(c2) {
      y2(), m2(c2.touches[0]);
    }
    const s2 = tt(u2.floating);
    s2 && (reactExports.useEffect(() => {
      if ((t2 || t2 === void 0) && !s2.getElementById("headlesui-float-cursor-style")) {
        const c2 = s2.createElement("style");
        return (s2.head || s2.getElementsByTagName("head")[0]).appendChild(c2), c2.id = "headlesui-float-cursor-style", c2.appendChild(s2.createTextNode([
          "*, *::before, *::after {",
          "  cursor: none !important;",
          "}",
          ".headlesui-float-cursor-root {",
          "  pointer-events: none !important;",
          "}"
        ].join(`
`))), () => {
          var l2;
          return (l2 = s2.getElementById("headlesui-float-cursor-style")) == null ? void 0 : l2.remove();
        };
      }
    }, [t2]), "ontouchstart" in window || navigator.maxTouchPoints > 0 ? (D("touchstart", b2), D("touchend", d2), D("touchmove", b2)) : (D("mouseenter", v2), D("mouseleave", d2), D("mousemove", v2)));
  }
  return /* @__PURE__ */ w.jsx(
    Se,
    {
      ...a2,
      portal: true,
      className: "headlesui-float-cursor-root",
      onInitial: o3
    }
  );
}
const gr = Object.assign(ct, { Reference: ar, Content: ir, Arrow: ur, Virtual: Se, ContextMenu: cr, Cursor: sr });
const Hint = ({
  children,
  iconProps = {},
  position = "left-1/2 -translate-x-1/2",
  maxWidth = "max-w-xs",
  size = 12,
  className = ""
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(kt, { className: "relative", children: ({ open }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(gr, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(kt.Button, { className: "rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      RiInformationFill,
      {
        size,
        className: `${open ? "ring-1 ring-base" : ""} rounded-full text-base transition-colors duration-150 hover:text-purple-500 focus:border-none focus:ring-base dark:text-base`,
        ...iconProps
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      tt$1,
      {
        as: reactExports.Fragment,
        enter: "transition ease-out duration-200",
        enterFrom: "opacity-0 translate-y-1",
        enterTo: "opacity-100 translate-y-0",
        leave: "transition ease-in duration-150",
        leaveFrom: "opacity-100 translate-y-0",
        leaveTo: "opacity-0 translate-y-1",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          kt.Panel,
          {
            className: "min-w-xs z-[1000]",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-hidden rounded shadow-lg ring-2 ring-inset ring-black/5", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-zinc-100/90 px-4 py-3 text-sm backdrop-blur-sm dark:bg-zinc-900/80", children }) })
          }
        )
      }
    )
  ] }) }) });
};
const SvgDashboard = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", ...props }, /* @__PURE__ */ reactExports.createElement("g", { stroke: "#6E8AA6", strokeWidth: 1.5 }, /* @__PURE__ */ reactExports.createElement("rect", { width: 6, height: 6, x: 4, y: 4, rx: 2 }), /* @__PURE__ */ reactExports.createElement("rect", { width: 6, height: 6, x: 4, y: 14, rx: 2 }), /* @__PURE__ */ reactExports.createElement("rect", { width: 6, height: 6, x: 14, y: 4, rx: 2 }), /* @__PURE__ */ reactExports.createElement("rect", { width: 6, height: 6, x: 14, y: 14, rx: 2 })));
const SvgFilter = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", ...props }, /* @__PURE__ */ reactExports.createElement("path", { stroke: "#8B9EB0", strokeWidth: 2, d: "M19 6H5c-1.1 0-1.4.6-.6 1.4l4.2 4.2c.8.8 1.4 2.3 1.4 3.4v5l4-2v-3.5c0-.8.6-2.1 1.4-2.9l4.2-4.2c.8-.8.5-1.4-.6-1.4Z" }));
const SvgList = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", ...props }, /* @__PURE__ */ reactExports.createElement("g", { stroke: "#6E8AA6", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5 }, /* @__PURE__ */ reactExports.createElement("path", { d: "M9 7h11M9 12h11M9 17h11M4 7h1M4 12h1M4 17h1" })));
const Dashboard = {
  component: SvgDashboard,
  name: "dashboard"
};
const List = { component: SvgList, name: "list" };
const Filter = { component: SvgFilter, name: "filter" };
const IconButton = ({
  disabled,
  Icon,
  size,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled, ...props, Icon, children: typeof Icon === "function" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, {}) : Icon });
};
const DashboardButton = ({
  disabled,
  size
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { disabled, Icon: Dashboard.component, size });
const ListButton = ({ disabled, size }) => /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { disabled, Icon: List.component, size });
const FilterButton = ({ disabled, size }) => /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { disabled, Icon: Filter.component, size });
var __defProp$a = Object.defineProperty;
var __getOwnPropDesc$a = Object.getOwnPropertyDescriptor;
var __decorateClass$9 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$a(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$a(target, key, result);
  return result;
};
let ErrorModel = class extends Model({
  error: prop().withSetter()
}) {
};
ErrorModel = __decorateClass$9([
  model("Error")
], ErrorModel);
const createErrorModel = () => new ErrorModel({});
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index2 < length) {
      var value = array2[index2];
      if (predicate(value, index2, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array2, values2) {
    var index2 = -1, length = values2.length, offset2 = array2.length;
    while (++index2 < length) {
      array2[offset2 + index2] = values2[index2];
    }
    return array2;
  }
  function arraySome(array2, predicate) {
    var index2 = -1, length = array2 == null ? 0 : array2.length;
    while (++index2 < length) {
      if (predicate(array2[index2], index2, array2)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set5) {
    var index2 = -1, result = Array(set5.size);
    set5.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries2) {
    var index2 = -1, length = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries2) {
    var index2 = -1, length = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries2) {
    var index2 = -1, length = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values2) {
    var index2 = -1, length = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values2[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries2) {
    var data = this.__data__ = new ListCache(entries2);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array2, key) {
    var length = array2.length;
    while (length--) {
      if (eq2(array2[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object2)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index2 = -1, result = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index2 < arrLength) {
      var arrValue = array2[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen2) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen2.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys2, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol) {
      return propertyIsEnumerable.call(object2, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs$1(lodash_isequalExports);
const noop$2 = () => {
};
const RATIO = Math.PI / 180;
const degreesToRadians = (degrees) => degrees * RATIO;
function polarToCartesian({ r: r2, theta }) {
  return {
    x: r2 * Math.cos(theta),
    y: r2 * Math.sin(theta)
  };
}
const ONE_MS = 1;
const ONE_SEC = ONE_MS * 1e3;
const ONE_MIN = ONE_SEC * 60;
var __defProp$9 = Object.defineProperty;
var __getOwnPropDesc$9 = Object.getOwnPropertyDescriptor;
var __decorateClass$8 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$9(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$9(target, key, result);
  return result;
};
const MIN_LOAD_TIME = ONE_MS * 500;
let LoaderModel = class extends Model({
  loading: prop(false),
  meta: prop(() => void 0),
  canCancel: prop(void 0)
}) {
  inProcess = false;
  loadQueue = [];
  resetTimer = null;
  loadTimer = null;
  setGlobalLoading(state) {
    if (!this.loadQueue.find((queueState) => isEqual(queueState, { ...state }))) {
      this.loadQueue.push(state);
    }
    if (!this.loadTimer) {
      this.activateLoadingQueue(!this.inProcess);
    }
  }
  updateCurrentLoadState(state) {
    const { loading } = state;
    if (typeof loading === "boolean")
      this.loading = loading;
    if (loading) {
      const { meta, canCancel } = state;
      if (meta)
        this.meta = meta;
      if (canCancel)
        this.canCancel = canCancel;
    } else {
      this.meta = null;
      this.canCancel = false;
    }
  }
  activateLoadingState(state) {
    this.inProcess = true;
    this.updateCurrentLoadState({ ...state, canCancel: false });
    if (state.loading) {
      this.resetTimer = setTimeout(() => {
        this.canCancel = true;
      }, state.timeout ?? ONE_MIN);
    }
  }
  deactivateLoadingState() {
    this.inProcess = false;
    this.updateCurrentLoadState({ loading: false, canCancel: false });
    clearTimeout(this.loadTimer ?? void 0);
    this.loadTimer = null;
    clearTimeout(this.resetTimer ?? void 0);
    this.resetTimer = null;
  }
  dequeue = () => {
    let next = this.loadQueue.shift();
    if (next) {
      if (next.loading === false) {
        const nextLoadStateIndex = this.loadQueue.findIndex(
          (state) => state.loading === true
        );
        if (nextLoadStateIndex >= 0) {
          this.loadQueue.splice(0, nextLoadStateIndex);
          next = this.loadQueue.shift();
          if (next) {
            this.activateLoadingState(next);
          }
        } else {
          this.deactivateLoadingState();
        }
      }
    }
  };
  activateLoadingQueue(immediate) {
    this.loadTimer = setInterval(() => this.dequeue(), MIN_LOAD_TIME);
    if (immediate)
      this.dequeue();
  }
  onAttachedToRootStore(rootStore) {
    console.log("loader attached");
    this.loadQueue = [];
  }
};
__decorateClass$8([
  modelAction
], LoaderModel.prototype, "setGlobalLoading", 1);
__decorateClass$8([
  modelAction
], LoaderModel.prototype, "deactivateLoadingState", 1);
LoaderModel = __decorateClass$8([
  model("Loader")
], LoaderModel);
const createLoaderModel = () => new LoaderModel({ loading: false, meta: null });
const LoaderModel$1 = LoaderModel;
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __decorateClass$7 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$8(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$8(target, key, result);
  return result;
};
let GlobalStateStore = class extends Model({
  loader: prop(createLoaderModel),
  error: prop(createErrorModel)
}) {
  setGlobalLoading(state) {
    this.loader.setGlobalLoading(state);
  }
  setGlobalError(state) {
    this.error.setError(state);
  }
};
__decorateClass$7([
  modelAction
], GlobalStateStore.prototype, "setGlobalLoading", 1);
__decorateClass$7([
  modelAction
], GlobalStateStore.prototype, "setGlobalError", 1);
GlobalStateStore = __decorateClass$7([
  model("GlobalState")
], GlobalStateStore);
const createGlobalStateStore = () => new GlobalStateStore({});
const getInitialTheme = () => {
  const peristentTheme = window.localStorage.getItem("theme");
  if (peristentTheme === "dark" || peristentTheme === "light") {
    return peristentTheme;
  }
  const mqTheme = window.matchMedia("(prefers-color-scheme: dark)");
  return mqTheme.matches ? "dark" : "light";
};
const observeDomTheme = (callback) => {
  const observer2 = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === "data-mode" && mutation.target === document.documentElement) {
        callback(document.documentElement.dataset.mode);
      }
    });
  });
  observer2.observe(document.documentElement, { attributes: true });
  return observer2.disconnect;
};
const ThemeContext = reactExports.createContext({
  theme: getInitialTheme()
});
const ThemeContextProvider = ThemeContext.Provider;
const ThemeProvider = ({
  children
}) => {
  const [theme, setTheme] = reactExports.useState(getInitialTheme());
  reactExports.useEffect(() => {
    observeDomTheme(setTheme);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeContextProvider, { value: { theme }, children });
};
let Debug = () => {
  return null;
};
const Footer = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: "flex w-full justify-center border-t-2 border-t-white p-2 text-center text-sm font-semibold", children: [
    "© 2014 - ",
    (/* @__PURE__ */ new Date()).getUTCFullYear(),
    " Tilli Software, All Rights Reserved"
  ] });
};
const LoadingScreen = ({
  show = false,
  cancellable,
  close,
  loadingMeta
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(tt$1, { show, as: reactExports.Fragment, unmount: false, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "relative z-[100]",
      onClose: cancellable ? close : noop$2,
      unmount: false,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          tt$1.Child,
          {
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            unmount: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bottom-0 left-0 right-0 top-0 h-screen w-screen overflow-hidden bg-black/25 backdrop-blur-sm" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex min-h-full items-center justify-center p-4 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          tt$1.Child,
          {
            as: reactExports.Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            unmount: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              _t.Panel,
              {
                className: `flex transform flex-col items-center overflow-hidden bg-base align-middle shadow-xl transition-all ${loadingMeta || cancellable ? "w-full max-w-xs rounded-2xl px-6 py-12 shadow-base" : "rounded-full p-16 shadow-lg shadow-base/20"}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 80 }),
                  !!loadingMeta && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    _t.Title,
                    {
                      as: "h3",
                      className: "mt-4 text-3xl font-bold leading-6",
                      children: loadingMeta
                    }
                  ),
                  cancellable && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { intent: "destructive", className: "mt-8", onClick: close, children: "Cancel" })
                ]
              }
            )
          }
        ) }) })
      ]
    }
  ) });
};
/**
 * @remix-run/router v1.8.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substr(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to2) {
    let base = window2.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to2 === "string" ? to2 : createPath(to2));
  }
  function validateHashLocation(location, to2) {
    warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to2) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to2, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action2 = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action2 = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action: action2,
        location: history.location,
        delta
      });
    }
  }
  function push2(to2, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to2, state);
    if (validateLocation)
      validateLocation(location, to2);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to2, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to2, state);
    if (validateLocation)
      validateLocation(location, to2);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to2) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url = createURL(to2);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push: push2,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index2) => {
    let treePath = [...parentPath, index2];
    let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
    if (isIndexRoute(route)) {
      let indexRoute = _extends$2({}, route, mapRouteProperties2(route), {
        id: id2
      });
      manifest[id2] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends$2({}, route, mapRouteProperties2(route), {
        id: id2,
        children: void 0
      });
      manifest[id2] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to2, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to2 === "string" ? parsePath(to2) : to2;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to2;
  if (typeof toArg === "string") {
    to2 = parsePath(toArg);
  } else {
    to2 = _extends$2({}, toArg);
    invariant(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
    invariant(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
    invariant(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
  }
  let isEmptyPath = toArg === "" || to2.pathname === "";
  let toPathname = isEmptyPath ? "/" : to2.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to2, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
const redirect = function redirect2(url, init2) {
  if (init2 === void 0) {
    init2 = 302;
  }
  let responseInit = init2;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers2 = new Headers(responseInit.headers);
  headers2.set("Location", url);
  return new Response(null, _extends$2({}, responseInit, {
    headers: headers2
  }));
};
class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = (route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
function createRouter$1(init2) {
  const routerWindow = init2.window ? init2.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser2;
  invariant(init2.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2;
  if (init2.mapRouteProperties) {
    mapRouteProperties2 = init2.mapRouteProperties;
  } else if (init2.detectErrorBoundary) {
    let detectErrorBoundary = init2.detectErrorBoundary;
    mapRouteProperties2 = (route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties2 = defaultMapRouteProperties;
  }
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(init2.routes, mapRouteProperties2, void 0, manifest);
  let inFlightDataRoutes;
  let basename = init2.basename || "/";
  let future = _extends$2({
    v7_normalizeFormMethod: false,
    v7_prependBasename: false
  }, init2.future);
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions = null;
  let getScrollRestorationKey = null;
  let getScrollPosition = null;
  let initialScrollRestored = init2.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init2.history.location, basename);
  let initialErrors = null;
  if (initialMatches == null) {
    let error = getInternalRouterError(404, {
      pathname: init2.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized = (
    // All initialMatches need to be loaded before we're ready.  If we have lazy
    // functions around still then we'll need to run them in initialize()
    !initialMatches.some((m2) => m2.route.lazy) && // And we have to either have no loaders or have been provided hydrationData
    (!initialMatches.some((m2) => m2.route.loader) || init2.hydrationData != null)
  );
  let router;
  let state = {
    historyAction: init2.history.action,
    location: init2.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init2.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init2.hydrationData && init2.hydrationData.loaderData || {},
    actionData: init2.hydrationData && init2.hydrationData.actionData || null,
    errors: init2.hydrationData && init2.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = Action.Pop;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledDeferredRoutes = [];
  let cancelledFetcherLoads = [];
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeDeferreds = /* @__PURE__ */ new Map();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let ignoreNextHistoryUpdate = false;
  function initialize() {
    unlistenHistory = init2.history.listen((_ref) => {
      let {
        action: historyAction,
        location,
        delta
      } = _ref;
      if (ignoreNextHistoryUpdate) {
        ignoreNextHistoryUpdate = false;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        ignoreNextHistoryUpdate = true;
        init2.history.go(delta * -1);
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            });
            init2.history.go(delta);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location);
    }
    return router;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_2, key) => deleteFetcher(key));
    state.blockers.forEach((_2, key) => deleteBlocker(key));
  }
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  function updateState(newState) {
    state = _extends$2({}, state, newState);
    subscribers.forEach((subscriber) => subscriber(state));
  }
  function completeNavigation(location, newState) {
    var _location$state, _location$state2;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_2, k2) => blockers.set(k2, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation)
      ;
    else if (pendingAction === Action.Pop)
      ;
    else if (pendingAction === Action.Push) {
      init2.history.push(location, location.state);
    } else if (pendingAction === Action.Replace) {
      init2.history.replace(location, location.state);
    }
    updateState(_extends$2({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }));
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  async function navigate(to2, opts) {
    if (typeof to2 === "number") {
      init2.history.go(to2);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to2, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation2 = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = _extends$2({}, nextLocation, init2.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = Action.Push;
    if (userReplace === true) {
      historyAction = Action.Replace;
    } else if (userReplace === false)
      ;
    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = Action.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let blockerKey = shouldBlockNavigation({
      currentLocation: currentLocation2,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to2, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  }
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    if (state.navigation.state === "submitting") {
      return;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(routesToUse, location, basename);
    if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(routesToUse);
      cancelActiveDeferreds();
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    }
    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init2.history, location, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionOutput = await handleAction(request, location, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      request = new Request(request.url, {
        signal: request.signal
      });
    }
    let {
      shortCircuited,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, _extends$2({
      matches
    }, pendingActionData ? {
      actionData: pendingActionData
    } : {}, {
      loaderData,
      errors
    }));
  }
  async function handleAction(request, location, submission, matches, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    });
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      result = await callLoaderOrAction("action", request, actionMatch, matches, manifest, mapRouteProperties2, basename);
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace2;
      if (opts && opts.replace != null) {
        replace2 = opts.replace;
      } else {
        replace2 = result.location === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(state, result, {
        submission,
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: {},
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  }
  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace2, pendingActionData, pendingError) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init2.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);
    cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(location, _extends$2({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingError || null
      }, pendingActionData ? {
        actionData: pendingActionData
      } : {}, updatedFetchers2 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      return {
        shortCircuited: true
      };
    }
    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach((rf2) => {
        let fetcher = state.fetchers.get(rf2.key);
        let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
        state.fetchers.set(rf2.key, revalidatingFetcher);
      });
      let actionData = pendingActionData || state.actionData;
      updateState(_extends$2({
        navigation: loadingNavigation
      }, actionData ? Object.keys(actionData).length === 0 ? {
        actionData: null
      } : {
        actionData
      } : {}, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    revalidatingFetchers.forEach((rf2) => {
      if (fetchControllers.has(rf2.key)) {
        abortFetcher(rf2.key);
      }
      if (rf2.controller) {
        fetchControllers.set(rf2.key, rf2.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
    let redirect3 = findRedirect(results);
    if (redirect3) {
      if (redirect3.idx >= matchesToLoad.length) {
        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      await startRedirectNavigation(state, redirect3.result, {
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends$2({
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function fetch2(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key))
      abortFetcher(key);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }));
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error);
      return;
    }
    let match = getTargetMatch(matches, path);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match, matches, submission);
  }
  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match.route.action && !match.route.lazy) {
      let error = getInternalRouterError(405, {
        method: submission.formMethod,
        pathname: path,
        routeId
      });
      setFetcherError(key, routeId, error);
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    let fetcher = getSubmittingFetcher(submission, existingFetcher);
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, manifest, mapRouteProperties2, basename);
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      if (pendingNavigationLoadId > originatingLoadId) {
        let doneFetcher = getDoneFetcher(void 0);
        state.fetchers.set(key, doneFetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        return;
      } else {
        fetchRedirectIds.add(key);
        let loadingFetcher = getLoadingFetcher(submission);
        state.fetchers.set(key, loadingFetcher);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        return startRedirectNavigation(state, actionResult, {
          submission,
          isFetchActionRedirect: true
        });
      }
    }
    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init2.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init2.history,
      state,
      matches,
      submission,
      nextLocation,
      isRevalidationRequired,
      cancelledDeferredRoutes,
      cancelledFetcherLoads,
      fetchLoadMatches,
      fetchRedirectIds,
      routesToUse,
      basename,
      {
        [match.route.id]: actionResult.data
      },
      void 0
      // No need to send through errors since we short circuit above
    );
    revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
      let staleKey = rf2.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher);
      if (fetchControllers.has(staleKey)) {
        abortFetcher(staleKey);
      }
      if (rf2.controller) {
        fetchControllers.set(staleKey, rf2.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
    let redirect3 = findRedirect(results);
    if (redirect3) {
      if (redirect3.idx >= matchesToLoad.length) {
        let fetcherKey = revalidatingFetchers[redirect3.idx - matchesToLoad.length].key;
        fetchRedirectIds.add(fetcherKey);
      }
      return startRedirectNavigation(state, redirect3.result);
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    let didAbortFetchLoads = abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState(_extends$2({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {
    let existingFetcher = state.fetchers.get(key);
    let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0);
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init2.history, path, abortController.signal);
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let result = await callLoaderOrAction("loader", fetchRequest, match, matches, manifest, mapRouteProperties2, basename);
    if (isDeferredResult(result)) {
      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
    }
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        let doneFetcher2 = getDoneFetcher(void 0);
        state.fetchers.set(key, doneFetcher2);
        updateState({
          fetchers: new Map(state.fetchers)
        });
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(state, result);
        return;
      }
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key);
      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
    let doneFetcher = getDoneFetcher(result.data);
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  async function startRedirectNavigation(state2, redirect3, _temp) {
    let {
      submission,
      replace: replace2,
      isFetchActionRedirect
    } = _temp === void 0 ? {} : _temp;
    if (redirect3.revalidate) {
      isRevalidationRequired = true;
    }
    let redirectLocation = createLocation(
      state2.location,
      redirect3.location,
      // TODO: This can be removed once we get rid of useTransition in Remix v2
      _extends$2({
        _isRedirect: true
      }, isFetchActionRedirect ? {
        _isFetchActionRedirect: true
      } : {})
    );
    invariant(redirectLocation, "Expected a location on the redirect navigation");
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect3.reloadDocument) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX$1.test(redirect3.location)) {
        const url = init2.history.createURL(redirect3.location);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace2) {
          routerWindow.location.replace(redirect3.location);
        } else {
          routerWindow.location.assign(redirect3.location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace2 === true ? Action.Replace : Action.Push;
    let activeSubmission = submission || getSubmissionFromNavigation(state2.navigation);
    if (redirectPreserveMethodStatusCodes.has(redirect3.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends$2({}, activeSubmission, {
          formAction: redirect3.location
        }),
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else if (isFetchActionRedirect) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation: getLoadingNavigation(redirectLocation),
        fetcherSubmission: activeSubmission,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, activeSubmission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset
      });
    }
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {
    let results = await Promise.all([...matchesToLoad.map((match) => callLoaderOrAction("loader", request, match, matches, manifest, mapRouteProperties2, basename)), ...fetchersToLoad.map((f2) => {
      if (f2.matches && f2.match && f2.controller) {
        return callLoaderOrAction("loader", createClientSideRequest(init2.history, f2.path, f2.controller.signal), f2.match, f2.matches, manifest, mapRouteProperties2, basename);
      } else {
        let error = {
          type: ResultType.error,
          error: getInternalRouterError(404, {
            pathname: f2.path
          })
        };
        return error;
      }
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((f2) => f2.match), fetcherResults, fetchersToLoad.map((f2) => f2.controller ? f2.controller.signal : null), true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    fetchLoadMatches.forEach((_2, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation: currentLocation2,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries2 = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries2[entries2.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({
      currentLocation: currentLocation2,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  function enableScrollRestoration(positions2, getPosition, getKey) {
    savedScrollPositions = positions2;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y2 = getSavedScrollPosition(state.location, state.matches);
      if (y2 != null) {
        updateState({
          restoreScrollPosition: y2
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location, matches.map((m2) => createUseMatchesMatch(m2, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location, matches);
      let y2 = savedScrollPositions[key];
      if (typeof y2 === "number") {
        return y2;
      }
    }
    return null;
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  router = {
    get basename() {
      return basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to2) => init2.history.createHref(to2),
    encodeLocation: (to2) => init2.history.encodeLocation(to2),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches, basename, prependBasename, to2, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId != null && relative !== "path") {
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(to2 ? to2 : ".", getPathContributingMatches(contextualMatches).map((m2) => m2.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  if (to2 == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to2 == null || to2 === "" || to2 === ".") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce((acc, _ref3) => {
          let [name2, value] = _ref3;
          return "" + acc + name2 + "=" + value + "\n";
        }, "")
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e2) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e2) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index2 = matches.findIndex((m2) => m2.route.id === boundaryId);
    if (index2 >= 0) {
      boundaryMatches = matches.slice(0, index2);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match, index2) => {
    if (match.route.lazy) {
      return true;
    }
    if (match.route.loader == null) {
      return false;
    }
    if (isNewLoader(state.loaderData, state.matches[index2], match) || cancelledDeferredRoutes.some((id2) => id2 === match.route.id)) {
      return true;
    }
    let currentRouteMatch = state.matches[index2];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, _extends$2({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      defaultShouldRevalidate: (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || // Clicked the same link, resubmitted a GET form
        currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    }));
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f2, key) => {
    if (!matches.some((m2) => m2.route.id === f2.routeId)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.includes(key)) {
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$2({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        defaultShouldRevalidate: isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match.route.id !== currentMatch.route.id
  );
  let isMissingData = currentLoaderData[match.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, _extends$2({}, mapRouteProperties2(routeToUpdate), {
    lazy: void 0
  }));
}
async function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties2, basename, opts) {
  if (opts === void 0) {
    opts = {};
  }
  let resultType;
  let result;
  let onReject;
  let runHandler = (handler) => {
    let reject;
    let abortPromise = new Promise((_2, r2) => reject = r2);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    return Promise.race([handler({
      request,
      params: match.params,
      context: opts.requestContext
    }), abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (match.route.lazy) {
      if (handler) {
        let values2 = await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, mapRouteProperties2, manifest)]);
        result = values2[0];
      } else {
        await loadLazyRouteModule(match.route, mapRouteProperties2, manifest);
        handler = match.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          return {
            type: ResultType.data,
            data: void 0
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e2) {
    resultType = ResultType.error;
    result = e2;
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  if (isResponse(result)) {
    let status = result.status;
    if (redirectStatusCodes.has(status)) {
      let location = result.headers.get("Location");
      invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
      if (!ABSOLUTE_URL_REGEX$1.test(location)) {
        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);
      } else if (!opts.isStaticRequest) {
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);
        let isSameBasename = stripBasename(url.pathname, basename) != null;
        if (url.origin === currentUrl.origin && isSameBasename) {
          location = url.pathname + url.search + url.hash;
        }
      }
      if (opts.isStaticRequest) {
        result.headers.set("Location", location);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null,
        reloadDocument: result.headers.get("X-Remix-Reload-Document") !== null
      };
    }
    if (opts.isRouteRequest) {
      let queryRouteResponse = {
        type: resultType === ResultType.error ? ResultType.error : ResultType.data,
        response: result
      };
      throw queryRouteResponse;
    }
    let data;
    let contentType = result.headers.get("Content-Type");
    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (isDeferredData(result)) {
    var _result$init, _result$init2;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init2 = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init2.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init2.headers = new Headers({
        "Content-Type": formEncType
      });
      init2.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init2.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init2.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init2.body = submission.formData;
    }
  }
  return new Request(url, init2);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  results.forEach((result, index2) => {
    let id2 = matchesToLoad[index2].route.id;
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, id2);
      let error = result.error;
      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = void 0;
      }
      errors = errors || {};
      if (errors[boundaryMatch.route.id] == null) {
        errors[boundaryMatch.route.id] = error;
      }
      loaderData[id2] = void 0;
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id2, result.deferredData);
        loaderData[id2] = result.deferredData.data;
      } else {
        loaderData[id2] = result.data;
      }
      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    }
  });
  if (pendingError) {
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let {
      key,
      match,
      controller
    } = revalidatingFetchers[index2];
    invariant(fetcherResults !== void 0 && fetcherResults[index2] !== void 0, "Did not find corresponding fetcher result");
    let result = fetcherResults[index2];
    if (controller && controller.signal.aborted) {
      continue;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends$2({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends$2({}, newLoaderData);
  for (let match of matches) {
    let id2 = match.route.id;
    if (newLoaderData.hasOwnProperty(id2)) {
      if (newLoaderData[id2] !== void 0) {
        mergedLoaderData[id2] = newLoaderData[id2];
      }
    } else if (loaderData[id2] !== void 0 && match.route.loader) {
      mergedLoaderData[id2] = loaderData[id2];
    }
    if (errors && errors.hasOwnProperty(id2)) {
      break;
    }
  }
  return mergedLoaderData;
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m2) => m2.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp4) {
  let {
    pathname,
    routeId,
    method,
    type
  } = _temp4 === void 0 ? {} : _temp4;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = 'No route matches URL "' + pathname + '"';
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
    }
  }
  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
}
function findRedirect(results) {
  for (let i2 = results.length - 1; i2 >= 0; i2--) {
    let result = results[i2];
    if (isRedirectResult(result)) {
      return {
        result,
        idx: i2
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends$2({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a2, b2) {
  if (a2.pathname !== b2.pathname || a2.search !== b2.search) {
    return false;
  }
  if (a2.hash === "") {
    return b2.hash !== "";
  } else if (a2.hash === b2.hash) {
    return true;
  } else if (b2.hash !== "") {
    return true;
  }
  return false;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {
  for (let index2 = 0; index2 < results.length; index2++) {
    let result = results[index2];
    let match = matchesToLoad[index2];
    if (!match) {
      continue;
    }
    let currentMatch = currentMatches.find((m2) => m2.route.id === match.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== void 0;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      let signal = signals[index2];
      invariant(signal, "Expected an AbortSignal for revalidating fetcher deferred result");
      await resolveDeferredData(result, signal, isFetcher).then((result2) => {
        if (result2) {
          results[index2] = result2 || results[index2];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap2) {
  if (unwrap2 === void 0) {
    unwrap2 = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap2) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e2) {
      return {
        type: ResultType.error,
        error: e2
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
}
function createUseMatchesMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data,
      " _hasFetcherDoneAnything ": true
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data,
      " _hasFetcherDoneAnything ": true
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0,
    " _hasFetcherDoneAnything ": true
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data,
    " _hasFetcherDoneAnything ": true
  };
  return fetcher;
}
/**
 * React Router v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to2, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to2, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      navigator2.go(to2);
      return;
    }
    let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
function useOutlet(context) {
  let outlet = reactExports.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to2, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$1({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match.route.errorElement || defaultErrorElement;
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      router.navigate(to2);
    } else {
      router.navigate(to2, _extends$1({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router,
    future
  } = _ref;
  let [state, setStateImpl] = reactExports.useState(router.state);
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  let navigator2 = reactExports.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: (n2) => router.navigate(n2),
      push: (to2, state2, opts) => router.navigate(to2, {
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to2, state2, opts) => router.navigate(to2, {
        replace: true,
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = reactExports.useMemo(() => ({
    router,
    navigator: navigator2,
    static: false,
    basename
  }), [router, navigator2, basename]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ reactExports.createElement(Router$2, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2
  }, state.initialized ? /* @__PURE__ */ reactExports.createElement(DataRoutes, {
    routes: router.routes,
    state
  }) : fallbackElement))), null);
}
function DataRoutes(_ref2) {
  let {
    routes,
    state
  } = _ref2;
  return useRoutesImpl(routes, void 0, state);
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router$2(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
new Promise(() => {
});
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    Object.assign(updates, {
      element: /* @__PURE__ */ reactExports.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.ErrorBoundary) {
    Object.assign(updates, {
      errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
/**
 * React Router DOM v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function createBrowserRouter(routes, opts) {
  return createRouter$1({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties
  }).initialize();
}
function createHashRouter(routes, opts) {
  return createRouter$1({
    basename: opts == null ? void 0 : opts.basename,
    future: _extends({}, opts == null ? void 0 : opts.future, {
      v7_prependBasename: true
    }),
    history: createHashHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
    routes,
    mapRouteProperties
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors)
    return null;
  let entries2 = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries2) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e2) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to: to2,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
    absoluteHref = to2;
    if (isBrowser$1) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to2 = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to2, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to2, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to: to2,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path = useResolvedPath(to2, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to: to2
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to2, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to2, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to2, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to2, preventScrollReset, relative]);
}
const SvgMLogo = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 32, height: 32, fill: "none", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M31.232 12.486c-.256-.32-.531-.48-.845-.48-.748 0-1.485.845-1.523.89l-2.867 3.603-.25.32v3.175a4.954 4.954 0 0 1 2.867-.903c1.063 0 2.049.327 2.868.903v-7.188l-.25-.32ZM12.646 11.315c0-.051-.032-.537-.23-1.005-.25-.601-.634-.896-1.171-.896h-.25L.806 22.336c-.985 1.229-.736 3.034.493 4.013 1.229.979 3.117.736 4.013-.493l7.328-9.3v-5.24h.006Z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m26.323 6.06-7.706 9.754.084-7.865c.083-2.784-3.444-4.013-5.165-1.805l-2.298 2.95c1.639 0 1.722 2.215 1.722 2.215v12.947c0 2.707 3.443 3.936 5.081 1.805l7.706-9.754 2.867-3.603s1.639-1.965 2.867-.41V7.95c.007-2.874-3.436-3.936-5.158-1.888ZM28.784 21.14h-.25a3.114 3.114 0 1 0 0 6.226h.25a3.114 3.114 0 1 0 0-6.227Z" }));
const UniversalSearch = () => {
  const location = useLocation();
  console.log("universal search location:", location);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-0 h-10 max-w-2xl flex-grow rounded-xl  md:mx-2 lg:mx-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      className: "h-full w-full rounded-xl bg-transparent px-4 py-2",
      placeholder: "Search..."
    }
  ) });
};
const Nav = () => {
  const rootStore = useRootStore();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sticky top-0 z-[9999] flex w-full items-center justify-center px-6 py-3 backdrop-blur", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NavLink, { to: "/", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "neu", block: false, className: "rounded-full p-[15px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SvgMLogo,
      {
        height: 32,
        width: 32,
        className: "fill-darkbg dark:fill-lightbg",
        opacity: 0.8
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center px-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(NavLink, { to: "/billers", className: "px-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-sm font-semibold", children: "Vendors" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(NavLink, { to: "/invoices", className: "px-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-sm font-semibold", children: "Invoices" }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(UniversalSearch, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-8 flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: rootStore?.beacon?.user.name.length ? rootStore.beacon.user.name : "Ibrahim Ali" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "-mt-1 text-[0.6rem]", children: [
          "ID: ",
          rootStore?.beacon?.user.id.length ? rootStore.beacon.user.id : "12345619"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        NavLink,
        {
          to: "/me",
          className: "ml-2 flex h-12 w-12 items-center justify-center rounded-full border border-blue-950/50 text-lg transition-all duration-100  hover:ring hover:ring-blue-500/10 dark:border-purple-100/20",
          children: "IA"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        NavLink,
        {
          to: "/organization",
          className: "ml-4 flex h-12 w-12 items-center justify-center rounded-xl border border-blue-950/50 text-lg font-bold transition-all duration-100 hover:ring hover:ring-blue-500/10 dark:border-blue-100/20",
          children: "T"
        }
      )
    ] })
  ] });
};
const GlobalErrorContext = reactExports.createContext({
  globalError: null,
  setGlobalError: noop$2
});
const GlobalErrorProvider = GlobalErrorContext.Provider;
const GlobalLoadingContext = reactExports.createContext(
  new LoaderModel$1({})
);
const GlobalLoadingProvider = GlobalLoadingContext.Provider;
const useGlobalLoading = () => reactExports.useContext(GlobalLoadingContext);
const GlobalContextProvider = ({
  children
}) => {
  const root = useRootStore();
  const [globalError, setGlobalError] = reactExports.useState(null);
  const globalLoader = root.global.loader;
  const { loading, meta, canCancel, deactivateLoadingState } = globalLoader;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalErrorProvider, { value: { globalError, setGlobalError }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GlobalLoadingProvider, { value: globalLoader, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      LoadingScreen,
      {
        show: loading,
        loadingMeta: meta,
        cancellable: canCancel,
        close: deactivateLoadingState
      }
    ),
    children
  ] }) });
};
const GlobalContextProvider$1 = observer(GlobalContextProvider);
const kvStore = {
  get: (key) => isE ? window.api.store.get(key) : window.localStorage.getItem(key),
  set: (key, value) => isE ? window.api.store.set(key, value) : window.localStorage.setItem(key, JSON.stringify(value)),
  has: (k2) => isE ? window.api.store.has(k2) : !!window.localStorage.getItem(k2)
};
var EPHEMERAL_KEYS = /* @__PURE__ */ ((EPHEMERAL_KEYS2) => {
  EPHEMERAL_KEYS2["PREV_SESSION"] = "SIGN";
  EPHEMERAL_KEYS2["ONBOARDING"] = "ONB_CMP";
  EPHEMERAL_KEYS2["NOAUTH_DATA"] = "NOAU_D";
  return EPHEMERAL_KEYS2;
})(EPHEMERAL_KEYS || {});
const getEphData = (key) => window.localStorage.getItem(key);
const modelName = (model2) => `${"b34c0n_R00T"}:${model2}`;
const getModelData = (model2) => kvStore.get(modelName(model2));
const setModelData = (model2, data) => kvStore.set(modelName(model2), data);
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: true });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  });
};
const resolveFetch$3 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => import("./index-d462ccd2.js"), true ? [] : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
class FunctionsError extends Error {
  constructor(message, name2 = "FunctionsError", context) {
    super(message);
    this.name = name2;
    this.context = context;
  }
}
class FunctionsFetchError extends FunctionsError {
  constructor(context) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
  }
}
class FunctionsRelayError extends FunctionsError {
  constructor(context) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
  }
}
class FunctionsHttpError extends FunctionsError {
  constructor(context) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
  }
}
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class FunctionsClient {
  constructor(url, { headers: headers2 = {}, customFetch } = {}) {
    this.url = url;
    this.headers = headers2;
    this.fetch = resolveFetch$3(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a2;
    return __awaiter$9(this, void 0, void 0, function* () {
      try {
        const { headers: headers2, method, body: functionArgs } = options;
        let _headers = {};
        let body;
        if (functionArgs && (headers2 && !Object.prototype.hasOwnProperty.call(headers2, "Content-Type") || !headers2)) {
          if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            _headers["Content-Type"] = "application/octet-stream";
            body = functionArgs;
          } else if (typeof functionArgs === "string") {
            _headers["Content-Type"] = "text/plain";
            body = functionArgs;
          } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
            body = functionArgs;
          } else {
            _headers["Content-Type"] = "application/json";
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers2),
          body
        }).catch((fetchError) => {
          throw new FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get("x-relay-error");
        if (isRelayError && isRelayError === "true") {
          throw new FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new FunctionsHttpError(response);
        }
        let responseType = ((_a2 = response.headers.get("Content-Type")) !== null && _a2 !== void 0 ? _a2 : "text/plain").split(";")[0].trim();
        let data;
        if (responseType === "application/json") {
          data = yield response.json();
        } else if (responseType === "application/octet-stream") {
          data = yield response.blob();
        } else if (responseType === "multipart/form-data") {
          data = yield response.formData();
        } else {
          data = yield response.text();
        }
        return { data, error: null };
      } catch (error) {
        return { data: null, error };
      }
    });
  }
}
var browserPonyfill = { exports: {} };
(function(module, exports) {
  var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
  var __self__ = function() {
    function F3() {
      this.fetch = false;
      this.DOMException = global2.DOMException;
    }
    F3.prototype = global2;
    return new F3();
  }();
  (function(self2) {
    (function(exports2) {
      var support = {
        searchParams: "URLSearchParams" in self2,
        iterable: "Symbol" in self2 && "iterator" in Symbol,
        blob: "FileReader" in self2 && "Blob" in self2 && function() {
          try {
            new Blob();
            return true;
          } catch (e2) {
            return false;
          }
        }(),
        formData: "FormData" in self2,
        arrayBuffer: "ArrayBuffer" in self2
      };
      function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      }
      if (support.arrayBuffer) {
        var viewClasses = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
          return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
      }
      function normalizeName(name2) {
        if (typeof name2 !== "string") {
          name2 = String(name2);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
          throw new TypeError("Invalid character in header field name");
        }
        return name2.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== "string") {
          value = String(value);
        }
        return value;
      }
      function iteratorFor(items2) {
        var iterator = {
          next: function() {
            var value = items2.shift();
            return { done: value === void 0, value };
          }
        };
        if (support.iterable) {
          iterator[Symbol.iterator] = function() {
            return iterator;
          };
        }
        return iterator;
      }
      function Headers2(headers2) {
        this.map = {};
        if (headers2 instanceof Headers2) {
          headers2.forEach(function(value, name2) {
            this.append(name2, value);
          }, this);
        } else if (Array.isArray(headers2)) {
          headers2.forEach(function(header) {
            this.append(header[0], header[1]);
          }, this);
        } else if (headers2) {
          Object.getOwnPropertyNames(headers2).forEach(function(name2) {
            this.append(name2, headers2[name2]);
          }, this);
        }
      }
      Headers2.prototype.append = function(name2, value) {
        name2 = normalizeName(name2);
        value = normalizeValue(value);
        var oldValue = this.map[name2];
        this.map[name2] = oldValue ? oldValue + ", " + value : value;
      };
      Headers2.prototype["delete"] = function(name2) {
        delete this.map[normalizeName(name2)];
      };
      Headers2.prototype.get = function(name2) {
        name2 = normalizeName(name2);
        return this.has(name2) ? this.map[name2] : null;
      };
      Headers2.prototype.has = function(name2) {
        return this.map.hasOwnProperty(normalizeName(name2));
      };
      Headers2.prototype.set = function(name2, value) {
        this.map[normalizeName(name2)] = normalizeValue(value);
      };
      Headers2.prototype.forEach = function(callback, thisArg) {
        for (var name2 in this.map) {
          if (this.map.hasOwnProperty(name2)) {
            callback.call(thisArg, this.map[name2], name2, this);
          }
        }
      };
      Headers2.prototype.keys = function() {
        var items2 = [];
        this.forEach(function(value, name2) {
          items2.push(name2);
        });
        return iteratorFor(items2);
      };
      Headers2.prototype.values = function() {
        var items2 = [];
        this.forEach(function(value) {
          items2.push(value);
        });
        return iteratorFor(items2);
      };
      Headers2.prototype.entries = function() {
        var items2 = [];
        this.forEach(function(value, name2) {
          items2.push([name2, value]);
        });
        return iteratorFor(items2);
      };
      if (support.iterable) {
        Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
      }
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError("Already read"));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsText(blob);
        return promise;
      }
      function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for (var i2 = 0; i2 < view.length; i2++) {
          chars[i2] = String.fromCharCode(view[i2]);
        }
        return chars.join("");
      }
      function bufferClone(buf) {
        if (buf.slice) {
          return buf.slice(0);
        } else {
          var view = new Uint8Array(buf.byteLength);
          view.set(new Uint8Array(buf));
          return view.buffer;
        }
      }
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (!body) {
            this._bodyText = "";
          } else if (typeof body === "string") {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([this._bodyArrayBuffer]);
          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
          } else {
            this._bodyText = body = Object.prototype.toString.call(body);
          }
          if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
              this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
              this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as blob");
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
            } else {
              return this.blob().then(readBlobAsArrayBuffer);
            }
          };
        }
        this.text = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected;
          }
          if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
          } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
          } else {
            return Promise.resolve(this._bodyText);
          }
        };
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods2.indexOf(upcased) > -1 ? upcased : method;
      }
      function Request2(input, options) {
        options = options || {};
        var body = options.body;
        if (input instanceof Request2) {
          if (input.bodyUsed) {
            throw new TypeError("Already read");
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers2(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          this.signal = input.signal;
          if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || "same-origin";
        if (options.headers || !this.headers) {
          this.headers = new Headers2(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || "GET");
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal;
        this.referrer = null;
        if ((this.method === "GET" || this.method === "HEAD") && body) {
          throw new TypeError("Body not allowed for GET or HEAD requests");
        }
        this._initBody(body);
      }
      Request2.prototype.clone = function() {
        return new Request2(this, { body: this._bodyInit });
      };
      function decode(body) {
        var form = new FormData();
        body.trim().split("&").forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split("=");
            var name2 = split.shift().replace(/\+/g, " ");
            var value = split.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name2), decodeURIComponent(value));
          }
        });
        return form;
      }
      function parseHeaders(rawHeaders) {
        var headers2 = new Headers2();
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
        preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
          var parts = line.split(":");
          var key = parts.shift().trim();
          if (key) {
            var value = parts.join(":").trim();
            headers2.append(key, value);
          }
        });
        return headers2;
      }
      Body.call(Request2.prototype);
      function Response2(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this.type = "default";
        this.status = options.status === void 0 ? 200 : options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = "statusText" in options ? options.statusText : "OK";
        this.headers = new Headers2(options.headers);
        this.url = options.url || "";
        this._initBody(bodyInit);
      }
      Body.call(Response2.prototype);
      Response2.prototype.clone = function() {
        return new Response2(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers2(this.headers),
          url: this.url
        });
      };
      Response2.error = function() {
        var response = new Response2(null, { status: 0, statusText: "" });
        response.type = "error";
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response2.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError("Invalid status code");
        }
        return new Response2(null, { status, headers: { location: url } });
      };
      exports2.DOMException = self2.DOMException;
      try {
        new exports2.DOMException();
      } catch (err) {
        exports2.DOMException = function(message, name2) {
          this.message = message;
          this.name = name2;
          var error = Error(message);
          this.stack = error.stack;
        };
        exports2.DOMException.prototype = Object.create(Error.prototype);
        exports2.DOMException.prototype.constructor = exports2.DOMException;
      }
      function fetch2(input, init2) {
        return new Promise(function(resolve, reject) {
          var request = new Request2(input, init2);
          if (request.signal && request.signal.aborted) {
            return reject(new exports2.DOMException("Aborted", "AbortError"));
          }
          var xhr = new XMLHttpRequest();
          function abortXhr() {
            xhr.abort();
          }
          xhr.onload = function() {
            var options = {
              status: xhr.status,
              statusText: xhr.statusText,
              headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            resolve(new Response2(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.ontimeout = function() {
            reject(new TypeError("Network request failed"));
          };
          xhr.onabort = function() {
            reject(new exports2.DOMException("Aborted", "AbortError"));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === "include") {
            xhr.withCredentials = true;
          } else if (request.credentials === "omit") {
            xhr.withCredentials = false;
          }
          if ("responseType" in xhr && support.blob) {
            xhr.responseType = "blob";
          }
          request.headers.forEach(function(value, name2) {
            xhr.setRequestHeader(name2, value);
          });
          if (request.signal) {
            request.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                request.signal.removeEventListener("abort", abortXhr);
              }
            };
          }
          xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
        });
      }
      fetch2.polyfill = true;
      if (!self2.fetch) {
        self2.fetch = fetch2;
        self2.Headers = Headers2;
        self2.Request = Request2;
        self2.Response = Response2;
      }
      exports2.Headers = Headers2;
      exports2.Request = Request2;
      exports2.Response = Response2;
      exports2.fetch = fetch2;
      Object.defineProperty(exports2, "__esModule", { value: true });
      return exports2;
    })({});
  })(__self__);
  __self__.fetch.ponyfill = true;
  delete __self__.fetch.polyfill;
  var ctx = __self__;
  exports = ctx.fetch;
  exports.default = ctx.fetch;
  exports.fetch = ctx.fetch;
  exports.Headers = ctx.Headers;
  exports.Request = ctx.Request;
  exports.Response = ctx.Response;
  module.exports = exports;
})(browserPonyfill, browserPonyfill.exports);
var browserPonyfillExports = browserPonyfill.exports;
const crossFetch = /* @__PURE__ */ getDefaultExportFromCjs$1(browserPonyfillExports);
class PostgrestBuilder {
  constructor(builder) {
    this.shouldThrowOnError = false;
    this.method = builder.method;
    this.url = builder.url;
    this.headers = builder.headers;
    this.schema = builder.schema;
    this.body = builder.body;
    this.shouldThrowOnError = builder.shouldThrowOnError;
    this.signal = builder.signal;
    this.isMaybeSingle = builder.isMaybeSingle;
    if (builder.fetch) {
      this.fetch = builder.fetch;
    } else if (typeof fetch === "undefined") {
      this.fetch = crossFetch;
    } else {
      this.fetch = fetch;
    }
  }
  /**
   * If there's an error with the query, throwOnError will reject the promise by
   * throwing the error instead of returning it as part of a successful response.
   *
   * {@link https://github.com/supabase/supabase-js/issues/92}
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  then(onfulfilled, onrejected) {
    if (this.schema === void 0)
      ;
    else if (["GET", "HEAD"].includes(this.method)) {
      this.headers["Accept-Profile"] = this.schema;
    } else {
      this.headers["Content-Profile"] = this.schema;
    }
    if (this.method !== "GET" && this.method !== "HEAD") {
      this.headers["Content-Type"] = "application/json";
    }
    const _fetch = this.fetch;
    let res = _fetch(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal
    }).then(async (res2) => {
      var _a2, _b2, _c2;
      let error = null;
      let data = null;
      let count2 = null;
      let status = res2.status;
      let statusText = res2.statusText;
      if (res2.ok) {
        if (this.method !== "HEAD") {
          const body = await res2.text();
          if (body === "")
            ;
          else if (this.headers["Accept"] === "text/csv") {
            data = body;
          } else if (this.headers["Accept"] && this.headers["Accept"].includes("application/vnd.pgrst.plan+text")) {
            data = body;
          } else {
            data = JSON.parse(body);
          }
        }
        const countHeader = (_a2 = this.headers["Prefer"]) === null || _a2 === void 0 ? void 0 : _a2.match(/count=(exact|planned|estimated)/);
        const contentRange = (_b2 = res2.headers.get("content-range")) === null || _b2 === void 0 ? void 0 : _b2.split("/");
        if (countHeader && contentRange && contentRange.length > 1) {
          count2 = parseInt(contentRange[1]);
        }
        if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
          if (data.length > 1) {
            error = {
              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
              code: "PGRST116",
              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
              hint: null,
              message: "JSON object requested, multiple (or no) rows returned"
            };
            data = null;
            count2 = null;
            status = 406;
            statusText = "Not Acceptable";
          } else if (data.length === 1) {
            data = data[0];
          } else {
            data = null;
          }
        }
      } else {
        const body = await res2.text();
        try {
          error = JSON.parse(body);
          if (Array.isArray(error) && res2.status === 404) {
            data = [];
            error = null;
            status = 200;
            statusText = "OK";
          }
        } catch (_d2) {
          if (res2.status === 404 && body === "") {
            status = 204;
            statusText = "No Content";
          } else {
            error = {
              message: body
            };
          }
        }
        if (error && this.isMaybeSingle && ((_c2 = error === null || error === void 0 ? void 0 : error.details) === null || _c2 === void 0 ? void 0 : _c2.includes("Results contain 0 rows"))) {
          error = null;
          status = 200;
          statusText = "OK";
        }
        if (error && this.shouldThrowOnError) {
          throw error;
        }
      }
      const postgrestResponse = {
        error,
        data,
        count: count2,
        status,
        statusText
      };
      return postgrestResponse;
    });
    if (!this.shouldThrowOnError) {
      res = res.catch((fetchError) => {
        var _a2, _b2, _c2;
        return {
          error: {
            message: `${(_a2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a2 !== void 0 ? _a2 : "FetchError"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
            details: `${(_b2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b2 !== void 0 ? _b2 : ""}`,
            hint: "",
            code: `${(_c2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c2 !== void 0 ? _c2 : ""}`
          },
          data: null,
          count: null,
          status: 0,
          statusText: ""
        };
      });
    }
    return res.then(onfulfilled, onrejected);
  }
}
class PostgrestTransformBuilder extends PostgrestBuilder {
  /**
   * Perform a SELECT on the query result.
   *
   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
   * return modified rows. By calling this method, modified rows are returned in
   * `data`.
   *
   * @param columns - The columns to retrieve, separated by commas
   */
  select(columns) {
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c2) => {
      if (/\s/.test(c2) && !quoted) {
        return "";
      }
      if (c2 === '"') {
        quoted = !quoted;
      }
      return c2;
    }).join("");
    this.url.searchParams.set("select", cleanedColumns);
    if (this.headers["Prefer"]) {
      this.headers["Prefer"] += ",";
    }
    this.headers["Prefer"] += "return=representation";
    return this;
  }
  /**
   * Order the query result by `column`.
   *
   * You can call this method multiple times to order by multiple columns.
   *
   * You can order foreign tables, but it doesn't affect the ordering of the
   * current table.
   *
   * @param column - The column to order by
   * @param options - Named parameters
   * @param options.ascending - If `true`, the result will be in ascending order
   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
   * `null`s appear last.
   * @param options.foreignTable - Set this to order a foreign table by foreign
   * columns
   */
  order(column, { ascending = true, nullsFirst, foreignTable } = {}) {
    const key = foreignTable ? `${foreignTable}.order` : "order";
    const existingOrder = this.url.searchParams.get(key);
    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === void 0 ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
    return this;
  }
  /**
   * Limit the query result by `count`.
   *
   * @param count - The maximum number of rows to return
   * @param options - Named parameters
   * @param options.foreignTable - Set this to limit rows of foreign tables
   * instead of the current table
   */
  limit(count2, { foreignTable } = {}) {
    const key = typeof foreignTable === "undefined" ? "limit" : `${foreignTable}.limit`;
    this.url.searchParams.set(key, `${count2}`);
    return this;
  }
  /**
   * Limit the query result by starting at an offset (`from`) and ending at the offset (`from + to`).
   * Only records within this range are returned.
   * This respects the query order and if there is no order clause the range could behave unexpectedly.
   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
   * and fourth rows of the query.
   *
   * @param from - The starting index from which to limit the result
   * @param to - The last index to which to limit the result
   * @param options - Named parameters
   * @param options.foreignTable - Set this to limit rows of foreign tables
   * instead of the current table
   */
  range(from, to2, { foreignTable } = {}) {
    const keyOffset = typeof foreignTable === "undefined" ? "offset" : `${foreignTable}.offset`;
    const keyLimit = typeof foreignTable === "undefined" ? "limit" : `${foreignTable}.limit`;
    this.url.searchParams.set(keyOffset, `${from}`);
    this.url.searchParams.set(keyLimit, `${to2 - from + 1}`);
    return this;
  }
  /**
   * Set the AbortSignal for the fetch request.
   *
   * @param signal - The AbortSignal to use for the fetch request
   */
  abortSignal(signal) {
    this.signal = signal;
    return this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be one row (e.g. using `.limit(1)`), otherwise this
   * returns an error.
   */
  single() {
    this.headers["Accept"] = "application/vnd.pgrst.object+json";
    return this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
   * this returns an error.
   */
  maybeSingle() {
    if (this.method === "GET") {
      this.headers["Accept"] = "application/json";
    } else {
      this.headers["Accept"] = "application/vnd.pgrst.object+json";
    }
    this.isMaybeSingle = true;
    return this;
  }
  /**
   * Return `data` as a string in CSV format.
   */
  csv() {
    this.headers["Accept"] = "text/csv";
    return this;
  }
  /**
   * Return `data` as an object in [GeoJSON](https://geojson.org) format.
   */
  geojson() {
    this.headers["Accept"] = "application/geo+json";
    return this;
  }
  /**
   * Return `data` as the EXPLAIN plan for the query.
   *
   * @param options - Named parameters
   *
   * @param options.analyze - If `true`, the query will be executed and the
   * actual run time will be returned
   *
   * @param options.verbose - If `true`, the query identifier will be returned
   * and `data` will include the output columns of the query
   *
   * @param options.settings - If `true`, include information on configuration
   * parameters that affect query planning
   *
   * @param options.buffers - If `true`, include information on buffer usage
   *
   * @param options.wal - If `true`, include information on WAL record generation
   *
   * @param options.format - The format of the output, can be `"text"` (default)
   * or `"json"`
   */
  explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
    const options = [
      analyze ? "analyze" : null,
      verbose ? "verbose" : null,
      settings ? "settings" : null,
      buffers ? "buffers" : null,
      wal ? "wal" : null
    ].filter(Boolean).join("|");
    const forMediatype = this.headers["Accept"];
    this.headers["Accept"] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
    if (format === "json")
      return this;
    else
      return this;
  }
  /**
   * Rollback the query.
   *
   * `data` will still be returned, but the query is not committed.
   */
  rollback() {
    var _a2;
    if (((_a2 = this.headers["Prefer"]) !== null && _a2 !== void 0 ? _a2 : "").trim().length > 0) {
      this.headers["Prefer"] += ",tx=rollback";
    } else {
      this.headers["Prefer"] = "tx=rollback";
    }
    return this;
  }
  /**
   * Override the type of the returned `data`.
   *
   * @typeParam NewResult - The new result type to override with
   */
  returns() {
    return this;
  }
}
class PostgrestFilterBuilder extends PostgrestTransformBuilder {
  /**
   * Match only rows where `column` is equal to `value`.
   *
   * To check if the value of `column` is NULL, you should use `.is()` instead.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  eq(column, value) {
    this.url.searchParams.append(column, `eq.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is not equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  neq(column, value) {
    this.url.searchParams.append(column, `neq.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is greater than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gt(column, value) {
    this.url.searchParams.append(column, `gt.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is greater than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gte(column, value) {
    this.url.searchParams.append(column, `gte.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is less than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lt(column, value) {
    this.url.searchParams.append(column, `lt.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is less than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lte(column, value) {
    this.url.searchParams.append(column, `lte.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-sensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  like(column, pattern) {
    this.url.searchParams.append(column, `like.${pattern}`);
    return this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAllOf(column, patterns) {
    this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-insensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  ilike(column, pattern) {
    this.url.searchParams.append(column, `ilike.${pattern}`);
    return this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAllOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
    return this;
  }
  /**
   * Match only rows where `column` IS `value`.
   *
   * For non-boolean columns, this is only relevant for checking if the value of
   * `column` is NULL by setting `value` to `null`.
   *
   * For boolean columns, you can also set `value` to `true` or `false` and it
   * will behave the same way as `.eq()`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  is(column, value) {
    this.url.searchParams.append(column, `is.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is included in the `values` array.
   *
   * @param column - The column to filter on
   * @param values - The values array to filter with
   */
  in(column, values2) {
    const cleanedValues = values2.map((s2) => {
      if (typeof s2 === "string" && new RegExp("[,()]").test(s2))
        return `"${s2}"`;
      else
        return `${s2}`;
    }).join(",");
    this.url.searchParams.append(column, `in.(${cleanedValues})`);
    return this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * `column` contains every element appearing in `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  contains(column, value) {
    if (typeof value === "string") {
      this.url.searchParams.append(column, `cs.${value}`);
    } else if (Array.isArray(value)) {
      this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
    } else {
      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
    }
    return this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * every element appearing in `column` is contained by `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  containedBy(column, value) {
    if (typeof value === "string") {
      this.url.searchParams.append(column, `cd.${value}`);
    } else if (Array.isArray(value)) {
      this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
    } else {
      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
    }
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is greater than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGt(column, range) {
    this.url.searchParams.append(column, `sr.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or greater than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGte(column, range) {
    this.url.searchParams.append(column, `nxl.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is less than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLt(column, range) {
    this.url.searchParams.append(column, `sl.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or less than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLte(column, range) {
    this.url.searchParams.append(column, `nxr.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where `column` is
   * mutually exclusive to `range` and there can be no element between the two
   * ranges.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeAdjacent(column, range) {
    this.url.searchParams.append(column, `adj.${range}`);
    return this;
  }
  /**
   * Only relevant for array and range columns. Match only rows where
   * `column` and `value` have an element in common.
   *
   * @param column - The array or range column to filter on
   * @param value - The array or range value to filter with
   */
  overlaps(column, value) {
    if (typeof value === "string") {
      this.url.searchParams.append(column, `ov.${value}`);
    } else {
      this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
    }
    return this;
  }
  /**
   * Only relevant for text and tsvector columns. Match only rows where
   * `column` matches the query string in `query`.
   *
   * @param column - The text or tsvector column to filter on
   * @param query - The query text to match with
   * @param options - Named parameters
   * @param options.config - The text search configuration to use
   * @param options.type - Change how the `query` text is interpreted
   */
  textSearch(column, query, { config: config2, type } = {}) {
    let typePart = "";
    if (type === "plain") {
      typePart = "pl";
    } else if (type === "phrase") {
      typePart = "ph";
    } else if (type === "websearch") {
      typePart = "w";
    }
    const configPart = config2 === void 0 ? "" : `(${config2})`;
    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
    return this;
  }
  /**
   * Match only rows where each column in `query` keys is equal to its
   * associated value. Shorthand for multiple `.eq()`s.
   *
   * @param query - The object to filter with, with column names as keys mapped
   * to their filter values
   */
  match(query) {
    Object.entries(query).forEach(([column, value]) => {
      this.url.searchParams.append(column, `eq.${value}`);
    });
    return this;
  }
  /**
   * Match only rows which doesn't satisfy the filter.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to be negated to filter with, following
   * PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  not(column, operator, value) {
    this.url.searchParams.append(column, `not.${operator}.${value}`);
    return this;
  }
  /**
   * Match only rows which satisfy at least one of the filters.
   *
   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure it's properly sanitized.
   *
   * It's currently not possible to do an `.or()` filter across multiple tables.
   *
   * @param filters - The filters to use, following PostgREST syntax
   * @param foreignTable - Set this to filter on foreign tables instead of the
   * current table
   */
  or(filters, { foreignTable } = {}) {
    const key = foreignTable ? `${foreignTable}.or` : "or";
    this.url.searchParams.append(key, `(${filters})`);
    return this;
  }
  /**
   * Match only rows which satisfy the filter. This is an escape hatch - you
   * should use the specific filter methods wherever possible.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to filter with, following PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  filter(column, operator, value) {
    this.url.searchParams.append(column, `${operator}.${value}`);
    return this;
  }
}
class PostgrestQueryBuilder {
  constructor(url, { headers: headers2 = {}, schema, fetch: fetch2 }) {
    this.url = url;
    this.headers = headers2;
    this.schema = schema;
    this.fetch = fetch2;
  }
  /**
   * Perform a SELECT query on the table or view.
   *
   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
   *
   * @param options - Named parameters
   *
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   *
   * @param options.count - Count algorithm to use to count rows in the table or view.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  select(columns, { head = false, count: count2 } = {}) {
    const method = head ? "HEAD" : "GET";
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : "*").split("").map((c2) => {
      if (/\s/.test(c2) && !quoted) {
        return "";
      }
      if (c2 === '"') {
        quoted = !quoted;
      }
      return c2;
    }).join("");
    this.url.searchParams.set("select", cleanedColumns);
    if (count2) {
      this.headers["Prefer"] = `count=${count2}`;
    }
    return new PostgrestFilterBuilder({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an INSERT into the table or view.
   *
   * By default, inserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to insert. Pass an object to insert a single row
   * or an array to insert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count inserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. Only applies for bulk
   * inserts.
   */
  insert(values2, { count: count2, defaultToNull = true } = {}) {
    const method = "POST";
    const prefersHeaders = [];
    if (this.headers["Prefer"]) {
      prefersHeaders.push(this.headers["Prefer"]);
    }
    if (count2) {
      prefersHeaders.push(`count=${count2}`);
    }
    if (!defaultToNull) {
      prefersHeaders.push("missing=default");
    }
    this.headers["Prefer"] = prefersHeaders.join(",");
    if (Array.isArray(values2)) {
      const columns = values2.reduce((acc, x2) => acc.concat(Object.keys(x2)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
        this.url.searchParams.set("columns", uniqueColumns.join(","));
      }
    }
    return new PostgrestFilterBuilder({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values2,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an UPSERT on the table or view. Depending on the column(s) passed
   * to `onConflict`, `.upsert()` allows you to perform the equivalent of
   * `.insert()` if a row with the corresponding `onConflict` columns doesn't
   * exist, or if it does exist, perform an alternative action depending on
   * `ignoreDuplicates`.
   *
   * By default, upserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to upsert with. Pass an object to upsert a
   * single row or an array to upsert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
   * duplicate rows are determined. Two rows are duplicates if all the
   * `onConflict` columns are equal.
   *
   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
   * `false`, duplicate rows are merged with existing rows.
   *
   * @param options.count - Count algorithm to use to count upserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. This only applies when
   * inserting new rows, not when merging with existing rows under
   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
   */
  upsert(values2, { onConflict, ignoreDuplicates = false, count: count2, defaultToNull = true } = {}) {
    const method = "POST";
    const prefersHeaders = [`resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`];
    if (onConflict !== void 0)
      this.url.searchParams.set("on_conflict", onConflict);
    if (this.headers["Prefer"]) {
      prefersHeaders.push(this.headers["Prefer"]);
    }
    if (count2) {
      prefersHeaders.push(`count=${count2}`);
    }
    if (!defaultToNull) {
      prefersHeaders.push("missing=default");
    }
    this.headers["Prefer"] = prefersHeaders.join(",");
    if (Array.isArray(values2)) {
      const columns = values2.reduce((acc, x2) => acc.concat(Object.keys(x2)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
        this.url.searchParams.set("columns", uniqueColumns.join(","));
      }
    }
    return new PostgrestFilterBuilder({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values2,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an UPDATE on the table or view.
   *
   * By default, updated rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param values - The values to update with
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count updated rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  update(values2, { count: count2 } = {}) {
    const method = "PATCH";
    const prefersHeaders = [];
    if (this.headers["Prefer"]) {
      prefersHeaders.push(this.headers["Prefer"]);
    }
    if (count2) {
      prefersHeaders.push(`count=${count2}`);
    }
    this.headers["Prefer"] = prefersHeaders.join(",");
    return new PostgrestFilterBuilder({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values2,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform a DELETE on the table or view.
   *
   * By default, deleted rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count deleted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  delete({ count: count2 } = {}) {
    const method = "DELETE";
    const prefersHeaders = [];
    if (count2) {
      prefersHeaders.push(`count=${count2}`);
    }
    if (this.headers["Prefer"]) {
      prefersHeaders.unshift(this.headers["Prefer"]);
    }
    this.headers["Prefer"] = prefersHeaders.join(",");
    return new PostgrestFilterBuilder({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
}
const version$6 = "1.8.2";
const DEFAULT_HEADERS$4 = { "X-Client-Info": `postgrest-js/${version$6}` };
class PostgrestClient {
  // TODO: Add back shouldThrowOnError once we figure out the typings
  /**
   * Creates a PostgREST client.
   *
   * @param url - URL of the PostgREST endpoint
   * @param options - Named parameters
   * @param options.headers - Custom headers
   * @param options.schema - Postgres schema to switch to
   * @param options.fetch - Custom fetch
   */
  constructor(url, { headers: headers2 = {}, schema, fetch: fetch2 } = {}) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$4), headers2);
    this.schemaName = schema;
    this.fetch = fetch2;
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    const url = new URL(`${this.url}/${relation}`);
    return new PostgrestQueryBuilder(url, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch
    });
  }
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return new PostgrestClient(this.url, {
      headers: this.headers,
      schema,
      fetch: this.fetch
    });
  }
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, { head = false, count: count2 } = {}) {
    let method;
    const url = new URL(`${this.url}/rpc/${fn}`);
    let body;
    if (head) {
      method = "HEAD";
      Object.entries(args).forEach(([name2, value]) => {
        url.searchParams.append(name2, `${value}`);
      });
    } else {
      method = "POST";
      body = args;
    }
    const headers2 = Object.assign({}, this.headers);
    if (count2) {
      headers2["Prefer"] = `count=${count2}`;
    }
    return new PostgrestFilterBuilder({
      method,
      url,
      headers: headers2,
      schema: this.schemaName,
      body,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
}
var global$1;
var hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal)
    return global$1;
  hasRequiredGlobal = 1;
  var naiveFallback = function() {
    if (typeof self === "object" && self)
      return self;
    if (typeof window === "object" && window)
      return window;
    throw new Error("Unable to resolve global `this`");
  };
  global$1 = function() {
    if (this)
      return this;
    if (typeof globalThis === "object" && globalThis)
      return globalThis;
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function() {
          return this;
        },
        configurable: true
      });
    } catch (error) {
      return naiveFallback();
    }
    try {
      if (!__global__)
        return naiveFallback();
      return __global__;
    } finally {
      delete Object.prototype.__global__;
    }
  }();
  return global$1;
}
const name = "websocket";
const description = "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.";
const keywords = [
  "websocket",
  "websockets",
  "socket",
  "networking",
  "comet",
  "push",
  "RFC-6455",
  "realtime",
  "server",
  "client"
];
const author = "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)";
const contributors = [
  "Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
];
const version$5 = "1.0.34";
const repository = {
  type: "git",
  url: "https://github.com/theturtle32/WebSocket-Node.git"
};
const homepage = "https://github.com/theturtle32/WebSocket-Node";
const engines = {
  node: ">=4.0.0"
};
const dependencies = {
  bufferutil: "^4.0.1",
  debug: "^2.2.0",
  "es5-ext": "^0.10.50",
  "typedarray-to-buffer": "^3.1.5",
  "utf-8-validate": "^5.0.2",
  yaeti: "^0.0.6"
};
const devDependencies = {
  "buffer-equal": "^1.0.0",
  gulp: "^4.0.2",
  "gulp-jshint": "^2.0.4",
  "jshint-stylish": "^2.2.1",
  jshint: "^2.0.0",
  tape: "^4.9.1"
};
const config = {
  verbose: false
};
const scripts = {
  test: "tape test/unit/*.js",
  gulp: "gulp"
};
const main = "index";
const directories = {
  lib: "./lib"
};
const browser$1 = "lib/browser.js";
const license = "Apache-2.0";
const require$$0 = {
  name,
  description,
  keywords,
  author,
  contributors,
  version: version$5,
  repository,
  homepage,
  engines,
  dependencies,
  devDependencies,
  config,
  scripts,
  main,
  directories,
  browser: browser$1,
  license
};
var version$4 = require$$0.version;
var _globalThis;
if (typeof globalThis === "object") {
  _globalThis = globalThis;
} else {
  try {
    _globalThis = requireGlobal();
  } catch (error) {
  } finally {
    if (!_globalThis && typeof window !== "undefined") {
      _globalThis = window;
    }
    if (!_globalThis) {
      throw new Error("Could not determine global this");
    }
  }
}
var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = version$4;
function W3CWebSocket(uri, protocols) {
  var native_instance;
  if (protocols) {
    native_instance = new NativeWebSocket(uri, protocols);
  } else {
    native_instance = new NativeWebSocket(uri);
  }
  return native_instance;
}
if (NativeWebSocket) {
  ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop2) {
    Object.defineProperty(W3CWebSocket, prop2, {
      get: function() {
        return NativeWebSocket[prop2];
      }
    });
  });
}
var browser = {
  "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
  "version": websocket_version
};
const version$3 = "2.7.4";
const DEFAULT_HEADERS$3 = { "X-Client-Info": `realtime-js/${version$3}` };
const VSN = "1.0.0";
const DEFAULT_TIMEOUT = 1e4;
const WS_CLOSE_NORMAL = 1e3;
var SOCKET_STATES;
(function(SOCKET_STATES2) {
  SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
  SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
  SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
  SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES2) {
  CHANNEL_STATES2["closed"] = "closed";
  CHANNEL_STATES2["errored"] = "errored";
  CHANNEL_STATES2["joined"] = "joined";
  CHANNEL_STATES2["joining"] = "joining";
  CHANNEL_STATES2["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS2) {
  CHANNEL_EVENTS2["close"] = "phx_close";
  CHANNEL_EVENTS2["error"] = "phx_error";
  CHANNEL_EVENTS2["join"] = "phx_join";
  CHANNEL_EVENTS2["reply"] = "phx_reply";
  CHANNEL_EVENTS2["leave"] = "phx_leave";
  CHANNEL_EVENTS2["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS2) {
  TRANSPORTS2["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE2) {
  CONNECTION_STATE2["Connecting"] = "connecting";
  CONNECTION_STATE2["Open"] = "open";
  CONNECTION_STATE2["Closing"] = "closing";
  CONNECTION_STATE2["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));
class Timer {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = void 0;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
class Serializer {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === "string") {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset2 = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset2, offset2 + topicSize));
    offset2 = offset2 + topicSize;
    const event = decoder.decode(buffer.slice(offset2, offset2 + eventSize));
    offset2 = offset2 + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset2, buffer.byteLength)));
    return { ref: null, topic, event, payload: data };
  }
}
class Push {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = void 0;
    this.ref = "";
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
    this.rateLimited = false;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = "";
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived("timeout")) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    const status = this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
    if (status === "rate limited") {
      this.rateLimited = true;
    }
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a2;
    if (this._hasReceived(status)) {
      callback((_a2 = this.receivedResp) === null || _a2 === void 0 ? void 0 : _a2.response);
    }
    this.recHooks.push({ status, callback });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = (payload) => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent)
      this.channel._trigger(this.refEvent, { status, response });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = void 0;
  }
  _matchReceive({ status, response }) {
    this.recHooks.filter((h2) => h2.status === status).forEach((h2) => h2.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
}
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
  REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
class RealtimePresence {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(events.state, {}, (newState) => {
      const { onJoin, onLeave, onSync } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach((diff) => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, (diff) => {
      const { onJoin, onLeave, onSync } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger("presence", {
        event: "join",
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger("presence", {
        event: "leave",
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map((m2) => m2.presence_ref);
        const curPresenceRefs = currentPresences.map((m2) => m2.presence_ref);
        const joinedPresences = newPresences.filter((m2) => curPresenceRefs.indexOf(m2.presence_ref) < 0);
        const leftPresences = currentPresences.filter((m2) => newPresenceRefs.indexOf(m2.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const { joins, leaves } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {
      };
    }
    if (!onLeave) {
      onLeave = () => {
      };
    }
    this.map(joins, (key, newPresences) => {
      var _a2;
      const currentPresences = (_a2 = state[key]) !== null && _a2 !== void 0 ? _a2 : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map((m2) => m2.presence_ref);
        const curPresences = currentPresences.filter((m2) => joinedPresenceRefs.indexOf(m2.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences)
        return;
      const presenceRefsToRemove = leftPresences.map((m2) => m2.presence_ref);
      currentPresences = currentPresences.filter((m2) => presenceRefsToRemove.indexOf(m2.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0)
        delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ("metas" in presences) {
        newState[key] = presences.metas.map((presence) => {
          presence["presence_ref"] = presence["phx_ref"];
          delete presence["phx_ref"];
          delete presence["phx_ref_prev"];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var PostgresTypes;
(function(PostgresTypes2) {
  PostgresTypes2["abstime"] = "abstime";
  PostgresTypes2["bool"] = "bool";
  PostgresTypes2["date"] = "date";
  PostgresTypes2["daterange"] = "daterange";
  PostgresTypes2["float4"] = "float4";
  PostgresTypes2["float8"] = "float8";
  PostgresTypes2["int2"] = "int2";
  PostgresTypes2["int4"] = "int4";
  PostgresTypes2["int4range"] = "int4range";
  PostgresTypes2["int8"] = "int8";
  PostgresTypes2["int8range"] = "int8range";
  PostgresTypes2["json"] = "json";
  PostgresTypes2["jsonb"] = "jsonb";
  PostgresTypes2["money"] = "money";
  PostgresTypes2["numeric"] = "numeric";
  PostgresTypes2["oid"] = "oid";
  PostgresTypes2["reltime"] = "reltime";
  PostgresTypes2["text"] = "text";
  PostgresTypes2["time"] = "time";
  PostgresTypes2["timestamp"] = "timestamp";
  PostgresTypes2["timestamptz"] = "timestamptz";
  PostgresTypes2["timetz"] = "timetz";
  PostgresTypes2["tsrange"] = "tsrange";
  PostgresTypes2["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
const convertChangeData = (columns, record, options = {}) => {
  var _a2;
  const skipTypes = (_a2 = options.skipTypes) !== null && _a2 !== void 0 ? _a2 : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
const convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find((x2) => x2.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop$1(value);
};
const convertCell = (type, value) => {
  if (type.charAt(0) === "_") {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    case PostgresTypes.abstime:
    case PostgresTypes.date:
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime:
    case PostgresTypes.text:
    case PostgresTypes.time:
    case PostgresTypes.timestamptz:
    case PostgresTypes.timetz:
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop$1(value);
    default:
      return noop$1(value);
  }
};
const noop$1 = (value) => {
  return value;
};
const toBoolean = (value) => {
  switch (value) {
    case "t":
      return true;
    case "f":
      return false;
    default:
      return value;
  }
};
const toNumber = (value) => {
  if (typeof value === "string") {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
const toJson = (value) => {
  if (typeof value === "string") {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
const toArray = (value, type) => {
  if (typeof value !== "string") {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  if (openBrace === "{" && closeBrace === "}") {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    try {
      arr = JSON.parse("[" + valTrim + "]");
    } catch (_2) {
      arr = valTrim ? valTrim.split(",") : [];
    }
    return arr.map((val) => convertCell(type, val));
  }
  return value;
};
const toTimestampString = (value) => {
  if (typeof value === "string") {
    return value.replace(" ", "T");
  }
  return value;
};
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES2) {
  REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES2) {
  REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
class RealtimeChannel {
  constructor(topic, params = { config: {} }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.params.config = Object.assign({
      broadcast: { ack: false, self: false },
      presence: { key: "" }
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive("ok", () => {
      this.state = CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach((pushEvent) => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
      this.state = CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError((reason) => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log("channel", `error ${this.topic}`, reason);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive("timeout", () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new RealtimePresence(this);
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a2, _b2;
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const { config: { broadcast, presence } } = this.params;
      this._onError((e2) => callback && callback("CHANNEL_ERROR", e2));
      this._onClose(() => callback && callback("CLOSED"));
      const accessTokenPayload = {};
      const config2 = {
        broadcast,
        presence,
        postgres_changes: (_b2 = (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.map((r2) => r2.filter)) !== null && _b2 !== void 0 ? _b2 : []
      };
      if (this.socket.accessToken) {
        accessTokenPayload.access_token = this.socket.accessToken;
      }
      this.updateJoinPayload(Object.assign({ config: config2 }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive("ok", ({ postgres_changes: serverPostgresFilters }) => {
        var _a3;
        this.socket.accessToken && this.socket.setAuth(this.socket.accessToken);
        if (serverPostgresFilters === void 0) {
          callback && callback("SUBSCRIBED");
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a3 = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a3 !== void 0 ? _a3 : 0;
          const newPostgresBindings = [];
          for (let i2 = 0; i2 < bindingsLen; i2++) {
            const clientPostgresBinding = clientPostgresBindings[i2];
            const { filter: { event, schema, table, filter } } = clientPostgresBinding;
            const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i2];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
            } else {
              this.unsubscribe();
              callback && callback("CHANNEL_ERROR", new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback("SUBSCRIBED");
          return;
        }
      }).receive("error", (error) => {
        callback && callback("CHANNEL_ERROR", new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
        return;
      }).receive("timeout", () => {
        callback && callback("TIMED_OUT");
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  track(payload, opts = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return yield this.send({
        type: "presence",
        event: "track",
        payload
      }, opts.timeout || this.timeout);
    });
  }
  untrack(opts = {}) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return yield this.send({
        type: "presence",
        event: "untrack"
      }, opts);
    });
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  send(payload, opts = {}) {
    return new Promise((resolve) => {
      var _a2, _b2, _c2;
      const push2 = this._push(payload.type, payload, opts.timeout || this.timeout);
      if (push2.rateLimited) {
        resolve("rate limited");
      }
      if (payload.type === "broadcast" && !((_c2 = (_b2 = (_a2 = this.params) === null || _a2 === void 0 ? void 0 : _a2.config) === null || _b2 === void 0 ? void 0 : _b2.broadcast) === null || _c2 === void 0 ? void 0 : _c2.ack)) {
        resolve("ok");
      }
      push2.receive("ok", () => resolve("ok"));
      push2.receive("timeout", () => resolve("timed out"));
    });
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log("channel", `leave ${this.topic}`);
      this._trigger(CHANNEL_EVENTS.close, "leave", this._joinRef());
    };
    this.rejoinTimer.reset();
    this.joinPush.destroy();
    return new Promise((resolve) => {
      const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive("ok", () => {
        onClose();
        resolve("ok");
      }).receive("timeout", () => {
        onClose();
        resolve("timed out");
      }).receive("error", () => {
        resolve("error");
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger("ok", {});
      }
    });
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new Push(this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a2, _b2;
    const typeLower = type.toLocaleLowerCase();
    const { close, error, leave, join } = CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    }
    if (["insert", "update", "delete"].includes(typeLower)) {
      (_a2 = this.bindings.postgres_changes) === null || _a2 === void 0 ? void 0 : _a2.filter((bind) => {
        var _a3, _b3, _c2;
        return ((_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event) === "*" || ((_c2 = (_b3 = bind.filter) === null || _b3 === void 0 ? void 0 : _b3.event) === null || _c2 === void 0 ? void 0 : _c2.toLocaleLowerCase()) === typeLower;
      }).map((bind) => bind.callback(handledPayload, ref));
    } else {
      (_b2 = this.bindings[typeLower]) === null || _b2 === void 0 ? void 0 : _b2.filter((bind) => {
        var _a3, _b3, _c2, _d2, _e2, _f2;
        if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
          if ("id" in bind) {
            const bindId = bind.id;
            const bindEvent = (_a3 = bind.filter) === null || _a3 === void 0 ? void 0 : _a3.event;
            return bindId && ((_b3 = payload.ids) === null || _b3 === void 0 ? void 0 : _b3.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c2 = payload.data) === null || _c2 === void 0 ? void 0 : _c2.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e2 = (_d2 = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d2 === void 0 ? void 0 : _d2.event) === null || _e2 === void 0 ? void 0 : _e2.toLocaleLowerCase();
            return bindEvent === "*" || bindEvent === ((_f2 = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f2 === void 0 ? void 0 : _f2.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map((bind) => {
        if (typeof handledPayload === "object" && "ids" in handledPayload) {
          const postgresChanges = handledPayload.data;
          const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
          const enrichedPayload = {
            schema,
            table,
            commit_timestamp,
            eventType: type2,
            new: {},
            old: {},
            errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter,
      callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
      var _a2;
      return !(((_a2 = bind.type) === null || _a2 === void 0 ? void 0 : _a2.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k2 in obj1) {
      if (obj1[k2] !== obj2[k2]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === "INSERT" || payload.type === "UPDATE") {
      records.new = convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === "UPDATE" || payload.type === "DELETE") {
      records.old = convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const noop2 = () => {
};
class RealtimeClient {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   */
  constructor(endPoint, options) {
    var _a2, _b2;
    this.accessToken = null;
    this.channels = [];
    this.endPoint = "";
    this.headers = DEFAULT_HEADERS$3;
    this.params = {};
    this.timeout = DEFAULT_TIMEOUT;
    this.transport = browser.w3cwebsocket;
    this.heartbeatIntervalMs = 3e4;
    this.heartbeatTimer = void 0;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop2;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new Serializer();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.eventsPerSecondLimitMs = 100;
    this.inThrottle = false;
    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
    if (options === null || options === void 0 ? void 0 : options.params)
      this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers)
      this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout)
      this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger)
      this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.transport)
      this.transport = options.transport;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)
      this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const eventsPerSecond = (_a2 = options === null || options === void 0 ? void 0 : options.params) === null || _a2 === void 0 ? void 0 : _a2.eventsPerSecond;
    if (eventsPerSecond)
      this.eventsPerSecondLimitMs = Math.floor(1e3 / eventsPerSecond);
    const accessToken = (_b2 = options === null || options === void 0 ? void 0 : options.params) === null || _b2 === void 0 ? void 0 : _b2.apikey;
    if (accessToken)
      this.accessToken = accessToken;
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries) => {
      return [1e3, 2e3, 5e3, 1e4][tries - 1] || 1e4;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new Timer(() => __awaiter$7(this, void 0, void 0, function* () {
      this.disconnect();
      this.connect();
    }), this.reconnectAfterMs);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);
    if (this.conn) {
      this.conn.binaryType = "arraybuffer";
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function() {
      };
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : "");
      } else {
        this.conn.close();
      }
      this.conn = null;
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  removeChannel(channel) {
    return __awaiter$7(this, void 0, void 0, function* () {
      const status = yield channel.unsubscribe();
      if (this.channels.length === 0) {
        this.disconnect();
      }
      return status;
    });
  }
  /**
   * Unsubscribes and removes all channels
   */
  removeAllChannels() {
    return __awaiter$7(this, void 0, void 0, function* () {
      const values_1 = yield Promise.all(this.channels.map((channel) => channel.unsubscribe()));
      this.disconnect();
      return values_1;
    });
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  channel(topic, params = { config: {} }) {
    if (!this.isConnected()) {
      this.connect();
    }
    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const { topic, event, payload, ref } = data;
    let callback = () => {
      this.encode(data, (result) => {
        var _a2;
        (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.send(result);
      });
    };
    this.log("push", `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      if (["broadcast", "presence", "postgres_changes"].includes(event)) {
        const isThrottled = this._throttle(callback)();
        if (isThrottled) {
          return "rate limited";
        }
      } else {
        callback();
      }
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * @param token A JWT string.
   */
  setAuth(token) {
    this.accessToken = token;
    this.channels.forEach((channel) => {
      token && channel.updateJoinPayload({ access_token: token });
      if (channel.joinedOnce && channel._isJoined()) {
        channel._push(CHANNEL_EVENTS.access_token, { access_token: token });
      }
    });
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find((c2) => c2.topic === topic && (c2._isJoined() || c2._isJoining()));
    if (dupChannel) {
      this.log("transport", `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter((c2) => c2._joinRef() !== channel._joinRef());
  }
  /**
   * Returns the URL of the websocket.
   *
   * @internal
   */
  _endPointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, (msg) => {
      let { topic, event, payload, ref } = msg;
      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {
        this.pendingHeartbeatRef = null;
      }
      this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
      this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach((callback) => callback(msg));
    });
  }
  /** @internal */
  _onConnOpen() {
    this.log("transport", `connected to ${this._endPointURL()}`);
    this._flushSendBuffer();
    this.reconnectTimer.reset();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);
    this.stateChangeCallbacks.open.forEach((callback) => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log("transport", "close", event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach((callback) => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log("transport", error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach((callback) => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? "&" : "?";
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  /** @internal */
  _flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach((callback) => callback());
      this.sendBuffer = [];
    }
  }
  /** @internal */
  _sendHeartbeat() {
    var _a2;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
      (_a2 = this.conn) === null || _a2 === void 0 ? void 0 : _a2.close(WS_CLOSE_NORMAL, "hearbeat timeout");
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: "phoenix",
      event: "heartbeat",
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth(this.accessToken);
  }
  /** @internal */
  _throttle(callback, eventsPerSecondLimitMs = this.eventsPerSecondLimitMs) {
    return () => {
      if (this.inThrottle)
        return true;
      callback();
      if (eventsPerSecondLimitMs > 0) {
        this.inThrottle = true;
        setTimeout(() => {
          this.inThrottle = false;
        }, eventsPerSecondLimitMs);
      }
      return false;
    };
  }
}
class StorageError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = "StorageError";
  }
}
function isStorageError(error) {
  return typeof error === "object" && error !== null && "__isStorageError" in error;
}
class StorageApiError extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = "StorageApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
class StorageUnknownError extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = "StorageUnknownError";
    this.originalError = originalError;
  }
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const resolveFetch$2 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => import("./index-d462ccd2.js"), true ? [] : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveResponse = () => __awaiter$6(void 0, void 0, void 0, function* () {
  if (typeof Response === "undefined") {
    return (yield __vitePreload(() => import("./index-d462ccd2.js"), true ? [] : void 0, import.meta.url)).Response;
  }
  return Response;
});
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const _getErrorMessage$1 = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError$1 = (error, reject) => __awaiter$5(void 0, void 0, void 0, function* () {
  const Res = yield resolveResponse();
  if (error instanceof Res) {
    error.json().then((err) => {
      reject(new StorageApiError(_getErrorMessage$1(err), error.status || 500));
    }).catch((err) => {
      reject(new StorageUnknownError(_getErrorMessage$1(err), err));
    });
  } else {
    reject(new StorageUnknownError(_getErrorMessage$1(error), error));
  }
});
const _getRequestParams$1 = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest$1(fetcher, method, url, options, parameters, body) {
  return __awaiter$5(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result) => {
        if (!result.ok)
          throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson)
          return result;
        return result.json();
      }).then((data) => resolve(data)).catch((error) => handleError$1(error, reject));
    });
  });
}
function get$1(fetcher, url, options, parameters) {
  return __awaiter$5(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "GET", url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter$5(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "POST", url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter$5(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "PUT", url, options, parameters, body);
  });
}
function remove2(fetcher, url, body, options, parameters) {
  return __awaiter$5(this, void 0, void 0, function* () {
    return _handleRequest$1(fetcher, "DELETE", url, options, parameters, body);
  });
}
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
};
const DEFAULT_FILE_OPTIONS = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: false
};
class StorageFileApi {
  constructor(url, headers2 = {}, bucketId, fetch2) {
    this.url = url;
    this.headers = headers2;
    this.bucketId = bucketId;
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        const headers2 = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers2["cache-control"] = `max-age=${options.cacheControl}`;
          headers2["content-type"] = options.contentType;
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body, headers: headers2 }, (options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {}));
        if (res.ok) {
          return {
            data: { path: cleanPath },
            error: null
          };
        } else {
          const error = yield res.json();
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToS3(path, fileBody, fileOptions) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set("token", token);
      try {
        let body;
        const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
        const headers2 = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
        if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
          body = new FormData();
          body.append("cacheControl", options.cacheControl);
          body.append("", fileBody);
        } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
          body = fileBody;
          body.append("cacheControl", options.cacheControl);
        } else {
          body = fileBody;
          headers2["cache-control"] = `max-age=${options.cacheControl}`;
          headers2["content-type"] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: "PUT",
          body,
          headers: headers2
        });
        if (res.ok) {
          return {
            data: { path: cleanPath },
            error: null
          };
        } else {
          const error = yield res.json();
          return { data: null, error };
        }
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   */
  createSignedUploadUrl(path) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const data = yield post(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers: this.headers });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get("token");
        if (!token) {
          throw new StorageError("No token returned by API");
        }
        return { data: { signedUrl: url.toString(), path, token }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   */
  move(fromPath, toPath) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   */
  copy(fromPath, toPath) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });
        return { data: { path: data.Key }, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = { signedUrl };
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
        return {
          data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
          error: null
        };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      try {
        const _path = this._getFinalPath(path);
        const res = yield get$1(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
    if (downloadQueryParam !== "") {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== "undefined";
    const renderPath = wantsTransformation ? "render/image" : "object";
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== "") {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join("&");
    if (queryString !== "") {
      queryString = `?${queryString}`;
    }
    return {
      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const data = yield remove2(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
        const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join("&");
  }
}
const version$2 = "2.5.2";
const DEFAULT_HEADERS$2 = { "X-Client-Info": `storage-js/${version$2}` };
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class StorageBucketApi {
  constructor(url, headers2 = {}, fetch2) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS$2), headers2);
    this.fetch = resolveFetch$2(fetch2);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const data = yield get$1(this.fetch, `${this.url}/bucket`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const data = yield get$1(this.fetch, `${this.url}/bucket/${id2}`, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id2, options = {
    public: false
  }) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket`, {
          id: id2,
          name: id2,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id2, options) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const data = yield put(this.fetch, `${this.url}/bucket/${id2}`, {
          id: id2,
          name: id2,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const data = yield post(this.fetch, `${this.url}/bucket/${id2}/empty`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id2) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const data = yield remove2(this.fetch, `${this.url}/bucket/${id2}`, {}, { headers: this.headers });
        return { data, error: null };
      } catch (error) {
        if (isStorageError(error)) {
          return { data: null, error };
        }
        throw error;
      }
    });
  }
}
class StorageClient extends StorageBucketApi {
  constructor(url, headers2 = {}, fetch2) {
    super(url, headers2, fetch2);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id2) {
    return new StorageFileApi(this.url, this.headers, id2, this.fetch);
  }
}
const version$1 = "2.33.1";
const DEFAULT_HEADERS$1 = { "X-Client-Info": `supabase-js/${version$1}` };
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const resolveFetch$1 = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = crossFetch;
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveHeadersConstructor = () => {
  if (typeof Headers === "undefined") {
    return browserPonyfillExports.Headers;
  }
  return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch2 = resolveFetch$1(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init2) => __awaiter$2(void 0, void 0, void 0, function* () {
    var _a2;
    const accessToken = (_a2 = yield getAccessToken()) !== null && _a2 !== void 0 ? _a2 : supabaseKey;
    let headers2 = new HeadersConstructor(init2 === null || init2 === void 0 ? void 0 : init2.headers);
    if (!headers2.has("apikey")) {
      headers2.set("apikey", supabaseKey);
    }
    if (!headers2.has("Authorization")) {
      headers2.set("Authorization", `Bearer ${accessToken}`);
    }
    return fetch2(input, Object.assign(Object.assign({}, init2), { headers: headers2 }));
  });
};
function stripTrailingSlash(url) {
  return url.replace(/\/$/, "");
}
function applySettingDefaults(options, defaults) {
  const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
  const { db: DEFAULT_DB_OPTIONS2, auth: DEFAULT_AUTH_OPTIONS2, realtime: DEFAULT_REALTIME_OPTIONS2, global: DEFAULT_GLOBAL_OPTIONS2 } = defaults;
  return {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS2), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS2), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS2), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS2), globalOptions)
  };
}
function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1e3);
  return timeNow + expiresIn;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    const r2 = Math.random() * 16 | 0, v2 = c2 == "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
}
const isBrowser = () => typeof document !== "undefined";
const localStorageWriteTests = {
  tested: false,
  writable: false
};
const supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== "object") {
      return false;
    }
  } catch (e2) {
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e2) {
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === "#") {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e2) {
    }
  }
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
const resolveFetch = (customFetch) => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === "undefined") {
    _fetch = (...args) => __vitePreload(() => import("./index-d462ccd2.js"), true ? [] : void 0, import.meta.url).then(({ default: fetch2 }) => fetch2(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const looksLikeFetchResponse = (maybeResponse) => {
  return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
};
const setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
const getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a2) {
    return value;
  }
};
const removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
function decodeBase64URL(value) {
  const key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let base64 = "";
  let chr1, chr2, chr3;
  let enc1, enc2, enc3, enc4;
  let i2 = 0;
  value = value.replace("-", "+").replace("_", "/");
  while (i2 < value.length) {
    enc1 = key.indexOf(value.charAt(i2++));
    enc2 = key.indexOf(value.charAt(i2++));
    enc3 = key.indexOf(value.charAt(i2++));
    enc4 = key.indexOf(value.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    base64 = base64 + String.fromCharCode(chr1);
    if (enc3 != 64 && chr2 != 0) {
      base64 = base64 + String.fromCharCode(chr2);
    }
    if (enc4 != 64 && chr3 != 0) {
      base64 = base64 + String.fromCharCode(chr3);
    }
  }
  return base64;
}
class Deferred {
  constructor() {
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      this.resolve = res;
      this.reject = rej;
    });
  }
}
Deferred.promiseConstructor = Promise;
function decodeJWTPayload(token) {
  const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;
  const parts = token.split(".");
  if (parts.length !== 3) {
    throw new Error("JWT is not valid: not a JWT structure");
  }
  if (!base64UrlRegex.test(parts[1])) {
    throw new Error("JWT is not valid: payload is not in base64url format");
  }
  const base64Url = parts[1];
  return JSON.parse(decodeBase64URL(base64Url));
}
async function sleep(time) {
  return await new Promise((accept) => {
    setTimeout(() => accept(null), time);
  });
}
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e2) {
          if (!isRetryable(attempt, e2)) {
            reject(e2);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ("0" + dec.toString(16)).substr(-2);
}
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array2 = new Uint32Array(verifierLength);
  if (typeof crypto === "undefined") {
    const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    const charSetLen = charSet.length;
    let verifier = "";
    for (let i2 = 0; i2 < verifierLength; i2++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array2);
  return Array.from(array2, dec2hex).join("");
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest("SHA-256", encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map((c2) => String.fromCharCode(c2)).join("");
}
function base64urlencode(str) {
  return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function generatePKCEChallenge(verifier) {
  if (typeof crypto === "undefined") {
    console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
    return verifier;
  }
  const hashed = await sha256(verifier);
  return base64urlencode(hashed);
}
class AuthError extends Error {
  constructor(message, status) {
    super(message);
    this.__isAuthError = true;
    this.name = "AuthError";
    this.status = status;
  }
}
function isAuthError(error) {
  return typeof error === "object" && error !== null && "__isAuthError" in error;
}
class AuthApiError extends AuthError {
  constructor(message, status) {
    super(message, status);
    this.name = "AuthApiError";
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
function isAuthApiError(error) {
  return isAuthError(error) && error.name === "AuthApiError";
}
class AuthUnknownError extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = "AuthUnknownError";
    this.originalError = originalError;
  }
}
class CustomAuthError extends AuthError {
  constructor(message, name2, status) {
    super(message);
    this.name = name2;
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
class AuthSessionMissingError extends CustomAuthError {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400);
  }
}
class AuthInvalidTokenResponseError extends CustomAuthError {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500);
  }
}
class AuthInvalidCredentialsError extends CustomAuthError {
  constructor(message) {
    super(message, "AuthInvalidCredentialsError", 400);
  }
}
class AuthImplicitGrantRedirectError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthImplicitGrantRedirectError", 500);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, "AuthPKCEGrantCodeExchangeError", 500);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class AuthRetryableFetchError extends CustomAuthError {
  constructor(message, status) {
    super(message, "AuthRetryableFetchError", status);
  }
}
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === "AuthRetryableFetchError";
}
var __rest$1 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError(error) {
  if (!looksLikeFetchResponse(error)) {
    throw new AuthRetryableFetchError(_getErrorMessage(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    throw new AuthRetryableFetchError(_getErrorMessage(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e2) {
    throw new AuthUnknownError(_getErrorMessage(e2), e2);
  }
  throw new AuthApiError(_getErrorMessage(data), error.status || 500);
}
const _getRequestParams = (method, options, parameters, body) => {
  const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };
  if (method === "GET") {
    return params;
  }
  params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a2;
  const headers2 = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers2["Authorization"] = `Bearer ${options.jwt}`;
  }
  const qs = (_a2 = options === null || options === void 0 ? void 0 : options.query) !== null && _a2 !== void 0 ? _a2 : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs["redirect_to"] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
  const data = await _handleRequest(fetcher, method, url + queryString, { headers: headers2, noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };
}
async function _handleRequest(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, requestParams);
  } catch (e2) {
    console.error(e2);
    throw new AuthRetryableFetchError(_getErrorMessage(e2), 0);
  }
  if (!result.ok) {
    await handleError(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e2) {
    await handleError(e2);
  }
}
function _sessionResponse(data) {
  var _a2;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    session.expires_at = expiresAt(data.expires_in);
  }
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { session, user }, error: null };
}
function _userResponse(data) {
  var _a2;
  const user = (_a2 = data.user) !== null && _a2 !== void 0 ? _a2 : data;
  return { data: { user }, error: null };
}
function _ssoResponse(data) {
  return { data, error: null };
}
function _generateLinkResponse(data) {
  const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest$1(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}
var __rest = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
class GoTrueAdminApi {
  constructor({ url = "", headers: headers2 = {}, fetch: fetch2 }) {
    this.url = url;
    this.headers = headers2;
    this.fetch = resolveFetch(fetch2);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = "global") {
    try {
      await _request(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return { data: null, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/invite`, {
        body: { email, data: options.data },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const { options } = params, rest = __rest(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ("newEmail" in rest) {
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body["newEmail"];
      }
      return await _request(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body,
        headers: this.headers,
        xform: _generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await _request(this.fetch, "POST", `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g;
    try {
      const pagination = { nextPage: null, lastPage: 0, total: 0 };
      const response = await _request(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b2 = (_a2 = params === null || params === void 0 ? void 0 : params.page) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b2 !== void 0 ? _b2 : "",
          per_page: (_d2 = (_c2 = params === null || params === void 0 ? void 0 : params.perPage) === null || _c2 === void 0 ? void 0 : _c2.toString()) !== null && _d2 !== void 0 ? _d2 : ""
        },
        xform: _noResolveJsonResponse
      });
      if (response.error)
        throw response.error;
      const users = await response.json();
      const total = (_e2 = response.headers.get("x-total-count")) !== null && _e2 !== void 0 ? _e2 : 0;
      const links = (_g = (_f2 = response.headers.get("link")) === null || _f2 === void 0 ? void 0 : _f2.split(",")) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach((link) => {
          const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
          const rel = JSON.parse(link.split(";")[1].split("=")[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return { data: Object.assign(Object.assign({}, users), pagination), error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { users: [] }, error };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await _request(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await _request(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id2, shouldSoftDelete = false) {
    try {
      return await _request(this.fetch, "DELETE", `${this.url}/admin/users/${id2}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _userResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const { data, error } = await _request(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: (factors) => {
          return { data: { factors }, error: null };
        }
      });
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await _request(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return { data, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
}
const version = "2.48.0";
const GOTRUE_URL = "http://localhost:9999";
const STORAGE_KEY = "supabase.auth.token";
const DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version}` };
const EXPIRY_MARGIN = 10;
const localStorageAdapter = {
  getItem: (key) => {
    if (!supportsLocalStorage()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: (key) => {
    if (!supportsLocalStorage()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
function polyfillGlobalThis() {
  if (typeof globalThis === "object")
    return;
  try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  } catch (e2) {
    if (typeof self !== "undefined") {
      self.globalThis = self;
    }
  }
}
polyfillGlobalThis();
const DEFAULT_OPTIONS = {
  url: GOTRUE_URL,
  storageKey: STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: DEFAULT_HEADERS,
  flowType: "implicit",
  debug: false
};
const AUTO_REFRESH_TICK_DURATION = 30 * 1e3;
const AUTO_REFRESH_TICK_THRESHOLD = 3;
async function lockNoOp(name2, acquireTimeout, fn) {
  return await fn();
}
class GoTrueClient {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a2;
    this.stateChangeEmitters = /* @__PURE__ */ new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.lockAcquired = false;
    this.pendingInLock = [];
    this.broadcastChannel = null;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && isBrowser()) {
      console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = settings.debug;
    this.inMemorySession = null;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.persistSession = settings.persistSession;
    this.storage = settings.storage || localStorageAdapter;
    this.admin = new GoTrueAdminApi({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = resolveFetch(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession && this.storage === localStorageAdapter && !supportsLocalStorage()) {
      console.warn(`No storage option exists to persist the session, which may result in unexpected behavior when using auth.
        If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.`);
    }
    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e2) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e2);
      }
      (_a2 = this.broadcastChannel) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("message", async (event) => {
        this._debug("received broadcast notification from other tab or client", event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false);
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      console.log(`GoTrueClient@${this.instanceID} (${version}) ${(/* @__PURE__ */ new Date()).toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    try {
      const isPKCEFlow = isBrowser() ? await this._isPKCEFlow() : false;
      this._debug("#_initialize()", "begin", "is PKCE flow", isPKCEFlow);
      if (isPKCEFlow || this.detectSessionInUrl && this._isImplicitGrantFlow()) {
        const { data, error } = await this._getSessionFromURL(isPKCEFlow);
        if (error) {
          this._debug("#_initialize()", "error detecting session from URL", error);
          await this._removeSession();
          return { error };
        }
        const { session, redirectType } = data;
        this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === "recovery") {
            await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
          } else {
            await this._notifyAllSubscribers("SIGNED_IN", session);
          }
        }, 0);
        return { error: null };
      }
      await this._recoverAndRefresh();
      return { error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { error };
      }
      return {
        error: new AuthUnknownError("Unexpected error during initialization", error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a2, _b2, _c2;
    try {
      await this._removeSession();
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          const codeVerifier = generatePKCEVerifier();
          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
          codeChallenge = await generatePKCEChallenge(codeVerifier);
          codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
        }
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b2 = options === null || options === void 0 ? void 0 : options.data) !== null && _b2 !== void 0 ? _b2 : {},
            channel: (_c2 = options === null || options === void 0 ? void 0 : options.channel) !== null && _c2 !== void 0 ? _c2 : "sms",
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error || !data) {
        return { data: { user: null, session: null }, error };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      await this._removeSession();
      let res;
      if ("email" in credentials) {
        const { email, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else if ("phone" in credentials) {
        const { phone, password, options } = credentials;
        res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          xform: _sessionResponse
        });
      } else {
        throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
      }
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data: { user: data.user, session: data.session }, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a2, _b2, _c2, _d2;
    await this._removeSession();
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a2 = credentials.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo,
      scopes: (_b2 = credentials.options) === null || _b2 === void 0 ? void 0 : _b2.scopes,
      queryParams: (_c2 = credentials.options) === null || _c2 === void 0 ? void 0 : _c2.queryParams,
      skipBrowserRedirect: (_d2 = credentials.options) === null || _d2 === void 0 ? void 0 : _d2.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    const { data, error } = await _request(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
      headers: this.headers,
      body: {
        auth_code: authCode,
        code_verifier: codeVerifier
      },
      xform: _sessionResponse
    });
    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    if (error) {
      return { data: { user: null, session: null }, error };
    } else if (!data || !data.session || !data.user) {
      return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() };
    }
    if (data.session) {
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("SIGNED_IN", data.session);
    }
    return { data, error };
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    await this._removeSession();
    try {
      const { options, provider, token, access_token, nonce } = credentials;
      const res = await _request(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
        },
        xform: _sessionResponse
      });
      const { data, error } = res;
      if (error) {
        return { data: { user: null, session: null }, error };
      } else if (!data || !data.session || !data.user) {
        return {
          data: { user: null, session: null },
          error: new AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("SIGNED_IN", data.session);
      }
      return { data, error };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a2, _b2, _c2, _d2, _e2;
    try {
      await this._removeSession();
      if ("email" in credentials) {
        const { email, options } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          const codeVerifier = generatePKCEVerifier();
          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
          codeChallenge = await generatePKCEChallenge(codeVerifier);
          codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
        }
        const { error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a2 = options === null || options === void 0 ? void 0 : options.data) !== null && _a2 !== void 0 ? _a2 : {},
            create_user: (_b2 = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b2 !== void 0 ? _b2 : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      }
      if ("phone" in credentials) {
        const { phone, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c2 = options === null || options === void 0 ? void 0 : options.data) !== null && _c2 !== void 0 ? _c2 : {},
            create_user: (_d2 = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d2 !== void 0 ? _d2 : true,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },
            channel: (_e2 = options === null || options === void 0 ? void 0 : options.channel) !== null && _e2 !== void 0 ? _e2 : "sms"
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number.");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP received via mobile.
   */
  async verifyOtp(params) {
    var _a2, _b2;
    try {
      if (params.type !== "email_change" && params.type !== "phone_change") {
        await this._removeSession();
      }
      let redirectTo = void 0;
      let captchaToken = void 0;
      if ("options" in params) {
        redirectTo = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo;
        captchaToken = (_b2 = params.options) === null || _b2 === void 0 ? void 0 : _b2.captchaToken;
      }
      const { data, error } = await _request(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
        redirectTo,
        xform: _sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error("An error occurred on token verification.");
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a2, _b2, _c2;
    try {
      await this._removeSession();
      return await _request(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b2 = (_a2 = params.options) === null || _a2 === void 0 ? void 0 : _a2.redirectTo) !== null && _b2 !== void 0 ? _b2 : void 0 }), ((_c2 = params === null || params === void 0 ? void 0 : params.options) === null || _c2 === void 0 ? void 0 : _c2.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true }),
        headers: this.headers,
        xform: _ssoResponse
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (result) => {
        const { data: { session }, error: sessionError } = result;
        if (sessionError)
          throw sessionError;
        if (!session)
          throw new AuthSessionMissingError();
        const { error } = await _request(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return { data: { user: null, session: null }, error };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      if (credentials.type != "email_change" && credentials.type != "phone_change") {
        await this._removeSession();
      }
      const endpoint = `${this.url}/resend`;
      if ("email" in credentials) {
        const { email, type, options } = credentials;
        const { error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return { data: { user: null, session: null }, error };
      } else if ("phone" in credentials) {
        const { phone, type, options } = credentials;
        const { data, error } = await _request(this.fetch, "POST", endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken }
          }
        });
        return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };
      }
      throw new AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   */
  async getSession() {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._useSession(async (result) => {
        return result;
      });
    });
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug("#_acquireLock", "begin", acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e2) {
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e2) {
            }
          })());
          await result;
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug("#_useSession", "begin");
    try {
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin");
    if (!this.lockAcquired) {
      this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    }
    try {
      let currentSession = null;
      if (this.persistSession) {
        const maybeSession = await getItemAsync(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        if (maybeSession !== null) {
          if (this._isValidSession(maybeSession)) {
            currentSession = maybeSession;
          } else {
            this._debug("#getSession()", "session from storage is not valid");
            await this._removeSession();
          }
        }
      } else {
        currentSession = this.inMemorySession;
        this._debug("#getSession()", "session from memory", currentSession);
      }
      if (!currentSession) {
        return { data: { session: null }, error: null };
      }
      const hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1e3 : false;
      this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
      if (!hasExpired) {
        return { data: { session: currentSession }, error: null };
      }
      const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return { data: { session: null }, error };
      }
      return { data: { session }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session.
   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return await this._getUser();
    });
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt,
          xform: _userResponse
        });
      }
      return await this._useSession(async (result) => {
        var _a2, _b2;
        const { data, error } = result;
        if (error) {
          throw error;
        }
        return await _request(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (_b2 = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b2 !== void 0 ? _b2 : void 0,
          xform: _userResponse
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async (result) => {
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new AuthSessionMissingError();
        }
        const session = sessionData.session;
        const { data, error: userError } = await _request(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: attributes,
          jwt: session.access_token,
          xform: _userResponse
        });
        if (userError)
          throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers("USER_UPDATED", session);
        return { data: { user: session.user }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(jwt) {
    return decodeJWTPayload(jwt);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1e3;
      let expiresAt2 = timeNow;
      let hasExpired = true;
      let session = null;
      const payload = decodeJWTPayload(currentSession.access_token);
      if (payload.exp) {
        expiresAt2 = payload.exp;
        hasExpired = expiresAt2 <= timeNow;
      }
      if (hasExpired) {
        const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!refreshedSession) {
          return { data: { user: null, session: null }, error: null };
        }
        session = refreshedSession;
      } else {
        const { data, error } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: "bearer",
          expires_in: expiresAt2 - timeNow,
          expires_at: expiresAt2
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers("SIGNED_IN", session);
      }
      return { data: { user: session.user, session }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        if (!currentSession) {
          const { data, error: error2 } = result;
          if (error2) {
            throw error2;
          }
          currentSession = (_a2 = data.session) !== null && _a2 !== void 0 ? _a2 : void 0;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new AuthSessionMissingError();
        }
        const { session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return { data: { user: null, session: null }, error };
        }
        if (!session) {
          return { data: { user: null, session: null }, error: null };
        }
        return { data: { user: session.user, session }, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { user: null, session: null }, error };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(isPKCEFlow) {
    try {
      if (!isBrowser())
        throw new AuthImplicitGrantRedirectError("No browser detected.");
      if (this.flowType === "implicit" && !this._isImplicitGrantFlow()) {
        throw new AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
      } else if (this.flowType == "pkce" && !isPKCEFlow) {
        throw new AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
      }
      const params = parseParametersFromURL(window.location.href);
      if (isPKCEFlow) {
        if (!params.code)
          throw new AuthPKCEGrantCodeExchangeError("No code detected.");
        const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
        if (error2)
          throw error2;
        const url = new URL(window.location.href);
        url.searchParams.delete("code");
        window.history.replaceState(window.history.state, "", url.toString());
        return { data: { session: data2.session, redirectType: null }, error: null };
      }
      if (params.error || params.error_description || params.error_code) {
        throw new AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
          error: params.error || "unspecified_error",
          code: params.error_code || "unspecified_code"
        });
      }
      const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, token_type } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new AuthImplicitGrantRedirectError("No session defined in URL");
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresIn = parseInt(expires_in);
      const expires_at = timeNow + expiresIn;
      const { data, error } = await this._getUser(access_token);
      if (error)
        throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at,
        refresh_token,
        token_type,
        user: data.user
      };
      window.location.hash = "";
      this._debug("#_getSessionFromURL()", "clearing window.location.hash");
      return { data: { session, redirectType: params.type }, error: null };
    } catch (error) {
      if (isAuthError(error)) {
        return { data: { session: null, redirectType: null }, error };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantFlow() {
    const params = parseParametersFromURL(window.location.href);
    return !!(isBrowser() && (params.access_token || params.error_description));
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCEFlow() {
    const params = parseParametersFromURL(window.location.href);
    const currentStorageContent = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session
   * and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using others scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = { scope: "global" }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({ scope } = { scope: "global" }) {
    return await this._useSession(async (result) => {
      var _a2;
      const { data, error: sessionError } = result;
      if (sessionError) {
        return { error: sessionError };
      }
      const accessToken = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token;
      if (accessToken) {
        const { error } = await this.admin.signOut(accessToken, scope);
        if (error) {
          if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {
            return { error };
          }
        }
      }
      if (scope !== "others") {
        await this._removeSession();
        await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`);
        await this._notifyAllSubscribers("SIGNED_OUT", null);
      }
      return { error: null };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id2 = uuid();
    const subscription = {
      id: id2,
      callback,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", id2);
        this.stateChangeEmitters.delete(id2);
      }
    };
    this._debug("#onAuthStateChange()", "registered callback with id", id2);
    this.stateChangeEmitters.set(id2, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id2);
      });
    })();
    return { data: { subscription } };
  }
  async _emitInitialSession(id2) {
    return await this._useSession(async (result) => {
      var _a2, _b2;
      try {
        const { data: { session }, error } = result;
        if (error)
          throw error;
        await ((_a2 = this.stateChangeEmitters.get(id2)) === null || _a2 === void 0 ? void 0 : _a2.callback("INITIAL_SESSION", session));
        this._debug("INITIAL_SESSION", "callback id", id2, "session", session);
      } catch (err) {
        await ((_b2 = this.stateChangeEmitters.get(id2)) === null || _b2 === void 0 ? void 0 : _b2.callback("INITIAL_SESSION", null));
        this._debug("INITIAL_SESSION", "callback id", id2, "error", err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address.
   * This method supports the PKCE flow.
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === "pkce") {
      const codeVerifier = generatePKCEVerifier();
      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
      codeChallenge = await generatePKCEChallenge(codeVerifier);
      codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
    }
    try {
      return await _request(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: { captcha_token: options.captchaToken }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      const startedAt = Date.now();
      return await retryable(async (attempt) => {
        await sleep(attempt * 200);
        this._debug(debugName, "refreshing attempt", attempt);
        return await _request(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
          body: { refresh_token: refreshToken },
          headers: this.headers,
          xform: _sessionResponse
        });
      }, (attempt, _2, result) => result && result.error && isAuthRetryableFetchError(result.error) && // retryable only if the request can be sent before the backoff overflows the tick duration
      Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION);
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        return { data: { session: null, user: null }, error };
      }
      throw error;
    } finally {
      this._debug(debugName, "end");
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
    if (isBrowser() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return { data: { provider, url }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a2;
    const debugName = "#_recoverAndRefresh()";
    this._debug(debugName, "begin");
    try {
      const currentSession = await getItemAsync(this.storage, this.storageKey);
      this._debug(debugName, "session from storage", currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, "session is not valid");
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const timeNow = Math.round(Date.now() / 1e3);
      const expiresWithMargin = ((_a2 = currentSession.expires_at) !== null && _a2 !== void 0 ? _a2 : Infinity) < timeNow + EXPIRY_MARGIN;
      this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${EXPIRY_MARGIN}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const { error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!isAuthRetryableFetchError(error)) {
              this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
              await this._removeSession();
            }
          }
        }
      } else {
        await this._notifyAllSubscribers("SIGNED_IN", currentSession);
      }
    } catch (err) {
      this._debug(debugName, "error", err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, "end");
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a2, _b2;
    if (!refreshToken) {
      throw new AuthSessionMissingError();
    }
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, "begin");
    try {
      this.refreshingDeferred = new Deferred();
      const { data, error } = await this._refreshAccessToken(refreshToken);
      if (error)
        throw error;
      if (!data.session)
        throw new AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
      const result = { session: data.session, error: null };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, "error", error);
      if (isAuthError(error)) {
        const result = { session: null, error };
        (_a2 = this.refreshingDeferred) === null || _a2 === void 0 ? void 0 : _a2.resolve(result);
        return result;
      }
      (_b2 = this.refreshingDeferred) === null || _b2 === void 0 ? void 0 : _b2.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, "end");
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({ event, session });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async (x2) => {
        try {
          await x2.callback(event, session);
        } catch (e2) {
          errors.push(e2);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i2 = 0; i2 < errors.length; i2 += 1) {
          console.error(errors[i2]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug("#_saveSession()", session);
    if (!this.persistSession) {
      this.inMemorySession = session;
    }
    if (this.persistSession && session.expires_at) {
      await this._persistSession(session);
    }
  }
  _persistSession(currentSession) {
    this._debug("#_persistSession()", currentSession);
    return setItemAsync(this.storage, this.storageKey, currentSession);
  }
  async _removeSession() {
    this._debug("#_removeSession()");
    if (this.persistSession) {
      await removeItemAsync(this.storage, this.storageKey);
    } else {
      this.inMemorySession = null;
    }
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener("visibilitychange", callback);
      }
    } catch (e2) {
      console.error("removing visibilitychange callback failed", e2);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug("#_startAutoRefresh()");
    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
      ticker.unref();
    } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
      Deno.unrefTimer(ticker);
    }
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async (result) => {
              const { data: { session } } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const expiresInTicks = Math.floor((session.expires_at * 1e3 - now) / AUTO_REFRESH_TICK_DURATION);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${AUTO_REFRESH_TICK_DURATION}ms, refresh threshold is ${AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e2) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", e2);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e2) {
      if (e2.isAcquireTimeout) {
        this._debug("auto refresh token tick lock not available");
      } else {
        throw e2;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug("#_handleVisibilityChange()");
    if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener("visibilitychange", this.visibilityChangedCallback);
      await this._onVisibilityChanged(true);
    } catch (error) {
      console.error("_handleVisibilityChange", error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, "visibilityState", document.visibilityState);
    if (document.visibilityState === "visible") {
      if (this.autoRefreshToken) {
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== "visible") {
            this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
            return;
          }
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === "hidden") {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === "pkce") {
      const codeVerifier = generatePKCEVerifier();
      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier);
      const codeChallenge = await generatePKCEChallenge(codeVerifier);
      const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
      this._debug("PKCE", "code verifier", `${codeVerifier.substring(0, 5)}...`, "code challenge", codeChallenge, "method", codeChallengeMethod);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    return `${this.url}/authorize?${urlParams.join("&")}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        return await _request(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#enroll}
   */
  async _enroll(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2, _b2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors`, {
          body: {
            friendly_name: params.friendlyName,
            factor_type: params.factorType,
            issuer: params.issuer
          },
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error) {
          return { data: null, error };
        }
        if ((_b2 = data === null || data === void 0 ? void 0 : data.totp) === null || _b2 === void 0 ? void 0 : _b2.qr_code) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return { data, error: null };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        const { data, error } = await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
          body: { code: params.code, challenge_id: params.challengeId },
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
        if (error) {
          return { data: null, error };
        }
        await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + data.expires_in }, data));
        await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
        return { data, error };
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    try {
      return await this._useSession(async (result) => {
        var _a2;
        const { data: sessionData, error: sessionError } = result;
        if (sessionError) {
          return { data: null, error: sessionError };
        }
        return await _request(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
          headers: this.headers,
          jwt: (_a2 = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a2 === void 0 ? void 0 : _a2.access_token
        });
      });
    } catch (error) {
      if (isAuthError(error)) {
        return { data: null, error };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    const { data: challengeData, error: challengeError } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return { data: null, error: challengeError };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    const { data: { user }, error: userError } = await this._getUser();
    if (userError) {
      return { data: null, error: userError };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter((factor) => factor.factor_type === "totp" && factor.status === "verified");
    return {
      data: {
        all: factors,
        totp
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return await this._useSession(async (result) => {
      var _a2, _b2;
      const { data: { session }, error: sessionError } = result;
      if (sessionError) {
        return { data: null, error: sessionError };
      }
      if (!session) {
        return {
          data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
          error: null
        };
      }
      const payload = this._decodeJWT(session.access_token);
      let currentLevel = null;
      if (payload.aal) {
        currentLevel = payload.aal;
      }
      let nextLevel = currentLevel;
      const verifiedFactors = (_b2 = (_a2 = session.user.factors) === null || _a2 === void 0 ? void 0 : _a2.filter((factor) => factor.status === "verified")) !== null && _b2 !== void 0 ? _b2 : [];
      if (verifiedFactors.length > 0) {
        nextLevel = "aal2";
      }
      const currentAuthenticationMethods = payload.amr || [];
      return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
    });
  }
}
GoTrueClient.nextInstanceID = 0;
({
  /**
   * @experimental
   */
  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
});
class SupabaseAuthClient extends GoTrueClient {
  constructor(options) {
    super(options);
  }
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS$1
};
const DEFAULT_DB_OPTIONS = {
  schema: "public"
};
const DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: "implicit"
};
const DEFAULT_REALTIME_OPTIONS = {};
class SupabaseClient {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl)
      throw new Error("supabaseUrl is required.");
    if (!supabaseKey)
      throw new Error("supabaseKey is required.");
    const _supabaseUrl = stripTrailingSlash(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, "ws");
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`;
    const DEFAULTS = {
      db: DEFAULT_DB_OPTIONS,
      realtime: DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
      global: DEFAULT_GLOBAL_OPTIONS
    };
    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_b2 = (_a2 = settings.auth) === null || _a2 === void 0 ? void 0 : _a2.storageKey) !== null && _b2 !== void 0 ? _b2 : "";
    this.headers = (_d2 = (_c2 = settings.global) === null || _c2 === void 0 ? void 0 : _c2.headers) !== null && _d2 !== void 0 ? _d2 : {};
    this.auth = this._initSupabaseAuthClient((_e2 = settings.auth) !== null && _e2 !== void 0 ? _e2 : {}, this.headers, (_f2 = settings.global) === null || _f2 === void 0 ? void 0 : _f2.fetch);
    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), (_g = settings.global) === null || _g === void 0 ? void 0 : _g.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));
    this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: (_h = settings.db) === null || _h === void 0 ? void 0 : _h.schema,
      fetch: this.fetch
    });
    this._listenForAuthEvents();
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  /**
   * Perform a query on a schema distinct from the default schema supplied via
   * the `options.db.schema` constructor parameter.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The name of the schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, options) {
    return this.rest.rpc(fn, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name2, opts = { config: {} }) {
    return this.realtime.channel(name2, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a2, _b2;
    return __awaiter$1(this, void 0, void 0, function* () {
      const { data } = yield this.auth.getSession();
      return (_b2 = (_a2 = data.session) === null || _a2 === void 0 ? void 0 : _a2.access_token) !== null && _b2 !== void 0 ? _b2 : null;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, debug }, headers2, fetch2) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers2),
      storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      debug,
      fetch: fetch2
    });
  }
  _initRealtimeClient(options) {
    return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, "CLIENT", session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
      this.realtime.setAuth(token !== null && token !== void 0 ? token : null);
      this.changedAccessToken = token;
    } else if (event === "SIGNED_OUT") {
      this.realtime.setAuth(this.supabaseKey);
      if (source == "STORAGE")
        this.auth.signOut();
      this.changedAccessToken = void 0;
    }
  }
}
const createClient = (supabaseUrl, supabaseKey, options) => {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
};
const supabaseClient = {}.STORYBOOK ? {} : createClient(
  "https://geaspizttckurewljdwi.supabase.co",
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdlYXNwaXp0dGNrdXJld2xqZHdpIiwicm9sZSI6ImFub24iLCJpYXQiOjE2ODE0MzUyOTIsImV4cCI6MTk5NzAxMTI5Mn0.AkePNRR0YVGsn90Tek_PEWTCILj8yRVDceZPDtSznFA",
  {
    auth: {
      autoRefreshToken: true,
      storageKey: "beacon_session",
      flowType: "implicit"
    }
  }
);
const getSession = async () => {
  const { error, data } = await supabaseClient.auth.getSession();
  return { error, session: data.session };
};
const getStoredSession = () => {
  try {
    const session = JSON.parse(
      localStorage.getItem("beacon_session") ?? "null"
    );
    return session;
  } catch (e2) {
    return null;
  }
};
const updateMetadata = (meta) => supabaseClient.auth.updateUser({ data: meta });
const storedSession = getStoredSession();
if (storedSession) {
  try {
    supabaseClient.auth.setSession({
      access_token: storedSession.access_token,
      refresh_token: storedSession.refresh_token
    });
  } catch (e2) {
    console.log("Set supabase session from storage failed", e2);
  }
}
var __defProp$7 = Object.defineProperty;
var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
var __decorateClass$6 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$7(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$7(target, key, result);
  return result;
};
let KybLiteModel = class extends Model({
  role: prop().withSetter(),
  use: prop().withSetter(),
  merchantName: prop().withSetter(),
  subMerchantDba: prop().withSetter(),
  taxId: prop().withSetter(),
  website: prop().withSetter(),
  phone: prop().withSetter(),
  placeId: prop().withSetter(),
  needToFindOrganization: prop().withSetter(),
  foundOrganizationId: prop().withSetter()
}) {
  async submitOnboarding() {
    const root = getRootStore(this);
    const mandatoryFields = root.auth.name && root.auth.email;
    const mandatoryOrgFields = root.auth.organization;
    if (mandatoryFields) {
      root.global.setGlobalLoading({
        loading: true,
        meta: this.foundOrganizationId ? "Creating your account..." : "Creating your organization..."
      });
      let newUser = null;
      if (this.foundOrganizationId) {
        newUser = await api$1.user.create.mutate({
          name: root.auth.name,
          email: root.auth.email,
          organizationId: this.foundOrganizationId
        });
      } else if (mandatoryOrgFields) {
        const addressId = await api$1.address.registerPlaceId.mutate(
          this.placeId
        );
        newUser = await api$1.user.createWithOrg.mutate({
          organization: root.auth.organization,
          kybDocument: {
            merchantName: this.merchantName ?? "",
            subMerchantDba: this.subMerchantDba ?? "",
            taxId: this.taxId ?? "",
            phone: this.phone ?? "",
            website: this.website ?? "",
            addressId
          },
          email: root.auth.email,
          name: root.auth.name
        });
        if (!newUser) {
          return;
        }
        const { data, error } = await updateMetadata({
          onboarding_complete: true
        });
        if (error || !data.user.user_metadata.onboarding_complete)
          ;
      }
    }
    root.global.setGlobalLoading({ loading: false });
  }
};
__decorateClass$6([
  modelAction
], KybLiteModel.prototype, "submitOnboarding", 1);
KybLiteModel = __decorateClass$6([
  model("Auth/KybLite")
], KybLiteModel);
const authModelName = "Auth";
function getAuthModelData() {
  const data = getModelData(authModelName);
  return typeof data === "string" ? JSON.parse(data) : data;
}
function setAuthModelData(value) {
  return setModelData(authModelName, value);
}
let AuthStore = class extends Model({
  email: prop().withSetter(),
  name: prop().withSetter(),
  organization: prop().withSetter(),
  kybLite: prop().withSetter(),
  session: prop(() => storedSession),
  waitingForOtp: prop(false).withSetter(),
  signedIn: prop(!!storedSession).withSetter()
}) {
  supabaseLoaded = false;
  authHandler = null;
  storedSession = storedSession;
  listeners = [];
  async onAuthChange(event, incomingSession) {
    const root = getRootStore(this);
    if (event === "INITIAL_SESSION") {
      this.supabaseLoaded = true;
    } else if (event === "TOKEN_REFRESHED" || event === "USER_UPDATED") {
      if (incomingSession) {
        this.session = incomingSession;
      } else
        console.warn(event, "event but no session?");
    }
    const session = this.supabaseLoaded ? incomingSession : incomingSession ?? this.storedSession;
    const meta = session?.user?.user_metadata ?? {};
    const { onboarding_complete, server_user_created, name: name2 } = meta;
    if (event === "INITIAL_SESSION" && session && !incomingSession || event === "SIGNED_OUT") {
      root.global.setGlobalLoading({ loading: true, meta: "Signing out..." });
      this.session = null;
      this.signedIn = false;
      await sleep$1(800);
      root.global.setGlobalLoading({ loading: false });
      return;
    } else if (event === "INITIAL_SESSION" && !session && !incomingSession) {
      console.log("?");
      root.global.setGlobalLoading({ loading: true, meta: "Signing out..." });
      this.session = null;
      this.signedIn = false;
      await sleep$1(800);
      root.global.setGlobalLoading({ loading: false });
      return;
    }
    if (session && onboarding_complete && server_user_created) {
      if (event === "INITIAL_SESSION" || event === "SIGNED_IN") {
        this.session = { ...session };
        return;
      }
    }
    if (session && !onboarding_complete) {
      if (event === "INITIAL_SESSION" || event === "SIGNED_IN") {
        root.global.setGlobalLoading({ loading: true });
      }
    }
  }
  signUp = _async(function* (email, name2, organization) {
    const emailStatus = yield* _await(
      api$1.user.checkValidEmail.query({ email })
    );
    if (emailStatus !== "AVAILABLE") {
      let error2 = null;
      if (emailStatus === "INVALID") {
        error2 = "This domain cannot be used to register for Monay Beacon.";
      } else {
        error2 = "This email is not valid.";
      }
      return { error: error2, data: { user: null, session: null } };
    }
    const { error, data } = yield* _await(
      supabaseClient.auth.signInWithOtp({
        email,
        options: {
          shouldCreateUser: true,
          data: {
            name: name2,
            beacon_user: true,
            server_user_created: false,
            creating_new_organization: !!organization,
            organization
          }
        }
      })
    );
    if (!error) {
      this.setWaitingForOtp(true);
      this.setEmail(email);
      this.setName(name2);
      if (organization)
        this.setOrganization(organization);
    }
    return { error, data };
  });
  signIn = _async(function* (email) {
    const { error, data } = yield* _await(
      supabaseClient.auth.signInWithOtp({
        email,
        options: {
          shouldCreateUser: false
        }
      })
    );
    if (!error) {
      this.setWaitingForOtp(true);
      this.setEmail(email);
    }
    console.log(error, data);
    return { error, data };
  });
  confirmOtp = _async(function* (token) {
    const { error, data } = yield* _await(
      supabaseClient.auth.verifyOtp({
        token,
        email: this.email,
        type: "email"
      })
    );
    if (!error) {
      this.setWaitingForOtp(false);
      this.session = data.session;
      this.setSignedIn(true);
    }
    return { error, data };
  });
  async signOut(scope = "local") {
    await supabaseClient.auth.signOut({ scope });
  }
  onAttachedToRootStore() {
    const res = supabaseClient.auth.onAuthStateChange(
      (event, session) => this.onAuthChange(event, session)
    );
    this.authHandler = res.data.subscription;
    const reactionDisposer = reaction(
      () => getSnapshot(this),
      (snap) => {
        setAuthModelData(snap);
      },
      { fireImmediately: true }
    );
    return () => {
      this.authHandler?.unsubscribe();
      reactionDisposer();
    };
  }
};
__decorateClass$6([
  observable$1
], AuthStore.prototype, "supabaseLoaded", 2);
__decorateClass$6([
  modelAction
], AuthStore.prototype, "onAuthChange", 1);
__decorateClass$6([
  modelFlow
], AuthStore.prototype, "signUp", 2);
__decorateClass$6([
  modelFlow
], AuthStore.prototype, "signIn", 2);
__decorateClass$6([
  modelFlow
], AuthStore.prototype, "confirmOtp", 2);
__decorateClass$6([
  modelFlow
], AuthStore.prototype, "signOut", 1);
AuthStore = __decorateClass$6([
  model(authModelName)
], AuthStore);
function createAuthStore() {
  const authStore = getAuthModelData();
  if (authStore) {
    try {
      return new AuthStore(authStore);
    } catch (e2) {
      console.log(e2);
    }
  }
  return new AuthStore({ kybLite: new KybLiteModel({}) });
}
var __defProp$6 = Object.defineProperty;
var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
var __decorateClass$5 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$6(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$6(target, key, result);
  return result;
};
let AddressModel = class extends Model({
  id: idProp,
  googlePlacesId: prop(),
  jsonAddress: prop(),
  country: prop()
}) {
};
AddressModel = __decorateClass$5([
  model("Beacon/Address")
], AddressModel);
let LocaleModel = class extends Model({}) {
};
LocaleModel = __decorateClass$5([
  model("Beacon/Locale")
], LocaleModel);
let CountryModel = class extends Model({}) {
};
CountryModel = __decorateClass$5([
  model("Beacon/Country")
], CountryModel);
var __defProp$5 = Object.defineProperty;
var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
var __decorateClass$4 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$5(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$5(target, key, result);
  return result;
};
let KybModel = class extends Model({
  id: idProp,
  // business information
  merchantName: prop().withSetter(),
  subMerchantDba: prop().withSetter(),
  website: prop().withSetter(),
  taxId: prop().withSetter(),
  phone: prop().withSetter(),
  linkedinUrl: prop().withSetter(),
  overview: prop().withSetter(),
  address: prop().withSetter(),
  // other information
  productDescription: prop().withSetter(),
  primaryBusiness: prop().withSetter(),
  firstYearSalesVol: prop().withSetter(),
  averageTxAmt: prop().withSetter(),
  posType: prop().withSetter(),
  posPct: prop().withSetter(),
  // financial documentation
  businessType: prop().withSetter(),
  productsAndServices: prop().withSetter(),
  backgroundInfo: prop().withSetter(),
  resumeUrl: prop().withSetter(),
  corpOverviewUrl: prop().withSetter(),
  statementUrl: prop().withSetter(),
  statementInterimUrl: prop().withSetter(),
  depositoryInfoUrl: prop().withSetter(),
  merchProcessingUrl: prop().withSetter(),
  profitLossUrl: prop().withSetter(),
  // boarding form info
  locationCount: prop().withSetter(),
  incorporationDate: prop().withSetter(),
  taxIdType: prop().withSetter(),
  taxName: prop().withSetter(),
  dbaName: prop().withSetter(),
  dbaContactName: prop().withSetter(),
  dbaContactType: prop().withSetter(),
  retailDescriptor: prop().withSetter(),
  customerServiceNum: prop().withSetter(),
  billToName: prop().withSetter(),
  billToContactName: prop().withSetter(),
  billToAddress: prop().withSetter()
}) {
};
KybModel = __decorateClass$4([
  model("Beacon/Organization/Kyb")
], KybModel);
let KybOwnerModel = class extends Model({
  name: prop().withSetter(),
  dob: prop().withSetter(),
  title: prop().withSetter(),
  ownershipPct: prop().withSetter(),
  ssn: prop().withSetter(),
  email: prop().withSetter(),
  mobile: prop().withSetter()
}) {
};
KybOwnerModel = __decorateClass$4([
  model("Beacon/Organization/Kyb/Owner")
], KybOwnerModel);
let KybManagerModel = class extends Model({
  name: prop().withSetter(),
  title: prop().withSetter(),
  linkedinUrl: prop().withSetter(),
  resumeUrl: prop().withSetter()
}) {
};
KybManagerModel = __decorateClass$4([
  model("Beacon/Organization/Kyb/Manager")
], KybManagerModel);
var __defProp$4 = Object.defineProperty;
var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
var __decorateClass$3 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$4(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$4(target, key, result);
  return result;
};
let OrganizationModel = class extends Model({
  id: idProp,
  subscriberUnits: prop(),
  billerUnits: prop(),
  kybDocument: prop().withSetter()
}) {
};
OrganizationModel = __decorateClass$3([
  model("Beacon/Organization")
], OrganizationModel);
let SubscriberModel = class extends Model({
  id: idProp,
  contactInfo: prop().withSetter()
}) {
};
SubscriberModel = __decorateClass$3([
  model("Beacon/Organization/Subscriber")
], SubscriberModel);
let BillerModel = class extends Model({
  id: idProp,
  contactInfo: prop().withSetter()
}) {
};
BillerModel = __decorateClass$3([
  model("Beacon/Organization/Biller")
], BillerModel);
let AccountModel = class extends Model({
  id: idProp,
  accountId: prop(),
  biller: prop(),
  subscriber: prop(),
  contracts: prop()
}) {
};
AccountModel = __decorateClass$3([
  model("Beacon/Organization/Account")
], AccountModel);
let ContractModel = class extends Model({
  id: idProp
}) {
};
ContractModel = __decorateClass$3([
  model("Beacon/Organization/Account/Contract")
], ContractModel);
let ServiceModel = class extends Model({
  id: idProp
}) {
};
ServiceModel = __decorateClass$3([
  model("Beacon/Organization/Account/Contract/Service")
], ServiceModel);
let DomainModel = class extends Model({
  domain: prop(),
  testEmail: prop()
}) {
};
DomainModel = __decorateClass$3([
  model("Beacon/Organization/Domains")
], DomainModel);
let SubmerchantModel = class extends Model({
  name: prop(),
  description: prop("")
}) {
};
SubmerchantModel = __decorateClass$3([
  model("Beacon/Organization/Submerchant")
], SubmerchantModel);
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$3(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$3(target, key, result);
  return result;
};
let UserModel = class extends Model({
  id: idProp,
  email: prop().withSetter(),
  name: prop(),
  phone: prop().withSetter(),
  role: prop().withSetter()
}) {
};
UserModel = __decorateClass$2([
  model("Beacon/User")
], UserModel);
let UserRoleModel = class extends Model({
  role: prop().withSetter(),
  description: prop().withSetter()
}) {
};
UserRoleModel = __decorateClass$2([
  model("Beacon/User/Role")
], UserRoleModel);
let UserControlModel = class extends Model({}) {
};
UserControlModel = __decorateClass$2([
  model("Beacon/User/Role/Control")
], UserControlModel);
let UserDeviceModel = class extends Model({
  os: prop().withSetter(),
  appVersion: prop().withSetter(),
  lastIp: prop().withSetter(),
  timezone: prop().withSetter(),
  fingerprint: prop().withSetter()
}) {
};
UserDeviceModel = __decorateClass$2([
  model("Beacon/User/Device")
], UserDeviceModel);
let UserFlagsModel = class extends Model({}) {
};
UserFlagsModel = __decorateClass$2([
  model("Beacon/User/Flags")
], UserFlagsModel);
let UserPrefsModel = class extends Model({}) {
};
UserPrefsModel = __decorateClass$2([
  model("Beacon/User/Prefs")
], UserPrefsModel);
let UserNudgePrefsModel = class extends Model({}) {
};
UserNudgePrefsModel = __decorateClass$2([
  model("Beacon/User/NudgePrefs")
], UserNudgePrefsModel);
var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
let BeaconStore = class extends Model({
  user: prop().withSetter(),
  organization: prop().withSetter(),
  nudges: prop(() => []).withSetter(),
  serviceTypes: prop(() => []).withSetter(),
  industries: prop(() => []).withSetter(),
  syncedWithServer: prop(false).withSetter()
}) {
};
BeaconStore = __decorateClass$1([
  model("Beacon")
], BeaconStore);
const createBeaconStore = () => new BeaconStore({
  user: new UserModel({
    email: "",
    name: ""
  }),
  organization: new OrganizationModel({
    subscriberUnits: [],
    billerUnits: [],
    kybDocument: new KybModel({
      address: new AddressModel({
        googlePlacesId: "",
        jsonAddress: {},
        country: new CountryModel({})
      })
    })
  })
});
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i2 = decorators.length - 1, decorator; i2 >= 0; i2--)
    if (decorator = decorators[i2])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
setGlobalConfig({
  showDuplicateModelNameWarnings: false
});
let RootStore = class extends Model({
  auth: prop(() => createAuthStore()),
  global: prop(() => createGlobalStateStore()),
  beacon: prop()
}) {
  get signedIn() {
    return this.auth.signedIn;
  }
  onAttachedToRootStore(rootStore) {
    if (this.signedIn) {
      this.beacon = createBeaconStore();
    }
  }
};
__decorateClass([
  computed
], RootStore.prototype, "signedIn", 1);
RootStore = __decorateClass([
  model("Root")
], RootStore);
const createRootStore = () => {
  const rootStore = registerRootStore(new RootStore({}));
  return rootStore;
};
const RootStoreContext = reactExports.createContext(null);
const RootProvider = RootStoreContext.Provider;
const useRootStore = () => reactExports.useContext(RootStoreContext);
const OTP_LENGTH = 6;
const Otp = () => {
  const root = useRootStore();
  const [otp, setOtp] = reactExports.useState(new Array(OTP_LENGTH).fill(""));
  const [loading, setLoading] = reactExports.useState(false);
  const [otpError, setOtpError] = reactExports.useState();
  const otp1 = reactExports.useRef(null);
  const otp2 = reactExports.useRef(null);
  const otp3 = reactExports.useRef(null);
  const otp4 = reactExports.useRef(null);
  const otp5 = reactExports.useRef(null);
  const otp6 = reactExports.useRef(null);
  const otpRefs = [
    otp1,
    otp2,
    otp3,
    otp4,
    otp5,
    otp6
  ];
  const submitOtp = async () => {
    setLoading(true);
    setOtpError(void 0);
    const { error } = await minTime(root.auth.confirmOtp(otp.join("")), 2e3);
    if (typeof error === "string")
      setOtpError(error);
    else if (error && typeof error === "object")
      setOtpError(error.message);
    setLoading(false);
  };
  const onInput = (event) => {
    const index2 = event.currentTarget.tabIndex;
    if (event.currentTarget.value && otpRefs[index2 + 1]) {
      otpRefs[index2 + 1].current?.focus();
    } else if (!event.currentTarget.value && otpRefs[index2 - 1]) {
      otpRefs[index2 - 1].current?.focus();
    }
    setOtp(
      [...otp].map((o3, i2) => i2 === index2 ? event.currentTarget.value : o3)
    );
  };
  const onPotentialDelete = (event) => {
    if (event.key.toLowerCase() === "backspace" || event.key.toLowerCase() === "delete") {
      setOtp([...otp].map(() => ""));
      if (otpError)
        setOtpError(void 0);
      otp1.current?.focus();
    }
  };
  const onInputFocus = (event) => {
    const index2 = event.currentTarget.tabIndex;
    for (let i2 = 0; i2 <= index2 && i2 <= otpRefs.length; i2++) {
      if (otpRefs[i2].current && !otpRefs[i2].current?.value) {
        otpRefs[i2].current?.focus();
        break;
      }
    }
  };
  reactExports.useEffect(() => {
    if (otp?.every((o3) => o3.match(/\d{1}/gi))) {
      submitOtp();
    }
  }, [otp]);
  reactExports.useEffect(() => {
    const pasteListener = (event) => {
      if (event.isTrusted && event.clipboardData?.getData("text")) {
        const otpText = event.clipboardData?.getData("text");
        if (!otpText.match(/\d{6}/gi)) {
          alert("Pasted OTP does not match format.");
        } else {
          setOtp(otpText.split(""));
        }
      }
    };
    window.addEventListener("paste", pasteListener);
    return () => {
      window.removeEventListener("paste", pasteListener);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 mt-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "mb-2 text-center", children: "Enter OTP" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-4 text-center leading-none", children: [
      "You should receive an email at ",
      root.auth.email,
      " with a one-time passcode from hello@monay.com."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative flex w-full flex-row justify-between", children: otp.map((otpAtIndex, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        maxLength: 1,
        className: "w-12 rounded-lg border-none bg-zinc-400/10 px-2 py-3 text-center font-mono text-3xl font-bold shadow-inner shadow-zinc-600/30 outline-none transition-all duration-300 focus:ring-2 focus:ring-inset focus:ring-base/25 disabled:bg-zinc-400/0 disabled:shadow-none disabled:ring-2 disabled:ring-zinc-400/10 dark:bg-zinc-50/10 dark:shadow-zinc-900/90 disabled:dark:bg-zinc-50/0 disabled:dark:ring-zinc-50/10 md:w-10",
        value: otpAtIndex,
        ref: otpRefs[i2],
        tabIndex: i2,
        onInput,
        onFocus: onInputFocus,
        onKeyDown: onPotentialDelete,
        disabled: loading,
        autoFocus: i2 === 0
      },
      `otp-${i2}`
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-2 mt-1 text-center text-xs leading-none", children: "Enter OTP Code" }),
    !!otpError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-4 rounded-md bg-red-500/20 p-2 text-center font-mono text-xs font-bold backdrop-blur-sm", children: otpError }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-8 flex w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 32 }) })
  ] });
};
const Otp$1 = observer(Otp);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
const isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name2) => name2.substring(0, name2.search(/\.\d+(\.|$)/)) || name2;
var isNameInFieldArray = (names, name2) => names.has(getNodeParentName(name2));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy2;
  const isArray2 = Array.isArray(data);
  if (data instanceof Date) {
    copy2 = new Date(data);
  } else if (data instanceof Set) {
    copy2 = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray2 || isObject(data))) {
    copy2 = isArray2 ? [] : {};
    if (!isArray2 && !isPlainObject(data)) {
      copy2 = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy2[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy2;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get3 = (obj, path, defaultValue) => {
  if (!path || !isObject(obj)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], obj);
  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
React.createContext(null);
var getProxyFormState = (formState, control, localProxyFormState, isRoot2 = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot2 || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot2) => {
  updateFormState(formStateData);
  const { name: name2, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot2 || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
function useSubscribe(props) {
  const _props = React.useRef(props);
  _props.current = props;
  React.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get3(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get3(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
function set4(object2, path, value) {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object2[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    object2[key] = newValue;
    object2 = object2[key];
  }
  return object2;
}
var appendErrors = (name2, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
  ...errors[name2],
  types: {
    ...errors[name2] && errors[name2].types ? errors[name2].types : {},
    [type]: message || true
  }
} : {};
const focusFieldBy = (fields, callback, fieldsNames) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get3(fields, key);
    if (field) {
      const { _f: _f2, ...currentField } = field;
      if (_f2 && callback(_f2.name)) {
        if (_f2.ref.focus) {
          _f2.ref.focus();
          break;
        } else if (_f2.refs && _f2.refs[0].focus) {
          _f2.refs[0].focus();
          break;
        }
      } else if (isObject(currentField)) {
        focusFieldBy(currentField, callback);
      }
    }
  }
};
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name2, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name2) || [..._names.watch].some((watchName) => name2.startsWith(watchName) && /^\.\w+/.test(name2.slice(watchName.length))));
var updateFieldArrayRootError = (errors, error, name2) => {
  const fieldArrayErrors = compact(get3(errors, name2));
  set4(fieldArrayErrors, "root", error[name2]);
  set4(errors, name2, fieldArrayErrors);
  return errors;
};
var isBoolean = (value) => typeof value === "boolean";
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value) => isString(value);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value) => value instanceof RegExp;
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values2 = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values2, isValid: !!values2.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name: name2, valueAsNumber, mount, disabled } = field._f;
  const inputValue = get3(formValues, name2);
  if (!mount || disabled) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name2, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name2] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name2] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name2].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name2].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name2] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name2] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name2] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name2] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
function baseGet(object2, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length) {
    object2 = isUndefined(object2) ? index2++ : object2[updatePath[index2++]];
  }
  return object2;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object2, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object2 : baseGet(object2, paths);
  const index2 = paths.length - 1;
  const key = paths[index2];
  if (childObject) {
    delete childObject[key];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object2, paths.slice(0, -1));
  }
  return object2;
}
function createSubject() {
  let _observers = [];
  const next = (value) => {
    for (const observer2 of _observers) {
      observer2.next && observer2.next(value);
    }
  };
  const subscribe = (observer2) => {
    _observers.push(observer2);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o3) => o3 !== observer2);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
}
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
function getFieldValue(_f2) {
  const ref = _f2.ref;
  if (_f2.refs ? _f2.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f2.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f2.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f2.ref.value : ref.value, _f2);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name2 of fieldsNames) {
    const field = get3(_fields, name2);
    field && set4(fields, name2, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name2) {
  const error = get3(errors, name2);
  if (error || isKey(name2)) {
    return {
      error,
      name: name2
    };
  }
  const names = name2.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get3(_fields, fieldName);
    const foundError = get3(errors, fieldName);
    if (field && !Array.isArray(field) && name2 !== fieldName) {
      return { name: name2 };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name: name2
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name2) => !compact(get3(ref, name2)).length && unset(ref, name2);
const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}, flushRootRender) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    errors: {}
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const shouldCaptureDirtyFields = props.resetOptions && props.resetOptions.keepDirtyValues;
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait2) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait2);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (_proxyFormState.isValid || shouldUpdateValid) {
      const isValid2 = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (value) => _proxyFormState.isValidating && _subjects.state.next({
    isValidating: value
  });
  const _updateFieldArray = (name2, values2 = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get3(_fields, name2))) {
        const fieldValues = method(get3(_fields, name2), args.argA, args.argB);
        shouldSetValues && set4(_fields, name2, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get3(_formState.errors, name2))) {
        const errors = method(get3(_formState.errors, name2), args.argA, args.argB);
        shouldSetValues && set4(_formState.errors, name2, errors);
        unsetEmptyArray(_formState.errors, name2);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get3(_formState.touchedFields, name2))) {
        const touchedFields = method(get3(_formState.touchedFields, name2), args.argA, args.argB);
        shouldSetValues && set4(_formState.touchedFields, name2, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name: name2,
        isDirty: _getDirty(name2, values2),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set4(_formValues, name2, values2);
    }
  };
  const updateErrors = (name2, error) => {
    set4(_formState.errors, name2, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const updateValidAndValue = (name2, shouldSkipSetValueAs, value, ref) => {
    const field = get3(_fields, name2);
    if (field) {
      const defaultValue = get3(_formValues, name2, isUndefined(value) ? get3(_defaultValues, name2) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set4(_formValues, name2, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name2, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name2, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name: name2
    };
    if (!isBlurEvent || shouldDirty) {
      if (_proxyFormState.isDirty) {
        isPreviousDirty = _formState.isDirty;
        _formState.isDirty = output.isDirty = _getDirty();
        shouldUpdateField = isPreviousDirty !== output.isDirty;
      }
      const isCurrentFieldPristine = deepEqual(get3(_defaultValues, name2), fieldValue);
      isPreviousDirty = get3(_formState.dirtyFields, name2);
      isCurrentFieldPristine ? unset(_formState.dirtyFields, name2) : set4(_formState.dirtyFields, name2, true);
      output.dirtyFields = _formState.dirtyFields;
      shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
    }
    if (isBlurEvent) {
      const isPreviousFieldTouched = get3(_formState.touchedFields, name2);
      if (!isPreviousFieldTouched) {
        set4(_formState.touchedFields, name2, isBlurEvent);
        output.touchedFields = _formState.touchedFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
      }
    }
    shouldUpdateField && shouldRender && _subjects.state.next(output);
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name2, isValid2, error, fieldState) => {
    const previousFieldError = get3(_formState.errors, name2);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid2) && _formState.isValid !== isValid2;
    if (props.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name2, error));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set4(_formState.errors, name2, error) : unset(_formState.errors, name2);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name: name2
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
    _updateIsValidating(false);
  };
  const _executeSchema = async (name2) => _options.resolver(_formValues, _options.context, getResolverOptions(name2 || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema();
    if (names) {
      for (const name2 of names) {
        const error = get3(errors, name2);
        error ? set4(_formState.errors, name2, error) : unset(_formState.errors, name2);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name2 in fields) {
      const field = fields[name2];
      if (field) {
        const { _f: _f2, ...fieldValue } = field;
        if (_f2) {
          const isFieldArrayRoot = _names.array.has(_f2.name);
          const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (fieldError[_f2.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get3(fieldError, _f2.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f2.name) : set4(_formState.errors, _f2.name, fieldError[_f2.name]) : unset(_formState.errors, _f2.name));
        }
        fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name2 of _names.unMount) {
      const field = get3(_fields, name2);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name2);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name2, data) => (name2 && data && set4(_formValues, name2, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name2) => compact(get3(_state.mount ? _formValues : _defaultValues, name2, props.shouldUnregister ? get3(_defaultValues, name2, []) : []));
  const setFieldValue = (name2, value, options = {}) => {
    const field = get3(_fields, name2);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set4(_formValues, name2, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name: name2,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name2, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name2);
  };
  const setValues = (name2, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name2}.${fieldKey}`;
      const field = get3(_fields, fieldName);
      (_names.array.has(name2) || !isPrimitive(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name2, value, options = {}) => {
    const field = get3(_fields, name2);
    const isFieldArray = _names.array.has(name2);
    const cloneValue = cloneObject(value);
    set4(_formValues, name2, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name: name2,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name: name2,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name2, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name2, cloneValue, options) : setFieldValue(name2, cloneValue, options);
    }
    isWatched(name2, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: name2,
      values: { ..._formValues }
    });
    !_state.mount && flushRootRender();
  };
  const onChange = async (event) => {
    const target = event.target;
    let name2 = target.name;
    let isFieldValueUpdated = true;
    const field = get3(_fields, name2);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    if (field) {
      let error;
      let isValid2;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get3(_formState.errors, name2) && !field._f.deps || skipValidation(isBlurEvent, get3(_formState.touchedFields, name2), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name2, _names, isBlurEvent);
      set4(_formValues, name2, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name2, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name: name2,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        _proxyFormState.isValid && _updateValid();
        return shouldRender && _subjects.state.next({ name: name2, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      _updateIsValidating(true);
      if (_options.resolver) {
        const { errors } = await _executeSchema([name2]);
        const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name2);
        const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name2);
        error = errorLookupResult.error;
        name2 = errorLookupResult.name;
        isValid2 = isEmptyObject(errors);
      } else {
        error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name2];
        isFieldValueUpdated = isNaN(fieldValue) || fieldValue === get3(_formValues, name2, fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid2 = false;
          } else if (_proxyFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name2, isValid2, error, fieldState);
      }
    }
  };
  const trigger = async (name2, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name2);
    _updateIsValidating(true);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name2) ? name2 : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name2 ? !fieldNames.some((name3) => get3(errors, name3)) : isValid2;
    } else if (name2) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get3(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name2) || _proxyFormState.isValid && isValid2 !== _formState.isValid ? {} : { name: name2 },
      ..._options.resolver || !name2 ? { isValid: isValid2 } : {},
      errors: _formState.errors,
      isValidating: false
    });
    options.shouldFocus && !validationResult && focusFieldBy(_fields, (key) => key && get3(_formState.errors, key), name2 ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values2 = {
      ..._defaultValues,
      ..._state.mount ? _formValues : {}
    };
    return isUndefined(fieldNames) ? values2 : isString(fieldNames) ? get3(values2, fieldNames) : fieldNames.map((name2) => get3(values2, name2));
  };
  const getFieldState = (name2, formState) => ({
    invalid: !!get3((formState || _formState).errors, name2),
    isDirty: !!get3((formState || _formState).dirtyFields, name2),
    isTouched: !!get3((formState || _formState).touchedFields, name2),
    error: get3((formState || _formState).errors, name2)
  });
  const clearErrors = (name2) => {
    name2 && convertToArrayPayload(name2).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name2 ? _formState.errors : {}
    });
  };
  const setError = (name2, error, options) => {
    const ref = (get3(_fields, name2, { _f: {} })._f || {}).ref;
    set4(_formState.errors, name2, {
      ...error,
      ref
    });
    _subjects.state.next({
      name: name2,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name2, defaultValue) => isFunction(name2) ? _subjects.values.subscribe({
    next: (payload) => name2(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name2, defaultValue, true);
  const unregister = (name2, options = {}) => {
    for (const fieldName of name2 ? convertToArrayPayload(name2) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const register = (name2, options = {}) => {
    let field = get3(_fields, name2);
    const disabledIsDefined = isBoolean(options.disabled);
    set4(_fields, name2, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name: name2 } },
        name: name2,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name2);
    field ? disabledIsDefined && set4(_formValues, name2, options.disabled ? void 0 : get3(_formValues, name2, getFieldValue(field._f))) : updateValidAndValue(name2, true, options.value);
    return {
      ...disabledIsDefined ? { disabled: options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name: name2,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name2, options);
          field = get3(_fields, name2);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set4(_fields, name2, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get3(_defaultValues, name2)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name: name2 }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name2, false, void 0, fieldRef);
        } else {
          field = get3(_fields, name2, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name2) && _state.action) && _names.unMount.add(name2);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && focusFieldBy(_fields, (key) => key && get3(_formState.errors, key), _names.mount);
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values: values2 } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values2;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      await onValid(fieldValues, e2);
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors),
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
  };
  const resetField = (name2, options = {}) => {
    if (get3(_fields, name2)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name2, get3(_defaultValues, name2));
      } else {
        setValue(name2, options.defaultValue);
        set4(_defaultValues, name2, options.defaultValue);
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name2);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name2);
        _formState.isDirty = options.defaultValue ? _getDirty(name2, get3(_defaultValues, name2)) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name2);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues || _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const values2 = formValues && !isEmptyObject(formValues) ? cloneUpdatedValues : _defaultValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues || shouldCaptureDirtyFields) {
        for (const fieldName of _names.mount) {
          get3(_formState.dirtyFields, fieldName) ? set4(values2, fieldName, get3(_formValues, fieldName)) : setValue(fieldName, get3(values2, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name2 of _names.mount) {
            const field = get3(_fields, name2);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values2);
      _subjects.array.next({
        values: { ...values2 }
      });
      _subjects.values.next({
        values: { ...values2 }
      });
    }
    _names = {
      mount: /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    !_state.mount && flushRootRender();
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;
    _state.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: keepStateOptions.keepDirtyValues ? _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitting: false,
      isSubmitSuccessful: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name2, options = {}) => {
    const field = get3(_fields, name2);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values2) => {
    reset(values2, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef();
  const _values = React.useRef();
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    errors: {},
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props, () => updateFormState((formState2) => ({ ...formState2 }))),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  React.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  React.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
var t$1 = function(e2, t2, i2) {
  if (e2 && "reportValidity" in e2) {
    var n2 = get3(i2, t2);
    e2.setCustomValidity(n2 && n2.message || ""), e2.reportValidity();
  }
}, i = function(r2, e2) {
  var i2 = function(i3) {
    var n3 = e2.fields[i3];
    n3 && n3.ref && "reportValidity" in n3.ref ? t$1(n3.ref, i3, r2) : n3.refs && n3.refs.forEach(function(e3) {
      return t$1(e3, i3, r2);
    });
  };
  for (var n2 in e2.fields)
    i2(n2);
}, n$1 = function(t2, n2) {
  n2.shouldUseNativeValidation && i(t2, n2);
  var f2 = {};
  for (var s2 in t2) {
    var u2 = get3(n2.fields, s2), c2 = Object.assign(t2[s2] || {}, { ref: u2 && u2.ref });
    if (a(n2.names || Object.keys(t2), s2)) {
      var l2 = Object.assign({}, o2(get3(f2, s2)));
      set4(l2, "root", c2), set4(f2, s2, l2);
    } else
      set4(f2, s2, c2);
  }
  return f2;
}, o2 = function(r2) {
  return Array.isArray(r2) ? r2.filter(Boolean) : [];
}, a = function(r2, e2) {
  return r2.some(function(r3) {
    return r3.startsWith(e2 + ".");
  });
};
var n = function(e2, o3) {
  for (var n2 = {}; e2.length; ) {
    var t2 = e2[0], s2 = t2.code, i2 = t2.message, a2 = t2.path.join(".");
    if (!n2[a2])
      if ("unionErrors" in t2) {
        var u2 = t2.unionErrors[0].errors[0];
        n2[a2] = { message: u2.message, type: u2.code };
      } else
        n2[a2] = { message: i2, type: s2 };
    if ("unionErrors" in t2 && t2.unionErrors.forEach(function(r2) {
      return r2.errors.forEach(function(r3) {
        return e2.push(r3);
      });
    }), o3) {
      var c2 = n2[a2].types, f2 = c2 && c2[t2.code];
      n2[a2] = appendErrors(a2, o3, n2, s2, f2 ? [].concat(f2, t2.message) : t2.message);
    }
    e2.shift();
  }
  return n2;
}, t = function(r2, t2, s2) {
  return void 0 === s2 && (s2 = {}), function(i$12, a2, u2) {
    try {
      return Promise.resolve(function(o3, n2) {
        try {
          var a3 = Promise.resolve(r2["sync" === s2.mode ? "parse" : "parseAsync"](i$12, t2)).then(function(r3) {
            return u2.shouldUseNativeValidation && i({}, u2), { errors: {}, values: s2.raw ? i$12 : r3 };
          });
        } catch (r3) {
          return n2(r3);
        }
        return a3 && a3.then ? a3.then(void 0, n2) : a3;
      }(0, function(r3) {
        if (function(r4) {
          return null != r4.errors;
        }(r3))
          return { values: {}, errors: n$1(n(r3.errors, !u2.shouldUseNativeValidation && "all" === u2.criteriaMode), u2) };
        throw r3;
      }));
    } catch (r3) {
      return Promise.reject(r3);
    }
  };
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items2) => {
    const obj = {};
    for (const item of items2) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys2 = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el2 = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description: description2 } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description: description2 };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description: description2 };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description2) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description: description2
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b2, _c2, _d2;
          const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items2 = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items2).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items2);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items2) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items2).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b2;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b2 = (_a2 = p2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const checkboxVariants = cva(["rounded-md"], {
  variants: {},
  defaultVariants: {}
});
const Checkbox = ({
  name: name2,
  className,
  label,
  register,
  deps,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: checkboxVariants({ className }), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "flex flex-row items-center gap-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        className: "rounded-md text-purple-two",
        type: "checkbox",
        ...props,
        ...register(name2, { deps, required: props.required }),
        "aria-label": props["aria-label"] ?? label ?? name2,
        "aria-required": props.required ?? false
      }
    ),
    label
  ] }) });
};
const baseInputVariants = cva(
  ["w-full", "relative", "rounded-md", "outline-none"],
  {
    variants: {
      base: {
        default: [
          "focus:ring-indigo-300/50 focus:dark:ring-indigo-300/50 focus:ring-inset focus:ring-2",
          "bg-slate-400/20 dark:bg-black/40",
          "text-light dark:text-dark",
          "border-none"
        ],
        neu: [
          "rounded-[5px]",
          "opacity-70",
          "bg-base",
          "text-input-shadow",
          "border border-solid border-white"
        ]
      },
      formSize: {
        sm: ["text-sm py-2 px-3"],
        md: ["text-md py-3 px-4"],
        lg: ["text-lg py-4 px-6"]
      },
      disabled: {
        true: ["opacity-75"],
        false: null
      },
      LeftIcon: {
        true: ["pl-12"],
        false: null
      },
      RightIcon: {
        true: ["pr-12"],
        false: null
      }
    },
    defaultVariants: {
      formSize: "md",
      disabled: false,
      base: "default"
    }
  }
);
const labelVariants = cva(
  ["text-md", "font-medium", "text-zinc-950", "dark:text-zinc-50"],
  {
    variants: {
      hidden: {
        true: ["hidden"],
        false: ["block"]
      }
    },
    defaultVariants: {
      hidden: false
    }
  }
);
const descriptionVariants = cva(
  ["text-sm", "text-zinc-800", "dark:text-zinc-400"],
  {
    variants: {},
    defaultVariants: {}
  }
);
const errorVariants = cva(["text-sm", "text-red-500", "font-medium"], {
  variants: {},
  defaultVariants: {}
});
const containerVariants = cva(["flex", "flex-col", "relative"], {
  variants: {
    block: {
      true: ["w-full"],
      false: ["min-w-[100px] w-auto"]
    }
  },
  defaultVariants: {
    block: true
  }
});
const inferredIconMap = {
  email: RiMailAddFill,
  name: RiContactsFill,
  website: RiLinksFill,
  url: RiLinksFill,
  phone: RiPhoneFill,
  tel: RiPhoneFill,
  address: RiMapPinFill
};
const inferIconFromInputType = (type, _label) => {
  const label = _label?.toLocaleLowerCase();
  if (type && type in inferredIconMap) {
    return inferredIconMap[type];
  }
  if (label && label in inferredIconMap) {
    return inferredIconMap[label];
  }
  return void 0;
};
const TextInput = ({
  label,
  labelProps,
  hideLabel,
  description: description2,
  descriptionProps,
  error,
  errorProps,
  className,
  inputClassName,
  loading,
  block,
  formSize,
  disabled,
  register,
  deps,
  name: name2,
  LeftIcon,
  leftIconProps = {},
  RightIcon,
  rightIconProps = {},
  inferIcon,
  textarea = false,
  labelHint,
  labelUrl,
  hintProps = {},
  base = "default",
  ...props
}) => {
  const inputClasses = baseInputVariants({
    formSize,
    disabled,
    LeftIcon: !!LeftIcon || inferIcon,
    RightIcon: !!RightIcon,
    className: inputClassName,
    base
  });
  const containerClasses2 = containerVariants({ block, className });
  const labelClasses = labelVariants({ ...labelProps, hidden: hideLabel });
  const descriptionClasses = descriptionVariants(descriptionProps);
  const errorClasses = errorVariants(errorProps);
  const renderIcon = (type) => {
    const iconMap = {
      left: LeftIcon,
      right: RightIcon
    };
    const Icon = iconMap[type] ?? (inferIcon && type === "left" && inferIconFromInputType(props.type, label));
    const positionClass = type === "left" ? "left-0" : "right-0";
    const iconProps = type === "left" ? leftIconProps : rightIconProps;
    return Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `absolute top-0 ${positionClass} z-0 flex h-full items-center justify-center rounded-l-md pl-3 text-light dark:text-dark ${loading && "opacity-40"}`,
        children: typeof Icon === "function" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: 20, ...iconProps }) : Icon
      }
    ) : null;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: labelClasses, children: label }),
      labelHint && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Hint,
        {
          className: "ml-1",
          position: "right-0 translate-x-1/2",
          ...hintProps,
          children: [
            labelHint,
            " ",
            labelUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 rounded bg-black/50 p-1 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: labelUrl,
                className: "text-blue-600 transition-all duration-150 hover:text-blue-400",
                target: "_blank",
                rel: "noreferrer",
                children: "Learn More"
              }
            ) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full items-center", children: [
      textarea ? (
        // @ts-expect-error prop spread to text area is invalid here but no problematic fields are really being passed so this does not matter
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: inputClasses,
            "aria-label": props["aria-label"] ?? label ?? name2,
            "aria-required": props.required ?? false,
            ...props,
            ...register?.(name2, { deps, required: props.required })
          }
        )
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: inputClasses,
          "aria-label": props["aria-label"] ?? label ?? name2,
          "aria-required": props.required ?? false,
          ...props,
          ...register?.(name2, { deps, required: props.required })
        }
      ),
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-0 top-0 z-[100] flex h-full w-full  items-center pl-2 text-indigo-700 dark:text-indigo-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 28 }) }),
      renderIcon("left"),
      renderIcon("right")
    ] }),
    !!description2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: descriptionClasses, children: description2 }),
    !!error && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: errorClasses, children: error })
  ] });
};
let hasWarned = false;
const ComboBox = ({
  initial,
  display,
  items: items2,
  filter,
  onSelectItem,
  renderItem,
  loading = false,
  placeholder,
  label,
  className,
  type,
  onQuery,
  prefiltered,
  labelProps,
  hideLabel,
  description: description2,
  descriptionProps,
  error,
  errorProps,
  inputClassName,
  block,
  formSize,
  disabled,
  register,
  deps,
  name: name2,
  LeftIcon,
  leftIconProps = {},
  RightIcon,
  rightIconProps = {},
  inferIcon,
  textarea = false,
  labelHint,
  labelUrl,
  hintProps = {},
  float,
  ref,
  ...props
}) => {
  const [selected, setSelected] = reactExports.useState(initial);
  const [query, setQuery] = reactExports.useState("");
  const filteredCombo = prefiltered ? items2 : query === "" ? items2 : items2.filter((item) => {
    if (filter)
      return filter(item);
    else {
      if (typeof item === "string") {
        return item.includes(query);
      } else {
        if (!hasWarned) {
          console.warn(
            "YOU ARE USING THE COMBOBOX COMPONENT WITHOUT A PROPER FILTER FUNCTION. PLEASE FIX THIS IMMEDIATELY.",
            items2
          );
          hasWarned = true;
        }
        return Object.values(item).filter((prop2) => typeof prop2 === "string").includes(query);
      }
    }
  });
  const onChange = (value) => {
    setSelected(value);
    onSelectItem?.(value);
  };
  const getDisplayValue = (item) => {
    if (typeof selected === "object" && typeof item === "object") {
      return item[display];
    }
    return selected;
  };
  const onChangeQuery = (event) => {
    setQuery(event.target.value);
    onQuery?.(event.target.value);
  };
  const inputClasses = baseInputVariants({
    formSize,
    disabled,
    LeftIcon: !!LeftIcon || inferIcon,
    RightIcon: !!RightIcon,
    className: inputClassName
  });
  const labelClasses = labelVariants({ ...labelProps, hidden: hideLabel });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qo, { value: selected, onChange, defaultValue: initial, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full items-start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: labelClasses, children: label }),
      labelHint && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Hint,
        {
          className: "ml-1",
          position: "right-0 translate-x-1/2",
          ...hintProps,
          children: [
            labelHint,
            " ",
            labelUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1 rounded bg-black/50 p-1 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: labelUrl,
                className: "text-blue-600 transition-all duration-150 hover:text-blue-400",
                target: "_blank",
                rel: "noreferrer",
                children: "Learn More"
              }
            ) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      qo.Input,
      {
        onChange: onChangeQuery,
        placeholder,
        displayValue: getDisplayValue,
        type,
        className: inputClasses,
        ...props
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      qo.Options,
      {
        className: `w-full rounded ${float && "absolute bottom-20 left-0 bg-slate-500/10 p-4 backdrop-blur"}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            tt$1,
            {
              show: false,
              as: reactExports.Fragment,
              enter: "duration-75",
              enterFrom: "opacity-20 scale-0 h-0",
              enterTo: "opacity-100 scale-100 h-[20px]",
              leave: "duration-75",
              leaveFrom: "opacity-100 scale-100 h-[20px]",
              leaveTo: "opacity-0 scale-0 h-0",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 20 }) })
            }
          ),
          filteredCombo.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            qo.Option,
            {
              value: item,
              as: "div",
              className: "cursor-pointer",
              children: ({ active, selected: selected2 }) => renderItem(item, { active, selected: selected2 })
            },
            typeof item === "object" ? item[display] : item
          ))
        ]
      }
    )
  ] }) });
};
const signInSchema = z.object({
  email: z.string().email({ message: "Please enter a valid email." })
});
const SignIn = ({ goToOtp }) => {
  const root = useRootStore();
  const { register, handleSubmit, setError, clearErrors, formState } = useForm({
    resolver: t(signInSchema),
    reValidateMode: "onBlur",
    shouldUseNativeValidation: false,
    defaultValues: {
      email: ""
    }
  });
  const loading = formState.isSubmitting || formState.isLoading;
  const showError = !loading && !!Object.keys(formState.errors).length;
  const onSubmit = async ({ email }) => {
    if (formState.errors.root)
      clearErrors("root");
    const res = await root.auth.signIn(email);
    console.log(res);
    if (res) {
      const { error } = res;
      if (typeof error === "string") {
        setError("root", { message: error });
      } else if (error && typeof error === "object") {
        setError("root", error);
      } else {
        goToOtp?.();
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "mb-4 mt-8", children: "Sign In" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit(onSubmit), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          type: "email",
          name: "email",
          label: "Email",
          hideLabel: true,
          register,
          placeholder: "john.doe@acme.io",
          error: formState.touchedFields.email && formState.errors.email?.message,
          loading,
          block: true,
          inferIcon: true,
          className: "mb-4"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          disabled: !formState.isDirty || loading || !formState.isValid,
          className: "py-2",
          block: true,
          loading,
          type: "submit",
          children: "Submit"
        }
      ),
      showError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-mt-1 rounded-b-md bg-red-100/80 px-4 py-2 text-center text-red-700", children: formState.errors.root?.message })
    ] })
  ] });
};
const SignIn$1 = observer(SignIn);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var src_exports = {};
__export(src_exports, {
  SessionContextProvider: () => SessionContextProvider,
  useSession: () => useSession$1,
  useSessionContext: () => useSessionContext,
  useSupabaseClient: () => useSupabaseClient,
  useUser: () => useUser
});
var dist = __toCommonJS(src_exports);
var import_react = reactExports;
var import_jsx_runtime = jsxRuntimeExports;
var SessionContext = (0, import_react.createContext)({
  isLoading: true,
  session: null,
  error: null,
  supabaseClient: {}
});
var SessionContextProvider = ({
  supabaseClient: supabaseClient2,
  initialSession = null,
  children
}) => {
  const [session, setSession] = (0, import_react.useState)(initialSession);
  const [isLoading, setIsLoading] = (0, import_react.useState)(!initialSession);
  const [error, setError] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    if (!session && initialSession) {
      setSession(initialSession);
    }
  }, [session, initialSession]);
  (0, import_react.useEffect)(() => {
    let mounted = true;
    function getSession2() {
      return __async(this, null, function* () {
        const {
          data: { session: session2 },
          error: error2
        } = yield supabaseClient2.auth.getSession();
        if (mounted) {
          if (error2) {
            setError(error2);
            setIsLoading(false);
            return;
          }
          setSession(session2);
          setIsLoading(false);
        }
      });
    }
    getSession2();
    return () => {
      mounted = false;
    };
  }, []);
  (0, import_react.useEffect)(() => {
    const {
      data: { subscription }
    } = supabaseClient2.auth.onAuthStateChange((event, session2) => {
      if (session2 && (event === "SIGNED_IN" || event === "TOKEN_REFRESHED" || event === "USER_UPDATED")) {
        setSession(session2);
      }
      if (event === "SIGNED_OUT") {
        setSession(null);
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  const value = (0, import_react.useMemo)(() => {
    if (isLoading) {
      return {
        isLoading: true,
        session: null,
        error: null,
        supabaseClient: supabaseClient2
      };
    }
    if (error) {
      return {
        isLoading: false,
        session: null,
        error,
        supabaseClient: supabaseClient2
      };
    }
    return {
      isLoading: false,
      session,
      error: null,
      supabaseClient: supabaseClient2
    };
  }, [isLoading, session, error]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SessionContext.Provider, { value, children });
};
var useSessionContext = () => {
  const context = (0, import_react.useContext)(SessionContext);
  if (context === void 0) {
    throw new Error(`useSessionContext must be used within a SessionContextProvider.`);
  }
  return context;
};
function useSupabaseClient() {
  const context = (0, import_react.useContext)(SessionContext);
  if (context === void 0) {
    throw new Error(`useSupabaseClient must be used within a SessionContextProvider.`);
  }
  return context.supabaseClient;
}
var useSession$1 = () => {
  const context = (0, import_react.useContext)(SessionContext);
  if (context === void 0) {
    throw new Error(`useSession must be used within a SessionContextProvider.`);
  }
  return context.session;
};
var useUser = () => {
  var _a2, _b2;
  const context = (0, import_react.useContext)(SessionContext);
  if (context === void 0) {
    throw new Error(`useUser must be used within a SessionContextProvider.`);
  }
  return (_b2 = (_a2 = context.session) == null ? void 0 : _a2.user) != null ? _b2 : null;
};
const useSession = () => {
  const supabaseSession = dist.useSession();
  if (supabaseSession) {
    return {
      ...supabaseSession,
      signOut: async () => {
        try {
          await api$1.user.signOut.mutate();
        } catch (e2) {
          console.log(e2);
        }
        localStorage.removeItem(EPHEMERAL_KEYS.NOAUTH_DATA);
        return supabaseClient.auth.signOut({ scope: "local" });
      }
    };
  }
  return null;
};
const SessionProvider = ({
  children
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(dist.SessionContextProvider, { supabaseClient, children });
const NoauthContext = reactExports.createContext({
  auth: async () => ({ data: null, error: null }),
  setKyb: noop$2,
  setRaw: noop$2,
  submitOnboarding: noop$2
});
NoauthContext.Provider;
const useNoauth = () => reactExports.useContext(NoauthContext);
const signUpSchema = z.object({
  name: z.string().min(3, { message: "Please enter your full name." }),
  email: z.string().email({ message: "Please enter a valid email." }),
  newOrg: z.optional(z.boolean()),
  orgName: z.optional(
    z.string().min(2, {
      message: "Please enter the full name of your organization."
    })
  )
}).refine(
  ({ newOrg, orgName }) => {
    if (newOrg && !orgName)
      return false;
    return true;
  },
  { message: "Please enter the full name of your organization." }
);
const SignUp = ({ goToOtp }) => {
  const root = useRootStore();
  useNoauth();
  const {
    register,
    handleSubmit,
    setError,
    clearErrors,
    watch,
    formState,
    resetField
  } = useForm({
    resolver: t(signUpSchema),
    reValidateMode: "onBlur",
    shouldUseNativeValidation: false,
    defaultValues: {
      name: "",
      email: "",
      newOrg: false
    }
  });
  const loading = formState.isSubmitting || formState.isLoading;
  const showError = !loading && !!Object.keys(formState.errors).length;
  const onSubmit = async ({
    email,
    name: name2,
    orgName
  }) => {
    if (formState.errors.root)
      clearErrors("root");
    const { error } = await root.auth.signUp(email, name2, orgName);
    if (typeof error === "string") {
      setError("root", { message: error });
    } else if (error && typeof error === "object") {
      setError("root", error);
    } else {
      goToOtp?.();
    }
  };
  const creatingNewOrg = watch("newOrg");
  reactExports.useEffect(() => {
    if (!creatingNewOrg)
      resetField("orgName");
  }, [creatingNewOrg]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "mb-4 mt-8", children: "Sign Up" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit(onSubmit), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          type: "text",
          name: "name",
          label: "Name",
          hideLabel: true,
          register,
          placeholder: "John Doe",
          error: formState.touchedFields.name && formState.errors.name?.message,
          loading,
          className: "mb-4",
          inferIcon: true,
          block: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          type: "email",
          name: "email",
          label: "Email",
          hideLabel: true,
          register,
          placeholder: "john.doe@acme.io",
          error: formState.touchedFields.email && formState.errors.email?.message,
          loading,
          block: true,
          inferIcon: true,
          className: "mb-4"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          disabled: loading,
          name: "newOrg",
          className: "mb-4",
          register,
          label: "Creating a new organization?",
          required: false
        }
      ),
      creatingNewOrg && /* @__PURE__ */ jsxRuntimeExports.jsx(
        TextInput,
        {
          type: "text",
          name: "orgName",
          placeholder: "ACME Corp.",
          register,
          label: "Organization Name",
          hideLabel: true,
          error: formState.touchedFields.orgName && formState.errors.orgName?.message,
          loading,
          className: "mb-4",
          block: true,
          required: false
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          disabled: !formState.isDirty || loading || !formState.isValid,
          className: "py-2",
          block: true,
          loading,
          type: "submit",
          children: "Submit"
        }
      ),
      showError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-mt-1 rounded-b-md bg-red-100/80 px-4 py-2 text-center text-red-700", children: formState.errors.root?.message })
    ] })
  ] });
};
const SignUp$1 = observer(SignUp);
const defaultTransitionProps = {
  enter: "ease-out",
  enterFrom: "opacity-0",
  enterTo: "opacity-1",
  leave: "ease-in",
  leaveFrom: "opacity-1",
  leaveTo: "opacity-0"
};
const fadeTranslationMap = addDefaultClasses(
  {
    none: { ...defaultTransitionProps },
    top: {
      enter: "translate-y-0",
      enterFrom: "-translate-y-8",
      enterTo: "translate-y-0",
      leave: "-translate-y-8",
      leaveFrom: "translate-y-0",
      leaveTo: "-translate-y-8"
    },
    bottom: {
      enter: "translate-y-0",
      enterFrom: "translate-y-8",
      enterTo: "translate-y-0",
      leave: "translate-y-8",
      leaveFrom: "translate-y-0",
      leaveTo: "translate-y-8"
    },
    left: {
      enter: "translate-x-0",
      enterFrom: "-translate-x-8",
      enterTo: "translate-x-0",
      leave: "-translate-x-8",
      leaveFrom: "translate-x-0",
      leaveTo: "-translate-x-8"
    },
    right: {
      enter: "translate-x-0",
      enterFrom: "translate-x-8",
      enterTo: "translate-x-0",
      leave: "-translate-x-8",
      leaveFrom: "translate-x-0",
      leaveTo: "translate-x-8"
    }
  },
  defaultTransitionProps
);
const Fade = ({
  children,
  map: map2,
  focusedIndex = 0,
  translation = "none",
  translationProps = {},
  onSwap,
  noIndex = false,
  block = false,
  appear = false,
  delay = false,
  className = "",
  ...props
}) => {
  reactExports.useId();
  const [show, setShow] = reactExports.useState(!appear);
  const nextChildIndex = reactExports.useRef(focusedIndex);
  const [_focusedIndex, setFocusedIndex] = reactExports.useState(focusedIndex);
  const renderFocusedChild = () => {
    if (noIndex) {
      return children;
    }
    if (map2 && _focusedIndex in map2) {
      const el2 = map2[_focusedIndex];
      const Component = el2.el;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...el2.props });
    }
    if (children) {
      return reactExports.Children.toArray(children)[_focusedIndex];
    }
    return null;
  };
  reactExports.useEffect(() => {
    if (focusedIndex !== nextChildIndex.current) {
      nextChildIndex.current = focusedIndex;
      setShow(false);
    }
  }, [focusedIndex]);
  const swapChild = () => {
    if (onSwap)
      onSwap(nextChildIndex.current);
    setFocusedIndex(nextChildIndex.current);
    setShow(true);
  };
  const fadeTranslation = fadeTranslationMap[translation];
  if (delay)
    fadeTranslation.enter += " delay-[1s]";
  reactExports.useEffect(() => {
    if (appear)
      setShow(true);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    tt$1,
    {
      afterLeave: swapChild,
      unmount: false,
      show,
      appear,
      as: "div",
      className: `transition-all duration-500 ${block && "w-full"} ${className}`,
      ...translationProps,
      ...fadeTranslation,
      ...props,
      children: renderFocusedChild()
    }
  ) });
};
const LoadingSkeleton = ({ height = 200, children, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container,
    {
      className: "relative overflow-hidden",
      style: {
        minHeight: height
      },
      ...props,
      type: "neu",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "load absolute -left-[50%] top-0 isolate z-50 h-full w-[50%] border-t border-list/50 bg-gradient-to-r from-list/0 via-list/50 to-list/0" }),
        children
      ]
    }
  );
};
const splash = "";
const stageMap$1 = {
  OTP: Otp$1,
  SIGNIN: SignIn$1,
  SIGNUP: SignUp$1
};
const initialStage = getEphData(EPHEMERAL_KEYS.PREV_SESSION) ? "SIGNIN" : "SIGNUP";
const swapMap = {
  OTP: initialStage,
  SIGNIN: "SIGNUP",
  SIGNUP: "SIGNIN"
};
const SwapSign = ({ stage, swap, lock }) => {
  const [_stage, setStage] = reactExports.useState(stage);
  reactExports.useEffect(() => {
    const timeout = setTimeout(() => {
      setStage(stage);
    }, 500);
    return () => {
      clearTimeout(timeout);
    };
  }, [stage]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      tabIndex: -1,
      className: "-mb-2 -ml-2 flex cursor-pointer flex-row items-center justify-start py-4 pl-2 pr-4",
      onClick: lock ? noop$2 : swap,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RiArrowLeftDoubleFill, { size: 14 }),
        "or",
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 font-bold", children: _stage === "SIGNIN" ? "Sign Up" : "Sign In" })
      ]
    }
  );
};
const SplashPage = () => {
  const [stage, setStage] = reactExports.useState(initialStage);
  const [lock, setLock] = reactExports.useState(false);
  const stageProps = {
    goToOtp: () => setStage("OTP"),
    goToSignup: () => setStage("SIGNUP"),
    goToSignin: () => setStage("SIGNIN")
  };
  const map2 = mapObject(stageMap$1, (_2, Fc2) => ({ props: stageProps, el: Fc2 }));
  const swap = () => {
    setStage(swapMap[stage]);
    setLock(true);
  };
  const resetLock = () => {
    if (lock)
      setLock(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-screen w-screen flex-row items-center justify-center overflow-hidden", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -z-10 flex h-screen w-screen items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid h-full max-h-[56rem] w-full max-w-4xl grid-cols-12 grid-rows-[repeat(12,minmax(0,1fr));]" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mx-4 w-full md:w-[416px]", children: [
      stage !== "OTP" && /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { focusedIndex: stage, noIndex: true, translation: "bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SwapSign, { stage, swap, lock }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { padding: "lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Fade, { map: map2, onSwap: resetLock, focusedIndex: stage }) })
    ] })
  ] });
};
const SplashPage$1 = observer(SplashPage);
const AppContext = reactExports.createContext(null);
const useApp = () => reactExports.useContext(AppContext);
let count = 0;
const AuthLayout = () => {
  const error = useRouteError();
  const [vendors, setVendors] = reactExports.useState([]);
  const [bills, setBills] = reactExports.useState([]);
  const [selectedBills, setSelectedBills] = reactExports.useState([]);
  const [payments, setPayments] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(false);
  reactExports.useEffect(() => {
    api$1.user.logSession.mutate();
  }, []);
  const getVendors = async () => {
    const vendorResponse = await api$1.xdex.fetchVendorCode.query({
      companyCode: "1005"
    });
    const vendors2 = vendorResponse.response.sort(
      (a2, b2) => a2.VendorNo - b2.VendorNo
    );
    setVendors(vendors2);
    return vendors2;
  };
  const getBills = async () => {
    try {
      count++;
      if (count > 3)
        count = 0;
      await sleep$1(count * 750);
      const bills2 = await api$1.xdex.fetchXdexData.query({
        buyerCode: 812,
        compCode: 1005,
        mobileNumber: "9898989898"
      });
      setBills(
        bills2.invoiceDetails.map((invoice) => ({
          ...invoice,
          buyerCode: 812,
          buyer: "Portage County Treasurer"
        }))
      );
    } catch (e2) {
      console.error(e2);
    }
  };
  const getAll = async () => {
    setLoading(true);
    await getVendors();
    await getBills();
    setLoading(false);
  };
  reactExports.useEffect(() => {
    if (!bills.length)
      getAll();
  }, []);
  const renderError = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "neu", className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/", className: "pb-2", children: "⬅️ Go Back" }),
      "Full Error:",
      /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "rounded-md bg-black/10 p-2 text-xs", children: JSON.stringify(error) })
    ] }) });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-screen w-full flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Nav, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AppContext.Provider,
      {
        value: {
          vendors,
          bills,
          selectedBills,
          payments,
          setVendors,
          setBills,
          setSelectedBills,
          setPayments,
          loading,
          setLoading
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full flex-grow", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mx-auto max-w-[1260px] px-[30px] pt-4", children: error ? renderError() : /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) }) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})
  ] });
};
const AuthLayout$1 = observer(AuthLayout);
const NoauthLayout = () => {
  const routeError = useRouteError();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !routeError && /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}),
    false
  ] });
};
const API_PATH = `${"http://localhost"}:${"3000"}`;
const fetchApiKey = async () => {
  const response = await fetch(
    `${API_PATH}/${"nZiwuejas"}`
  );
  if (response.ok) {
    return response.json();
  }
  console.log(response);
  return response.text();
};
let hasRefreshedOnSession = false;
const getApiKey = async (force) => {
  const [existingKey, exp] = [
    localStorage.getItem("nZiwuejas") ?? "",
    localStorage.getItem("beacon_expiry")
  ];
  if (!existingKey || force) {
    if (!exp || parseInt(exp, 10) > Date.now() || force) {
      try {
        const { key } = await fetchApiKey();
        console.log(key);
        if (key && typeof key === "string") {
          localStorage.setItem("nZiwuejas", key);
          localStorage.setItem(
            "beacon_expiry",
            (Date.now() + 1e3 * 60 * 60 * 24).toString()
          );
          hasRefreshedOnSession = true;
          console.log(key);
          return key;
        }
      } catch (e2) {
        console.log("API Key retrieval failure:", e2);
      }
    }
  }
  return existingKey;
};
const TRPC_PATH = `${API_PATH}/api/trpc`;
async function headers() {
  const { session, error } = await getSession();
  if (error) {
    console.info(
      "AUTH ERROR:",
      error.name,
      error.message,
      error.status,
      error.cause
    );
  }
  const { name: name2, version: version2 } = os();
  const agent = await getFingerprintAgent();
  const fingerprint = await agent.get({
    debug: false
  });
  return {
    authorization: `Bearer ${session?.access_token}`,
    "x-t-api-key": await getApiKey(),
    "x-t-os": `${name2}::${version2}`,
    "x-t-v": "1.0.0",
    "x-t-f": fingerprint.visitorId,
    "x-t-t": isElectron() ? "DESKTOP" : "WEB",
    "x-t-tz": ((/* @__PURE__ */ new Date()).getTimezoneOffset() / 60).toString()
  };
}
const api = createTRPCProxyClient({
  transformer: SuperJSON,
  links: [
    loggerLink({
      enabled: (opts) => opts.direction === "down" && opts.result instanceof Error
    }),
    splitLink({
      condition(op) {
        return op.context.noBatch === true;
      },
      true: httpLink({
        url: TRPC_PATH,
        headers
      }),
      false: httpBatchLink({
        url: TRPC_PATH,
        headers
      })
    })
  ]
});
class Server {
  root;
  msgListeners;
  constructor() {
    this.root = createRootStore();
    this.msgListeners = [];
  }
  getInitialState() {
    return getSnapshot(this.root);
  }
  onMessage(listener) {
    this.msgListeners.push(listener);
  }
  sendMessage(actionCall) {
  }
}
const server = new Server();
function init() {
  const rootSnapshot = server.getInitialState();
  const root = fromSnapshot(rootSnapshot);
  getApiKey(true);
  const runServerActionLocally = (actionCall) => {
    try {
      applySerializedActionAndSyncNewModelIds(root, actionCall);
    } finally {
    }
  };
  server.onMessage((actionCall) => {
    runServerActionLocally(actionCall);
  });
  return root;
}
const api$1 = api;
const AllBillersPage = () => {
  const navigate = useNavigate();
  const { vendors } = useApp();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Your Vendors" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 bg-blue-600/5 px-2 py-1", children: vendors.length })
    ] }),
    vendors.map((vendor) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container,
        {
          type: "list",
          className: "mb-2 cursor-pointer p-1 transition-all duration-150 hover:shadow-md",
          padding: "xs",
          onClick: () => navigate(`/biller/${vendor.VendorNo}`),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm", children: [
              "Vendor No.",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "rounded-md bg-black/10 p-1 text-xs", children: vendor.VendorNo })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-bold", children: vendor.Name })
          ]
        },
        vendor.VendorNo
      );
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-8" })
  ] });
};
const InvoiceItem$1 = ({
  invoiceNumber = "201180533505",
  amount = 126.21,
  invoiceDate = "08/26/2023",
  dueDate = "09/26/2023",
  charges = 0,
  status = "Paid",
  ...props
}) => {
  const unpaid = "bg-red-600/10";
  const paid = "bg-green-600/10";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container,
    {
      className: "flex flex-row items-center justify-between text-[14px] font-normal leading-5 text-[#36597D]",
      type: "neu",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: invoiceNumber }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: invoiceDate }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "$",
          amount
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "$",
          charges
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: dueDate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `rounded-[5px] p-2 ${status === "Paid" ? paid : unpaid}`, children: status })
      ]
    }
  );
};
const InvoiceList$1 = (props) => {
  const { bills } = useApp();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[#F1F5F9]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Container,
      {
        className: "flex-column sticky top-0 mb-[10px] flex justify-between text-[14px] font-semibold leading-5 text-[#36597D]",
        type: "list",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Invoice Number" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Amount" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Charges" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Due Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Status" })
        ]
      }
    ),
    (props.incomingBills ?? bills).map((bill) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        InvoiceItem$1,
        {
          amount: bill.amount,
          invoiceNumber: bill.invoiceNumber.toString(),
          invoiceDate: new Date(bill.invoiceDate).toLocaleDateString(
            "en-US",
            { month: "numeric", day: "numeric", year: "numeric" }
          ),
          dueDate: new Date(bill.dueDate).toLocaleDateString("en-US", {
            month: "numeric",
            day: "numeric",
            year: "numeric"
          }),
          status: bill?.status ?? "Unpaid"
        }
      ) }, bill.invoiceNumber);
    })
  ] }) });
};
const BillerPage = () => {
  const [loading, setLoading] = reactExports.useState(false);
  const { billerId } = useParams();
  const { bills, setBills, vendors } = useApp();
  const biller = vendors.find(
    (vendor) => vendor.VendorNo.toString() === billerId
  );
  const billerBills = bills.filter(
    (bill) => bill.buyerCode === biller.VendorNo
  );
  const getBills = async () => {
    setLoading(true);
    await sleep$1(Math.floor(Math.random() * 3e3));
    try {
      const bBills = await api$1.xdex.fetchXdexData.query({
        compCode: 1005,
        buyerCode: biller.VendorNo,
        mobileNumber: "9898989898"
      });
      if (bBills?.length) {
        setBills([
          ...bills.filter((bill) => bill.buyerCode !== biller.VendorNo),
          ...bBills
        ]);
      }
    } catch (e2) {
      console.error(e2);
    }
    setLoading(false);
  };
  reactExports.useEffect(() => {
    getBills();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex w-full items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: biller.Name }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "ml-2 rounded-md bg-black/20 px-2 py-1", children: [
        "Vendor #",
        biller.VendorNo
      ] }),
      !loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/pay", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { intent: "primary", children: "Pay" }) }) })
    ] }),
    loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceList$1, { incomingBills: billerBills })
  ] });
};
const CheckboxActive = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMDSURBVHgBpZa9bhRBDID9s3cRCXWooU5eAvrwKPT08BQ8RVLzFEmdggKFiChCURQ4LjvYM/bYcxshIea0t7Pz48/22N5FsFZKOZDbiVxHch3D/7VLuc4Q8bMPoEEO5fbx7mF7ePVjAw8/CzyWGchW1EXUNugN0TYTAcsD67j8EUkfCfb3WC6EZ2u+lqn3Arx20Ker21+HX283JrXdulCyflJPIVSVEOEyydpnrPeVUFnAzwX4bK/C3rFAXt/cbd58udlAkR/a5qcgdU4u3oFon+q9WdQsA5hlfsV4IM+/pxng7ff7bV3clG0dtM0NQAG0dT5XgXUOmyI27i7fbGeYmI+mUuDl/cNjh1CCVHjX3oT5WdkY2jq3lJOC+idHre14guT7EUJtA7ZDxiQcMsBUZyBzIdoeqvJmWz/BXDygBkscwvKQtc/W6JmoD7pC5vh+njpLDkr+DAvoSYhb0EGcIpRcuCmbXaWgApEnTRvq7vKD5gzoQihSwMgLYGJNM0QIA4Y2jDsucIgBtDGFNyB7ZMhud51VAPctYApxtQZgAYmwxwC4ouD5hz0VGii7kkY3ku1eQBwAY4C0cAhjsuwxGGzaLfC+W+wQzJA071Kp+2RhEQ3hHDljG5AG9z4JSZYgZeUTiPomHDZWazjCW60ZITScDaS5gdwtwtDEC2m1hiKEAeHvkOqJAh4Bi/DWPGJbHdEVZ9O0jIzv7tHi4i7NpWXXvSZl8gyP7MdeIL0kZUKvd9m/6Rl3XNbzSKurVwFtjOHCXvohkjMkuGWju2J8XFstWqnaJc6HHcIR1rthHK5ZQhZJVIcmPN9byxtRkCyElUYWBYRTWUHL5DrvLyFcQrI1xrwk+WC42F9Te+9TOy+yM2KmWhHYCq2a6nmWz4QgRS0MtLpe2hmtmU9XE33bXzXBDlD3cT2jpnn9DnDJCEPyVrm5kyCy9Vo/u+qQfm49zvBhuy0vthIds70W/aW1a8HopjjwKEEBgfy55U2/iIRxIoOvhol/b+dyXch1KpB7HfgDs71yISc3wwIAAAAASUVORK5CYII=";
const DotIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAR8SURBVHgB7Vk9b9tWFL18pL6s1JWbBHGAoKDRoUCXqkOXAq3rpR0Tb13aZO0U/wPL/8Be2jXp1C3OmgxKMmR2fkE4BAgSJJAdmeLHI/lyzyOpKIkc0bIh0UAOcEXzkRSPju+97717DSoIpVSLD9fYVtnabDZbi6bDPpvDtsf2kG3XMIz9og8bk25gsjYfbrLdAPEoURTHCZuiJL1O04BJ6pebwtBmVcxbgmiLx52Jz9LRZKHiJttGwsRCGZNkotOSnISYxbBMQfWKuV2xxNanlDeOIGzzoYtjIBMKo5hmAegh+V1CCCeM1drlpYYz7j7x8YMK/tpldW03iGZGGGCPoUrFpEQlth/I7rOXh+2x942e5AonibIHYUR8pHkAb4U79j3piDhZX7mytDd6fah05sNa4XkSBqBk1TKpWbNsL1F3nvY8e/T6qHtsQulBMF/COeAqVXaVBSYupOxmompo0plbbCDoykA4h+BU2Kia5PrSdj25ORzPjps6rc0w6IoAbmJZAmpTzw02MnFJZLLfCGS5COcwDaH9+8ANKJDRBsag9LU0PyZURsC3MenAVZj4dYgM0qtRXE7COUC4wsT7XqTXPyDdjpKSkzZS4oNA4nQVpO2ScyaEJBZVUmqibZBu8bRJZQfWhHGqrp3laSo1PljVtQSdKaT0zxjpFJ9JzwoWnQD3Hj+hf/+/R81Gnf66+gv99tP3E8f/4fFzH4wfFydS+r+7j+hwENCL1wdM8n6hcXfMeGEY6uSkXc8f/g31ph0vDHUK2ePvP36n5fMtOrdQpz+v/jz1eGFkCdvgVZN6MwipzMDGBBxf9Fz68dvls5E9VGZnb3LhtYaiUwjEWQJb13z7CtKFC3/zAvavCa/wzCwQQdoxJpYh5wsEouTdlcV7RcY+SD8xjPJ6CQqeUYwCaEKNmp7AHbB9IErs2fBjVAp8ttZCFUN7oLtrcVm1jBuBvErghRLlA7rwZQPDDwXqwJZp3M7TSZmAbaDPZF0/JYxSAmNXf3I9eBtb9KREcoMLynSHniTUF1cuLWL4FkTWpNEyYLV3EKGqBMRBIYpAONTT9+WlBapXdRBu4WMYgrWK1TGZfNqioLlBE2bx4BIHbqhFXFnWKu/k/ZghacgexrTm+iETj+eiON6J9gVconfoE4pIP3xzEb7s8OVOft97yQ49DqtqrvcHoYMUgzrDrKijUeSzagfsDq/6HgVM/ruvv4JbOHx5bbRxNHYufPqy1w5CdadZtewa+5IuAKKFdsozp1JpwCGtIaVBYfgwxqBwRnidCb/XvjiSxvPnPVuaZpcj10YQ1CqCS1NCl6dAfhr++X9NL34SpX031Hk4ooGfZolLHHTIFJlLrI3rK37y3Sir8q/vvO57NxEUVS5wc4+PVU9Lr8clrijNvWic5oQx2+EHnF9s0JULzTxL7LB1juolFnovKvDcbeqwv11nf9eKoGuAQEmpq+yr1JivfHctdwfB52i9cSOIvmjW6OJiHcqC4G227Uld22OJNdIf/5UN+3+b5tAffwtv2IUn6QkAIgAAAABJRU5ErkJggg==";
const InvoiceItem = ({
  invoiceNumber = "201180533505",
  amount = 126.21,
  invoiceDate = "08/26/2023",
  dueDate = "09/26/2023",
  charges = 0,
  status = "Paid",
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container,
    {
      className: "flex flex-row items-center justify-between text-[14px] font-normal leading-5 text-[#36597D]",
      type: "neu",
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginLeft: "30px", marginRight: "10px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            className: "h-[24px] w-[24px]",
            src: CheckboxActive,
            alt: "CheckboxActive"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: invoiceNumber }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: invoiceDate }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { marginRight: "10px" }, children: [
          "$",
          amount
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { marginRight: "10px" }, children: [
          "$",
          charges
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: dueDate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            style: {
              marginRight: "10px",
              display: "flex",
              justifyContent: "center",
              width: "67px",
              height: "30px",
              padding: "5px 10px",
              gap: "10px",
              borderRadius: "5px",
              background: "rgba(22, 163, 74, 0.10)"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  color: "var(--green-600, #16A34A)",
                  textAlign: "center",
                  fontSize: "14px",
                  fontStyle: "normal",
                  fontWeight: "600",
                  lineHeight: "20px"
                },
                children: status
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "h-[32px] w-[32px]", src: DotIcon, alt: "DotIcon" })
      ]
    }
  );
};
const InvoiceList = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[#F1F5F9]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between p-[10px]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "heading-page", children: "Invoices" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsx(FilterButton, { disabled: false, Icon: true, size: "small" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-[5px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListButton, { disabled: false, Icon: true, size: "small" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-[5px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardButton, { disabled: false, Icon: true, size: "small" }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Container,
      {
        className: "flex-column mb-[10px] flex items-center justify-between text-[14px] font-semibold leading-5 text-[#36597D]",
        type: "list",
        ...props,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginLeft: "30px", marginRight: "10px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              className: "h-[24px] w-[24px]",
              src: CheckboxActive,
              alt: "CheckboxActive"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: "Invoice Number" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: "Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: "Amount" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: "Charges" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: "Due Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "10px" }, children: "Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginRight: "30px" }, children: "Pay" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceItem, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceItem, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceItem, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceItem, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceItem, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceItem, {}) })
  ] }) });
};
const AllInvoicesPage = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InvoiceList, {});
};
const InvoicePage = () => {
  useLocation();
  const { invoiceId } = useParams();
  const { bills } = useApp();
  const bill = bills.find((b2) => b2.invoiceNumber.toString() === invoiceId);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Container,
      {
        className: "flex-column sticky top-0 mb-[10px] flex justify-between text-[14px] font-semibold leading-5 text-[#36597D]",
        type: "list",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Invoice Number" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Amount" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Charges" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Due Date" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Status" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InvoiceItem$1,
      {
        invoiceNumber: bill.invoiceNumber.toString(),
        amount: bill.amount,
        invoiceDate: new Date(bill.invoiceDate).toLocaleDateString("en-US", {
          month: "numeric",
          day: "numeric",
          year: "numeric"
        }),
        dueDate: new Date(bill.dueDate).toLocaleDateString("en-US", {
          month: "numeric",
          day: "numeric",
          year: "numeric"
        }),
        status: bill?.status ?? "Unpaid"
      }
    )
  ] });
};
const NoOrg = ({ goToStage }) => {
  const goNext = () => goToStage?.("USERINFO");
  const session = useSession();
  const { email } = useNoauth();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Container,
    {
      title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-2 text-center", children: "We ran into an issue." }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "We couldnt find an organization based on your email ",
          email,
          " with domain:"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative my-3 flex min-h-[50px] items-center justify-center text-lg font-semibold", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute flex h-full w-full items-center justify-center opacity-20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RiMailCloseFill, { size: 50 }) }),
          email?.split("@")[1]
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          " ",
          "If you think there has been a mistake, please notify your workspace admin."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-8", children: "You may also register your organization now." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex flex-row gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "min-w-[30%]",
              intent: "destructive",
              onClick: session?.signOut,
              children: "Sign Out"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { block: true, intent: "primary", onClick: goNext, children: [
            "Register",
            /* @__PURE__ */ jsxRuntimeExports.jsx(RiArrowRightDoubleLine, {})
          ] })
        ] })
      ] })
    }
  );
};
const NoOrgTransition = ({ show }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    tt$1,
    {
      as: reactExports.Fragment,
      show,
      enter: "duration-300 ease-in delay-300",
      enterFrom: "scale-90 opacity-0",
      enterTo: "scale-100 opacity-100",
      leave: "duration-500 ease-out",
      leaveFrom: "scale-100 opacity-100",
      leaveTo: "scale-50 opacity-0",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex h-40 w-40 items-center justify-center rounded-full bg-black/20 shadow-2xl shadow-base/10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RiBuilding2Fill,
          {
            size: 100,
            className: "absolute z-0 text-white opacity-50"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          tt$1.Child,
          {
            as: "div",
            className: "absolute flex h-full w-full items-center justify-center",
            enter: "duration-[5s] ease-out delay-700",
            enterFrom: "scale-50 opacity-0",
            enterTo: "opacity-100 scale-100",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rotate-cw grid h-32 w-32 transform-gpu grid-cols-2 grid-rows-2 [animation-duration:7s] [animation-iteration-count:1] [animation-timing-function:ease-out]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rotate-ccw flex h-full w-full items-center justify-center [animation-duration:7s] [animation-iteration-count:1] [animation-timing-function:ease-out]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RiSearch2Line, { className: "text-white", size: 80 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rotate-ccw col-span-1 col-start-2 row-span-1 row-start-2 flex h-full w-full items-center justify-center [animation-duration:7s] [animation-iteration-count:1] [animation-timing-function:ease-out]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RiQuestionLine, { className: "text-white/70", size: 40 }) })
            ] })
          }
        )
      ] }) })
    }
  );
};
const minCompletionMap = {
  ORGNONE: 0,
  USERINFO: 0,
  ORGINFO: 0.2,
  ORGFINAL: 0.7
};
const order = [
  "ORGNONE",
  "USERINFO",
  "ORGINFO",
  "ORGFINAL"
];
const maxPendingMap = Object.fromEntries(
  order.map((action2, i2, o3) => [action2, minCompletionMap[o3[i2 + 1]] ?? 1])
);
const stageMetaMap = {
  ORGNONE: {
    title: ""
  },
  USERINFO: {
    title: "Your Info"
  },
  ORGINFO: {
    title: ({ organization }) => organization ? `${(organization?.length ?? 0) > 20 ? organization.slice(0, 17) + "..." : organization}` : "Your Org"
  },
  ORGFINAL: {
    title: "Org Info"
  }
};
const items = order.slice(1);
const OnboardingNav = ({
  loading,
  setStage,
  stage,
  complete
}) => {
  const { organization } = useNoauth();
  const currentStage = stage;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    tt$1,
    {
      as: reactExports.Fragment,
      show: !loading && stage !== "ORGNONE",
      appear: true,
      enter: "duration-300 ease-in delay-1000 origin-bottom",
      enterFrom: "scale-90 opacity-0",
      enterTo: "scale-100 opacity-100",
      leave: "duration-500 ease-out origin-top",
      leaveFrom: "scale-100 opacity-100",
      leaveTo: "scale-50 opacity-0",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-mx-2 w-full rounded-t-xl bg-zinc-500/10 md:-mx-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex w-full flex-row items-center", children: items.map((stage2) => {
        const { title } = stageMetaMap[stage2];
        const display = typeof title === "function" ? title({ organization }) : title;
        const onClick = () => stage2 !== currentStage ? setStage(stage2) : null;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            disabled: order.indexOf(stage2) > order.indexOf(complete),
            intent: "bare",
            size: "small",
            onClick,
            className: `flex-1 rounded-b-none px-6 py-4 text-zinc-700 dark:text-zinc-300 ${stage2 === currentStage && "border-t-2 border-t-purple-700/40 bg-zinc-300/10 shadow-inner shadow-purple-950/20 dark:border-t-purple-300/40"}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-bold", children: display })
          },
          stage2
        );
      }) }) })
    }
  );
};
const filled = [];
const randomFill = (length, preset) => {
  const randomNum = preset ?? Math.floor(Math.random() * length);
  if (~filled.indexOf(randomNum)) {
    return randomFill(length);
  } else {
    filled.push(randomNum);
  }
  return randomNum;
};
const TOTAL = 600;
const FILTERED = 100;
const positions = new Array(TOTAL + FILTERED).fill(2.8).map((k2, i2, arr) => ({
  ...polarToCartesian({
    r: degreesToRadians(i2 * 8 * k2) + degreesToRadians(8 * (TOTAL - i2 + 100) / TOTAL),
    theta: degreesToRadians(i2 * 10 - k2 * i2 / TOTAL) + degreesToRadians(400 * (TOTAL - i2) / TOTAL)
  })
})).filter((_2, i2) => i2 < FILTERED * 2 ? i2 % 2 : true).map((obj, i2) => ({
  ...obj,
  fillOrder: randomFill(
    TOTAL,
    i2 < FILTERED / 2 ? i2 % 6 ? void 0 : i2 : void 0
  )
}));
const OnboardingProgress = ({
  clamp: clamp2 = 1,
  complete = 0,
  pending = 0,
  total = 1,
  stage
}) => {
  const pctComplete = complete / total;
  const pctPending = Math.max(pending / total, pctComplete);
  const pctClamp = clamp2 / total;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-full overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rotate-cw absolute right-1/2 top-1/2 transform-gpu will-change-transform [animation-duration:90s]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: positions.map(({ x: x2, y: y2, fillOrder }, i2) => {
    const pct = fillOrder / TOTAL;
    let bg2 = "bg-zinc-600 shadow-sm shadow-zinc-800";
    if (pct <= pctComplete && pct <= pctClamp) {
      bg2 = "bg-green-600 shadow-inner shadow-green-900/70";
    } else if (pct <= pctPending && pct <= pctClamp) {
      bg2 = "bg-zinc-700 ring ring-inset ring-slate-700";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressMember, { x: x2, y: y2, bg: bg2, index: i2 }, `${x2}-${y2}`);
  }) }) }) });
};
const ProgressMember = ({ x: x2, y: y2, bg: bg2, index: index2 }) => {
  const size = 8;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `absolute rounded-full ${bg2} transition-all duration-500`,
      style: {
        transform: `translateX(${x2}px) translateY(${y2}px)`,
        height: size,
        width: size
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex transform-gpu items-center justify-center text-[8px] will-change-auto" })
    }
  );
};
const AddressListView = ({
  description: description2,
  distance_meters,
  types,
  terms,
  place_id,
  matched_substrings,
  structured_formatting
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full flex-col px-2 py-1", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-semibold", children: structured_formatting.main_text }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs", children: structured_formatting.secondary_text })
  ] });
};
const useAppear = (timer = 500) => {
  const [show, setShow] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const timeout = setTimeout(() => {
      setShow(true);
    }, timer);
    return () => {
      clearTimeout(timeout);
    };
  }, []);
  return { show, setShow };
};
const useListener = (type, listener) => {
  reactExports.useEffect(() => {
    window.addEventListener(type, listener);
    return () => {
      window.removeEventListener(type, listener);
    };
  }, []);
};
const useFormKeyListener = (getFormValues, handler) => {
  useListener("keyup", () => {
    const values2 = getFormValues();
    handler(values2);
  });
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var fastDeepEqual = function equal2(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor)
      return false;
    var length, i2, keys2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal2(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (a2.constructor === RegExp)
      return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf)
      return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString)
      return a2.toString() === b2.toString();
    keys2 = Object.keys(a2);
    length = keys2.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!equal2(a2[key], b2[key]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
const DEFAULT_ID = "__googleMapsScriptId";
var LoaderStatus;
(function(LoaderStatus2) {
  LoaderStatus2[LoaderStatus2["INITIALIZED"] = 0] = "INITIALIZED";
  LoaderStatus2[LoaderStatus2["LOADING"] = 1] = "LOADING";
  LoaderStatus2[LoaderStatus2["SUCCESS"] = 2] = "SUCCESS";
  LoaderStatus2[LoaderStatus2["FAILURE"] = 3] = "FAILURE";
})(LoaderStatus || (LoaderStatus = {}));
class Loader {
  /**
   * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set
   * using this library, instead the defaults are set by the Google Maps
   * JavaScript API server.
   *
   * ```
   * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});
   * ```
   */
  constructor({ apiKey, authReferrerPolicy, channel, client: client2, id: id2 = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url = "https://maps.googleapis.com/maps/api/js", version: version2 }) {
    this.callbacks = [];
    this.done = false;
    this.loading = false;
    this.errors = [];
    this.apiKey = apiKey;
    this.authReferrerPolicy = authReferrerPolicy;
    this.channel = channel;
    this.client = client2;
    this.id = id2 || DEFAULT_ID;
    this.language = language;
    this.libraries = libraries;
    this.mapIds = mapIds;
    this.nonce = nonce;
    this.region = region;
    this.retries = retries;
    this.url = url;
    this.version = version2;
    if (Loader.instance) {
      if (!fastDeepEqual(this.options, Loader.instance.options)) {
        throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);
      }
      return Loader.instance;
    }
    Loader.instance = this;
  }
  get options() {
    return {
      version: this.version,
      apiKey: this.apiKey,
      channel: this.channel,
      client: this.client,
      id: this.id,
      libraries: this.libraries,
      language: this.language,
      region: this.region,
      mapIds: this.mapIds,
      nonce: this.nonce,
      url: this.url,
      authReferrerPolicy: this.authReferrerPolicy
    };
  }
  get status() {
    if (this.errors.length) {
      return LoaderStatus.FAILURE;
    }
    if (this.done) {
      return LoaderStatus.SUCCESS;
    }
    if (this.loading) {
      return LoaderStatus.LOADING;
    }
    return LoaderStatus.INITIALIZED;
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  /**
   * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].
   *
   * @ignore
   * @deprecated
   */
  createUrl() {
    let url = this.url;
    url += `?callback=__googleMapsCallback`;
    if (this.apiKey) {
      url += `&key=${this.apiKey}`;
    }
    if (this.channel) {
      url += `&channel=${this.channel}`;
    }
    if (this.client) {
      url += `&client=${this.client}`;
    }
    if (this.libraries.length > 0) {
      url += `&libraries=${this.libraries.join(",")}`;
    }
    if (this.language) {
      url += `&language=${this.language}`;
    }
    if (this.region) {
      url += `&region=${this.region}`;
    }
    if (this.version) {
      url += `&v=${this.version}`;
    }
    if (this.mapIds) {
      url += `&map_ids=${this.mapIds.join(",")}`;
    }
    if (this.authReferrerPolicy) {
      url += `&auth_referrer_policy=${this.authReferrerPolicy}`;
    }
    return url;
  }
  deleteScript() {
    const script = document.getElementById(this.id);
    if (script) {
      script.remove();
    }
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   * @deprecated, use importLibrary() instead.
   */
  load() {
    return this.loadPromise();
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   *
   * @ignore
   * @deprecated, use importLibrary() instead.
   */
  loadPromise() {
    return new Promise((resolve, reject) => {
      this.loadCallback((err) => {
        if (!err) {
          resolve(window.google);
        } else {
          reject(err.error);
        }
      });
    });
  }
  importLibrary(name2) {
    this.execute();
    return google.maps.importLibrary(name2);
  }
  /**
   * Load the Google Maps JavaScript API script with a callback.
   * @deprecated, use importLibrary() instead.
   */
  loadCallback(fn) {
    this.callbacks.push(fn);
    this.execute();
  }
  /**
   * Set the script on document.
   */
  setScript() {
    var _a2, _b2;
    if (document.getElementById(this.id)) {
      this.callback();
      return;
    }
    const params = {
      key: this.apiKey,
      channel: this.channel,
      client: this.client,
      libraries: this.libraries.length && this.libraries,
      v: this.version,
      mapIds: this.mapIds,
      language: this.language,
      region: this.region,
      authReferrerPolicy: this.authReferrerPolicy
    };
    Object.keys(params).forEach(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (key) => !params[key] && delete params[key]
    );
    if (!((_b2 = (_a2 = window === null || window === void 0 ? void 0 : window.google) === null || _a2 === void 0 ? void 0 : _a2.maps) === null || _b2 === void 0 ? void 0 : _b2.importLibrary)) {
      ((g2) => {
        let h2, a2, k2, p2 = "The Google Maps JavaScript API", c2 = "google", l2 = "importLibrary", q2 = "__ib__", m2 = document, b2 = window;
        b2 = b2[c2] || (b2[c2] = {});
        const d2 = b2.maps || (b2.maps = {}), r2 = /* @__PURE__ */ new Set(), e2 = new URLSearchParams(), u2 = () => (
          // @ts-ignore
          h2 || (h2 = new Promise((f2, n2) => __awaiter(this, void 0, void 0, function* () {
            var _a3;
            yield a2 = m2.createElement("script");
            a2.id = this.id;
            e2.set("libraries", [...r2] + "");
            for (k2 in g2)
              e2.set(k2.replace(/[A-Z]/g, (t2) => "_" + t2[0].toLowerCase()), g2[k2]);
            e2.set("callback", c2 + ".maps." + q2);
            a2.src = this.url + `?` + e2;
            d2[q2] = f2;
            a2.onerror = () => h2 = n2(Error(p2 + " could not load."));
            a2.nonce = this.nonce || ((_a3 = m2.querySelector("script[nonce]")) === null || _a3 === void 0 ? void 0 : _a3.nonce) || "";
            m2.head.append(a2);
          })))
        );
        d2[l2] ? console.warn(p2 + " only loads once. Ignoring:", g2) : d2[l2] = (f2, ...n2) => r2.add(f2) && u2().then(() => d2[l2](f2, ...n2));
      })(params);
    }
    const libraryPromises = this.libraries.map((library) => this.importLibrary(library));
    if (!libraryPromises.length) {
      libraryPromises.push(this.importLibrary("core"));
    }
    Promise.all(libraryPromises).then(() => this.callback(), (error) => {
      const event = new ErrorEvent("error", { error });
      this.loadErrorCallback(event);
    });
  }
  /**
   * Reset the loader state.
   */
  reset() {
    this.deleteScript();
    this.done = false;
    this.loading = false;
    this.errors = [];
    this.onerrorEvent = null;
  }
  resetIfRetryingFailed() {
    if (this.failed) {
      this.reset();
    }
  }
  loadErrorCallback(e2) {
    this.errors.push(e2);
    if (this.errors.length <= this.retries) {
      const delay = this.errors.length * Math.pow(2, this.errors.length);
      console.error(`Failed to load Google Maps script, retrying in ${delay} ms.`);
      setTimeout(() => {
        this.deleteScript();
        this.setScript();
      }, delay);
    } else {
      this.onerrorEvent = e2;
      this.callback();
    }
  }
  callback() {
    this.done = true;
    this.loading = false;
    this.callbacks.forEach((cb2) => {
      cb2(this.onerrorEvent);
    });
    this.callbacks = [];
  }
  execute() {
    this.resetIfRetryingFailed();
    if (this.done) {
      this.callback();
    } else {
      if (window.google && window.google.maps && window.google.maps.version) {
        console.warn("Google Maps already loaded outside @googlemaps/js-api-loader.This may result in undesirable behavior as options and script parameters may not match.");
        this.callback();
        return;
      }
      if (this.loading)
        ;
      else {
        this.loading = true;
        this.setScript();
      }
    }
  }
}
const loader = new Loader({
  apiKey: "AIzaSyC32_38njmAdsjfOqVXY7v5oc6uwGZMRyE"
});
let locationDenied;
let currentLocation;
const getCurrentPosition = async () => new Promise((resolve) => {
  navigator.geolocation.getCurrentPosition(resolve, resolve);
});
let placesApi;
let autocompleteService;
const initPlaces = async (getLocation) => {
  if (!placesApi) {
    if (getLocation && !currentLocation && !locationDenied) {
      const location = await getCurrentPosition();
      if (location instanceof GeolocationPosition) {
        currentLocation = location;
      } else {
        locationDenied = location;
      }
    }
    placesApi = await loader.importLibrary("places");
    autocompleteService = new placesApi.AutocompleteService();
  }
  return { placesApi, autocompleteService };
};
let getPlacePrediction;
const initPlacePrediction = async () => {
  if (!getPlacePrediction) {
    const { autocompleteService: autocompleteService2 } = await initPlaces();
    getPlacePrediction = async (input) => {
      return autocompleteService2.getPlacePredictions({
        input,
        locationBias: currentLocation ? {
          lat: currentLocation.coords.latitude,
          lng: currentLocation.coords.longitude
        } : null
      });
    };
  }
  return getPlacePrediction;
};
const autocompletePlace = async (input) => {
  const getPlacePrediction2 = await initPlacePrediction();
  return getPlacePrediction2(input);
};
const renderListView = (Component) => {
  return (item, { active, selected }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `pointer-events-none absolute h-full w-full rounded ${selected ? "bg-purple-950/20 dark:bg-purple-50/10" : active ? "bg-purple-950/10 dark:bg-purple-50/10" : "bg-transparent dark:bg-transparent"}`
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Component, { ...item })
  ] });
};
const useFormCompletion = (getFormValues, changeCompletion, deltaScalar = 0.1) => {
  const currentLength = reactExports.useRef(reduceStringLength(getFormValues()));
  const handler = (values2) => {
    const newLength = reduceStringLength(values2);
    const delta = newLength - currentLength.current;
    if (delta)
      changeCompletion(delta * deltaScalar);
    currentLength.current = newLength;
  };
  useFormKeyListener(getFormValues, handler);
};
const orgAddressSchema = z.object({
  website: z.string().url({ message: "Please enter a valid URL." }),
  phone: z.string().length(10, { message: "Please enter a valid number." })
});
const OrgFinal = ({
  finish,
  changeCompletion
}) => {
  const { show } = useAppear();
  const { organization, setKyb, kybDocument } = useNoauth();
  const { register, handleSubmit, formState, getValues } = useForm({
    resolver: t(orgAddressSchema),
    reValidateMode: "onBlur",
    shouldUseNativeValidation: false,
    defaultValues: {
      website: kybDocument?.website ?? "",
      phone: kybDocument?.phone ?? ""
    }
  });
  const [chosenAddress, setChosenAddress] = reactExports.useState();
  const [addresses, setAddresses] = reactExports.useState([]);
  const [addressLoading, setAddressLoading] = reactExports.useState(false);
  useFormCompletion(getValues, changeCompletion, 5e-3);
  reactExports.useEffect(() => {
    initPlacePrediction();
  }, []);
  const autoComplete = async (query) => {
    const res = await autocompletePlace(query);
    return res;
  };
  const onQuery = async (query) => {
    if (query) {
      setAddressLoading(true);
      const res = await autoComplete(query);
      if (res)
        setAddresses(res.predictions);
      setAddressLoading(false);
    }
  };
  const onSubmit = ({ website, phone }) => {
    setKyb({
      website,
      phone,
      address: {
        googlePlacesId: chosenAddress?.place_id ?? "",
        jsonAddress: {
          address: chosenAddress?.description,
          fmt: chosenAddress?.structured_formatting
        }
      }
    });
    finish?.();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    tt$1,
    {
      show,
      appear: true,
      as: "div",
      className: "w-full",
      unmount: false,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          tt$1.Child,
          {
            as: reactExports.Fragment,
            enter: "duration-500 delay-700 ease-out",
            enterFrom: "translate-y-8 opacity-0 scale-90",
            enterTo: "translate-y-0 opacity-100 scale-100",
            unmount: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center", children: "Your Organization" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          tt$1.Child,
          {
            as: "div",
            enter: "duration-1000 delay-[1.5s] ease-out",
            enterFrom: "opacity-0 max-h-[0px]",
            enterTo: "opacity-100 max-h-screen",
            unmount: false,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex w-full justify-center text-center text-lg leading-5", children: [
                "Tell us about ",
                organization,
                ".",
                /* @__PURE__ */ jsxRuntimeExports.jsx(Hint, { position: "-translate-x-[260px]", maxWidth: "max-w-[390px]", children: "We need information about your business' sub-merchant underwriting in order to process payments for you." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "py-2", onSubmit: handleSubmit(onSubmit), children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    type: "tel",
                    name: "phone",
                    label: "Phone",
                    register,
                    placeholder: "404 803 9945",
                    className: "mb-4 w-full",
                    inferIcon: true,
                    labelHint: ""
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    type: "url",
                    name: "website",
                    label: "Website",
                    register,
                    placeholder: "https://acme.com",
                    className: "mb-4 w-full",
                    inferIcon: true,
                    labelHint: "",
                    labelUrl: "https://en.wikipedia.org/wiki/Trade_name"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-4 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ComboBox,
                  {
                    items: addresses,
                    display: "description",
                    renderItem: renderListView(AddressListView),
                    placeholder: "3 Bethesda Metro Center, Bethesda, MD",
                    label: "Address",
                    onQuery,
                    onSelectItem: setChosenAddress,
                    loading: addressLoading,
                    prefiltered: true,
                    float: true
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    block: true,
                    intent: "primary",
                    type: "submit",
                    disabled: !formState.isValid || !chosenAddress,
                    children: "Continue"
                  }
                )
              ] }) })
            ]
          }
        )
      ]
    }
  );
};
const orgInformationSchema = z.object({
  merchantName: z.string().min(1),
  subMerchantDba: z.string().min(1),
  taxId: z.string().min(5)
});
const OrgInformation = ({
  goToStage,
  changeCompletion
}) => {
  const { show } = useAppear();
  const { organization, setKyb, kybDocument } = useNoauth();
  const { register, handleSubmit, formState, getValues, watch } = useForm({
    resolver: t(orgInformationSchema),
    mode: "onTouched",
    reValidateMode: "onBlur",
    defaultValues: {
      merchantName: organization,
      subMerchantDba: kybDocument?.subMerchantDba ?? "",
      taxId: kybDocument?.taxId ?? ""
    }
  });
  useFormCompletion(getValues, changeCompletion, 0.02);
  const onSubmit = ({
    merchantName: merchantName2,
    subMerchantDba: subMerchantDba2,
    taxId: taxId2
  }) => {
    setKyb({ merchantName: merchantName2, subMerchantDba: subMerchantDba2, taxId: taxId2 });
    goToStage?.("ORGFINAL");
  };
  const merchantName = watch("merchantName");
  const subMerchantDba = watch("subMerchantDba");
  const taxId = watch("taxId");
  reactExports.useEffect(() => {
    setKyb({ merchantName, subMerchantDba, taxId });
  }, [merchantName, subMerchantDba, taxId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    tt$1,
    {
      show,
      appear: true,
      as: "div",
      unmount: false,
      className: "w-full",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          tt$1.Child,
          {
            as: reactExports.Fragment,
            enter: "duration-500 delay-700 ease-out",
            enterFrom: "translate-y-8 opacity-0 scale-90",
            enterTo: "translate-y-0 opacity-100 scale-100",
            unmount: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-center", children: "Your Organization" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          tt$1.Child,
          {
            as: "div",
            enter: "duration-1000 delay-[1.5s] ease-out",
            enterFrom: "opacity-0 max-h-[0px]",
            enterTo: "opacity-100 max-h-screen",
            unmount: false,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex w-full justify-center text-center text-lg leading-5", children: [
                "Tell us about ",
                organization,
                ".",
                /* @__PURE__ */ jsxRuntimeExports.jsx(Hint, { position: "-translate-x-[260px]", maxWidth: "max-w-[390px]", children: "We need information about your business' sub-merchant underwriting in order to process payments for you." })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "py-2", onSubmit: handleSubmit(onSubmit), children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 flex w-full flex-wrap items-center justify-between gap-4 lg:flex-nowrap", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextInput,
                    {
                      type: "text",
                      name: "merchantName",
                      label: "Merchant Name",
                      register,
                      placeholder: "Acme Inc.",
                      className: "w-full lg:w-[50%]",
                      labelHint: "The legal name of the business enterprise owned by the sub-merchant (your organization)."
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextInput,
                    {
                      type: "text",
                      name: "subMerchantDba",
                      label: "Sub-merchant DBA",
                      register,
                      placeholder: "ACME CO",
                      className: "w-full lg:w-[50%]",
                      labelHint: "Your organization's trade name by which it Does Business As.",
                      labelUrl: "https://en.wikipedia.org/wiki/Trade_name"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-4 w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    type: "text",
                    name: "taxId",
                    label: "Tax ID",
                    register,
                    placeholder: "12-3456789",
                    className: "w-full",
                    labelHint: "Tax identification number of the organization by {LOCALE}"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    block: true,
                    intent: "primary",
                    type: "submit",
                    disabled: !formState.isValid,
                    children: "Continue"
                  }
                )
              ] }) })
            ]
          }
        )
      ]
    }
  );
};
const userInfoSchema = z.object({
  role: z.string().min(2, { message: "Please enter your full role." }),
  use: z.string()
});
const UserInformation = ({
  goToStage,
  changeCompletion
}) => {
  const { show } = useAppear();
  const { name: name2, rawUserData, setRaw } = useNoauth();
  const { register, handleSubmit, formState, getValues, watch } = useForm({
    resolver: t(userInfoSchema),
    reValidateMode: "onBlur",
    shouldUseNativeValidation: false,
    defaultValues: (() => {
      let role = "";
      let use = "";
      if (rawUserData) {
        if ("role" in rawUserData)
          role = rawUserData.role;
        if ("use" in rawUserData)
          use = rawUserData.use;
      }
      return {
        role,
        use
      };
    })()
  });
  const onSubmit = ({ role, use }) => {
    setRaw({ role, use });
    goToStage?.("ORGINFO");
  };
  useFormCompletion(getValues, changeCompletion);
  const roleValue = watch("role");
  const useValue = watch("use");
  reactExports.useEffect(() => {
    setRaw({ role: roleValue, use: useValue });
  }, [roleValue, useValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    tt$1,
    {
      show,
      appear: true,
      as: "div",
      className: "w-full",
      unmount: false,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          tt$1.Child,
          {
            as: reactExports.Fragment,
            enter: "duration-500 delay-700 ease-out",
            enterFrom: "translate-y-8 opacity-0 scale-90",
            enterTo: "translate-y-0 opacity-100 scale-100",
            unmount: false,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-center", children: [
              "Hi, ",
              name2?.split(" ")[0] ?? "friend",
              "."
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          tt$1.Child,
          {
            as: "div",
            enter: "duration-1000 delay-[1.5s] ease-out",
            enterFrom: "opacity-0 max-h-[0px]",
            enterTo: "opacity-100 max-h-[300px]",
            unmount: false,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 text-center text-lg leading-5", children: "Tell us a little more about yourself." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "py-2", onSubmit: handleSubmit(onSubmit), children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    type: "text",
                    name: "role",
                    label: "Your Role",
                    register,
                    placeholder: "Admin, Sales, etc.",
                    error: formState.errors.role?.message ?? (formState.touchedFields.role && roleValue.length < 2 && "Please enter your full role."),
                    className: "mb-4",
                    block: true
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextInput,
                  {
                    type: "text",
                    name: "use",
                    label: "How do you plan to use Beacon?",
                    register,
                    placeholder: "Processing receivables, paying bills, etc.",
                    className: "mb-4",
                    block: true,
                    textarea: true
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    block: true,
                    intent: "primary",
                    type: "submit",
                    disabled: !formState.isValid,
                    children: "Continue"
                  }
                )
              ] }) })
            ]
          }
        )
      ]
    }
  );
};
const stageMap = {
  ORGNONE: NoOrg,
  USERINFO: UserInformation,
  ORGINFO: OrgInformation,
  ORGFINAL: OrgFinal
};
const OnboardingPage = observer(() => {
  const orgSearchFired = reactExports.useRef(false);
  const { loading, setGlobalLoading } = useGlobalLoading();
  const { email, organization, submitOnboarding } = useNoauth();
  const session = dist.useSession();
  const org = organization ?? session?.user.user_metadata.organization;
  const [complete, setComplete] = reactExports.useState(
    org ? kvStore.get(EPHEMERAL_KEYS.ONBOARDING) ?? "USERINFO" : "ORGNONE"
  );
  const [stage, setStage] = reactExports.useState(complete);
  const [pctComplete, setPctComplete] = reactExports.useState(
    minCompletionMap[complete] ?? 0
  );
  reactExports.useEffect(() => {
    if (!org && session?.user && email && !orgSearchFired.current) {
      setGlobalLoading({
        loading: true,
        meta: "Finding your organization..."
      });
      orgSearchFired.current = true;
      minTime(
        api$1.user.checkOrgExists.query(email).then(async (orgId) => {
          if (!orgId) {
            setStage("ORGNONE");
          } else {
            submitOnboarding(orgId);
          }
        }).catch(() => {
          orgSearchFired.current = false;
        }).finally(() => {
          setGlobalLoading({ loading: false });
        }),
        3e3
      );
    } else if (org) {
      setGlobalLoading({ loading: false });
    }
  }, [session, email]);
  reactExports.useEffect(() => {
    if (order.indexOf(stage) > order.indexOf(complete)) {
      setComplete(stage);
      kvStore.set(EPHEMERAL_KEYS.ONBOARDING, stage.toString());
    }
  }, [stage]);
  const goToStage = (stage2) => {
    setStage(stage2);
  };
  const changeCompletion = (completion) => {
    const onPreviousStage = order.indexOf(stage) < order.indexOf(complete);
    setPctComplete((pctComplete2) => {
      if (pctComplete2 + completion > maxPendingMap[stage] && onPreviousStage) {
        return pctComplete2;
      }
      return Math.max(
        Math.min(completion + pctComplete2, maxPendingMap[stage]),
        0
      );
    });
  };
  const map2 = mapObject(stageMap, (_2, fc2) => ({
    props: { goToStage, changeCompletion, finish: submitOnboarding },
    el: fc2
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full w-full flex-col-reverse overflow-hidden md:flex-row-reverse", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full md:w-[422px] lg:w-[618px]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-full w-full flex-col items-start justify-center overflow-hidden bg-black/10 px-2 shadow-md shadow-black/30 md:items-center md:px-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Fade,
        {
          delay: true,
          appear: true,
          block: true,
          map: map2,
          focusedIndex: stage,
          className: "flex flex-1 flex-col items-center justify-center"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        OnboardingNav,
        {
          loading,
          setStage,
          stage,
          complete
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative h-auto flex-1 md:flex-grow", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden h-full w-full items-center justify-center md:flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        tt$1,
        {
          as: "div",
          className: "h-full w-full",
          show: !loading && stage !== "ORGNONE",
          enter: "duration-300 ease-in delay-300",
          enterFrom: "scale-75 opacity-0",
          enterTo: "scale-100 opacity-100",
          leave: "duration-500 ease-out",
          leaveFrom: "scale-100 opacity-100",
          leaveTo: "scale-50 opacity-0",
          autoFocus: false,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            OnboardingProgress,
            {
              stage,
              complete: pctComplete,
              clamp: maxPendingMap[complete] ?? 0,
              pending: maxPendingMap[complete] ?? 0
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(NoOrgTransition, { show: !loading && stage === "ORGNONE" })
    ] }) })
  ] });
});
const paymentSucess = "" + new URL("paymentSucess-2b42f32d.png", import.meta.url).href;
const PaymentSuccess = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { className: "w-[653px] pb-[171px] pl-[93px] pr-[96px] pt-[111px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        className: "h-[142px] w-[142px]",
        src: paymentSucess,
        alt: "paymentSucess"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-[30px] flex flex-col items-center justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[30px] font-[600] text-[#36597D]", children: "Payment successful !" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Thank you, your payment was processed successful." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-[30px]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between pb-[10px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Transaction ID" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: "87654333" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between pb-[10px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Date of transaction" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: "11/07/2023" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex justify-between pb-[15px]",
          style: { borderBottom: "1px solid rgba(139, 158, 176, 0.20)" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Payment Type" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: "Card 4321" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-[30px]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between pb-[10px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Payment amount" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: "$122.99" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "mb-[15px] flex justify-between pb-[15px]",
          style: { borderBottom: "1px solid rgba(139, 158, 176, 0.20)" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Payment method fee" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: "$0.00" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex justify-between pb-[15px]",
          style: { borderBottom: "1px solid rgba(139, 158, 176, 0.20)" },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Total amount" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: "$122.99" })
          ]
        }
      )
    ] })
  ] });
};
const LogoIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAArqSURBVHgB7ZtfbFtXHcd/58+1ncRJbxECJm3yLYKpD4i4E6AOIXIDHVunjfiuq7q2D7EnTQIhZAcJhIQmOw8IGA9NHxC82REqKesqOwyU0lXE5Z/GJqiD0AYPkBsqoT0g5Ya09Z97zzn8jrOigSZt9N7YqXQ/anWPTyz73K9/v/P7/c45FyAmJiYmJiYmJiYmJiYmJiYmJuaugcAQMFerphgZqSsGpiLKU4S4khiVzgPHNuAuYzgC/vL5qjBUc/vBE4v6dfrVJVtSWgSqPKnuTiEHyv7VC6tv16+FHPvD+Wuj185XU9eWLLgLGLgFvndlyQZuFBUFT1CRBUpAtyWVLjDW2D58fHns90t5dOsijq4lQc13Dp103/GD/3EuA93eFhwoeDBABi7g+396oYSClSUJnH8ePdm83W/+Ct2YkCzOizNAiIcjawRMmYRBVhJlEUpaispWwMBVhJqKCuyDLAptEwKWxPcD69+RCQrwn1oE0WuioC7sIgMX8J7GhVVFZO2NmROL5s8uZgzam5YGVSiKBSC2ZJJsohiWIpAFDjaKbUqC1kmJpagCyVAbAkQytYl9a0rJq0BRMEamJH6+EmIeeNAClsjhDzELBIW893QNdomBCmhV62aQDjYFkQ5wNis4eIrLFuhITOWGJCyHVjQrqTIVU66iVPd7aJWAlqYjtqndHd/TVCDWhEEUvs6hBZrKgEoAZAPfWgaQIKA313fn6+cW8Ks34b7T87ALcBggIilsGuCcx9jMTbVd8B4reGa9aiZ4ukg5qaA1LRNDOZJ3WltTbz+X6eBChcoqoDkGJANU1oCRq0JBmeMPEdzszrFxbjOarItrVQeFK9G/L1Xl9R9NwX2nrkLEDNYCaxerYIDpnj7mmNWqmU5PFCVXWQwUZ99wjjfh/8S8VjU7LIWuCrNo1YuAFondJV8Sh/MApwFWFB865cB61aQksSqt04cgYgYmoHZfLuRmwOgBUCoDCVnBKHz2+qkTDQhJX0iaKAGjGUrVssAI3u10HD6RLCuh1sT9p2t0/VyFCNJCQUN/31sZmIAHv3cxLxidwmZLJlQOb9JxC06kKYfxp/OTTKoFxdWyBJrxR9rzhp9c9e8/dUhbIQN06wOnpiFCKAwI0qNl1sMvFOrAX59+Yjpq8TT+R55aw+hRoD06w3CeTN1IZZUgDf465p4YUNACIWoGIuBHv7Vc5j6xaBc2/vKlJ0qwi+ikWylVIIEyUcwy78Ail5jOIESojdTfLmYgQnZdwEPPvjhJe6pCfWi89lWnAgOgLyIQh0qShQAsEMrS/SiqG4iuBRGyqwJ+4mv1HA9kA1MXl/hqDgaIFpFJUuCElKkgng40FBNMfoNE6se7kgfapbrZU4mq8uWGkAqjLy298tyMCwNm+2MnGunf/XgW6xyrwyb20SDAFFtClERugdNPX5oUN406FfIs7RHFfNJ65bnHFmFIcCnnSABZ5gc2unMWVGIdIiRSAT97cmWW+nLBkCTPb9Ep6pMi68KulFDvFu9BdGVBFpmPIgplRr3WGJmAjzgrs2htJbHddWib5olPbBz0xq9/8HgTho0vaxhAsnouhIiJRMBHH72cRWsr9YL2dAKSNvgky32weJfWYA/gTZ9sMkUtDGZZiJjQAubsFctoyzOJQDmpTso0AlLkvlojPjW5hMiL9zsFxWtgKmXp/RiIkNAC8i4vYrCoNS4ddZM+pgxdWGRdMoXu6106f7QJewR04TUa4Hg7qUitMJSATx1csfTkXP/Nw4u5wysWllD6dZMH1MXg4cJeQkILLRBXv6gNERJKQMZ4TlufbhuClWhXYerCbHThJusNrMx+V4z1DBfduEkELeo1SIiIUHeJYs0s/fFIP8fjPTp58ZWHGywgM9CFLVw4cGEP4TqOh+kMcEHcUUhHVo+HEnCCj/SveWvVpL2dPhTONJRssWBvWaCG4RxIfLiKqzLlDyxFs20a6i73p3Y8gad41gjYmm5jLgidTsrDBYT9sIfQC7rE70djtx9MmHEGIiCUgGZyfOeaSqPZTWz2PxDnvkZrGgUk+2APYfi+hUFkDdcj9Vy4jiLm7l26YENIwglopL2qvWmifO57RvZZum/CGO2bJd9jLqwIzzDJ1qGjPMwU1pigLaxMZiEkoe5yPDm+huJlK60DLlqhpfvMRHrtG4dey4xAovXMh1cjz/zvFNbG0rIdrPFAuzHVKY2HC62mVQ0XkUMJmAjoAklAUbfHjTSc+0w7kzbGmhOJEWfCGFseT0zYsEfgPcj++cvHm9zHkq6Lbizw5rtwlcJ4KCsMJaDTJB7BBPXCw6qU5mPzBktUUmNmY9zYN5XmZmt/at8U7AEOVuo4/xFXt9F1J7G9gdUSBJzWeI/YEILQE9WxK2QeRZxhFDJUUTNjmJPjidGND+7/wOQYT2189/B1G4ZMCkiZdVU/XyVdtMQ5/OkxIuuNLSro8Fz4NjgpO1JCTlFwJYGFFE02RnmqMjIytmAa42UYIoe/XrewKrJbFaeZrdSzPNixRF3WaUgPQhGJgNqVn7xCHKw3t3DDwcRdh1XccbbelzCLY4mRjSXbt2FY9IwyJvUV3TR8VoRAzWe/iUL23nRpP9wWSaS5xvErpEIpTOOQCnpYSkEpyRKbhsHPVG0V6TLSu+FTX3jR1pamtxQ+/pWf5KGnttASXdZhRdL5j0uHYldPJlw4omxKoKoPrKBVNo5dJgPbmbPzK5biouonSV6KHqEJo56g/nSHQ1YwNvvqdz5feODZel4yABS1BnfIQI52vPCQquIljyJWUMRd3yOxc3WTjSXrwtjZSlWGqnaZ7xgkmQkSopIkgT4WYRopXn3124+HOuoxkHLhyZdIAS8tdOnKxSNqV4OKbdfNJB9ZxcB21uixKVxIPUO2fSfRM4q4wV7S4omA2aOK11knKEBIBlZvoXhzRJ+8pSji51Qkhfz/8ghuL4yNongdWsNavIjzn40iNjlN1nGxo8XasKy2k1WFeyMJEky/vOC4EJKBng984YhaJRQ8FHMKv3ir5wNu9+xEw7Ac+/SVYsBEWXFCJJUmXj3J3jzpysANmPLAoE3B24vNWnQHmwZ6QhUDSgUrqGnajyrgGQas4/xYIwLnxl+QO9qvfSq7YgvOyspXWSZpUyqxoahqSaKAERQOc9Ofv3DUhV1i4IfMUbBrfXcmcLsG3cL/OsXJ4GAWQcDqO4n5zMHfTnWDtq0MKKFltRRX8+dbDzVhCAzUAvsQWBsVsN5mYEmAOSoxOjNYx/yxIkX/VP4Cimy++V4vEMJr9zpwQ9w0b/ht82bQMdtBO3sL/9aW7fkfvn5kAYbIwAVUEmq3KBQCBgVDQH1bwHSaQB6tsoqC1bZ9KBSaOycI6rayGDBoM4bLZGY2xUenUv52/laAG0RYPn6/9ckWDJmhPCuHqUz9XwEUxgywcADVAMVIpQB8tEBMC2b1gzIYrT2cxjxsWuju+1H49UCJXDvouJ3u9vQXX77HhT3AUATUFQpG4+KTl4lTf0RZQkAVRWpCALXb85+2Pn3FeS6DIuZhx0pdn2HkvhRN5I6CoQioQRFLOO9lbpd3zz+k8kzBjNxZjNB5Y390aJEutrP6uTl077nb7r1XGJqAGnRl/dzcLKY1pSdeIv91jkZboEzALOqYw9Rn/sRlEunjCVExVAE1S+jCGEz0RvfkW/txYK5UsIgrPE2IiYmJiYmJiYmJiYmJiYmJiYmJiYJ/Aw51teJHs5MDAAAAAElFTkSuQmCC";
const Arrow = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACZSURBVHgB7dLLDYMwDAZgp12AAuo5jVIgTNGN2g1wN+hInaKnHjpAhViAGDhwS3hLXPxJkSLZ8q9EBmCM7Uel5q6SvJjSJ1Pz8NUPvoKtrSAiHApRSVaQhRfUIoAlpM7wcjXkCumGdzWpc4Q1XCFzhh/HGqry/w7CWLRXDOMznKLoRiSwPc/f94Owlf4lm3zLUIjU/o1hjLk1ZCkwOzGr4+AAAAAASUVORK5CYII=";
const CheckboxActiveIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASZSURBVHgBnVZLbBxFEK0ar42zOOvN2t6ATWIsFClCXLggIOIAQkkgDopwjDigCCTEhY9AyoWPhMHiEJPAIcCBiy+IGxeQEIjwExFYKIiPAolAkZFjEmSv7VWC1/bsTBdVXd09M8ktY/f2TE93vXpVr6sHIHcRUZXbq9xm6dqvn7lNc7s5bxtzIIfWWvDWyc+T2rkzKf51JiGCFHkcDKXcDM8x3MuVIt/JGMkYz0B9l8JNw12wZ3QL3XNfdZnNvoaIxwMQz356ZZGOvX/EdC43kkgWpcbkgOTP3pMF5HFj9I4oQXcHxq2R577+Er00ORJvvaHrSQb7QBZvZ6yTU4fToeWGiXg6eO9kGWmvQOGdyTHUuWRBTYF9baBkJo/uuFDtLd0WMcjhH7+lLc0lkHuZz5NCQH3PTsk4+wWMJ43IvUVCCYx/tM96NRbi6LOPF2sG4CkxvnPmBFznDbpgOjAMmHKDYoMM6rzIGSRUDOkVjDIJ0B+nL5cMwZgA7Vj4Bzq9g9qjUhAmboF/h4g5ttrsmP0ndcLNl+vPs6tdHPmtAhRb4xljWWFFkBM+upCgZ5p5jiIm0FBgYb7txXhKbQFqq+fWGcIwWyKCVAALtqxTds39+yow9d4wPPRILUuTB9F8CosNy0ioa8Q0qzk1WAGoSU82u/aP98Kjj9egv16CAwwU5qBSRpc3Vm1bQwcOAxQtZ1Vj7l31PvDP/vGKBfLX2d/X3AIfSsfJghoNHV4ZHs0ADm3voL1j3bwfInRpt+oYZZDRg5Wwam52A44fueh9ASzw5stAHBhB2B8++gBPvNCNex/uhmdf3gx9A5ENxYNjPbDv4OZg4/zfMbw5cRFaq7KtLecsV+7GcI5KAuTZeLpu08CmsnrGjOC5V6rw66l1uPeB8tUgLWNpoN9/5FKkSZZ6ckXoPIhT27tvrMJaiwJYHmSeQY5OLBAzcWtIhQNQVIw8+NCFDDnpOV5wYc4UwDKQNhybaJCMq2L9NvD7zVcYFVZiVAwOCCmoGL0ikI0m8M7kZTZqAsjbrzegtaalyFYLaxh1md8/uS1NPkcuicXCBq508fr5uQSnXrxEt9zaAd9/vepehEqCFIqs7mM5nyAXQz49EhWDZQsQaLhS7QRkx5YWE1z8JnYOGLfZQkq0gBmgHAs3D+SY2dASlJWaoJRQ/7KdHCLsLBHlC7WVbSg7Npy+/pLL0b8DgzAf9Ig+R1AwUyja4HkThgHSMkmuqFsd8k+11rnQTqNZAZq5cRuczwqCShU9F1IPg3RzR4COYXDOlh7H2Bey2++snKLIzAnQd3vG8atN12MzOIxa3YEgX091NXql5d6RP5cKGYNyT0dz94H6D/Bf/EXEgVyv9sFHh56H6XIZV9yZnTFSPaBnIE0BkEIQAstMIN3lqPnYM4PT60l8Yni4upL/3LqDu12ffJje9ctMvKu5kg5e/cGR+wrSTy372UXhYyWF3r7oXH2oNLt7vP/LSiX6dOe2nt+8C5ADk7p/N7e6MVDnHa3nCQ+YlHd4wnKNgKRPjagZrHZlnryXuUlKl/hIPd0RL/00MjKy7m3/D/vMb7btSk2AAAAAAElFTkSuQmCC";
const CheckboxInactiveIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAMDSURBVHgBpZa9bhRBDID9s3cRCXWooU5eAvrwKPT08BQ8RVLzFEmdggKFiChCURQ4LjvYM/bYcxshIea0t7Pz48/22N5FsFZKOZDbiVxHch3D/7VLuc4Q8bMPoEEO5fbx7mF7ePVjAw8/CzyWGchW1EXUNugN0TYTAcsD67j8EUkfCfb3WC6EZ2u+lqn3Arx20Ker21+HX283JrXdulCyflJPIVSVEOEyydpnrPeVUFnAzwX4bK/C3rFAXt/cbd58udlAkR/a5qcgdU4u3oFon+q9WdQsA5hlfsV4IM+/pxng7ff7bV3clG0dtM0NQAG0dT5XgXUOmyI27i7fbGeYmI+mUuDl/cNjh1CCVHjX3oT5WdkY2jq3lJOC+idHre14guT7EUJtA7ZDxiQcMsBUZyBzIdoeqvJmWz/BXDygBkscwvKQtc/W6JmoD7pC5vh+njpLDkr+DAvoSYhb0EGcIpRcuCmbXaWgApEnTRvq7vKD5gzoQihSwMgLYGJNM0QIA4Y2jDsucIgBtDGFNyB7ZMhud51VAPctYApxtQZgAYmwxwC4ouD5hz0VGii7kkY3ku1eQBwAY4C0cAhjsuwxGGzaLfC+W+wQzJA071Kp+2RhEQ3hHDljG5AG9z4JSZYgZeUTiPomHDZWazjCW60ZITScDaS5gdwtwtDEC2m1hiKEAeHvkOqJAh4Bi/DWPGJbHdEVZ9O0jIzv7tHi4i7NpWXXvSZl8gyP7MdeIL0kZUKvd9m/6Rl3XNbzSKurVwFtjOHCXvohkjMkuGWju2J8XFstWqnaJc6HHcIR1rthHK5ZQhZJVIcmPN9byxtRkCyElUYWBYRTWUHL5DrvLyFcQrI1xrwk+WC42F9Te+9TOy+yM2KmWhHYCq2a6nmWz4QgRS0MtLpe2hmtmU9XE33bXzXBDlD3cT2jpnn9DnDJCEPyVrm5kyCy9Vo/u+qQfm49zvBhuy0vthIds70W/aW1a8HopjjwKEEBgfy55U2/iIRxIoOvhol/b+dyXch1KpB7HfgDs71yISc3wwIAAAAASUVORK5CYII=";
const CheckboxSemiactiveIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAP4SURBVHgBnVY7aFVNEJ453uT///ySXBONGh8xhWBhYyM+sLHQxkIQO7ESGy0srGxErBS1sbNJI3Y2CqL4AFEwiKKIqCgS8IXEmFx8xpNzdpzZ2dndEzvPvXt3757ZeXzzzZwDkF1E1OZxlMc4/f31iMcoj1W5bsyM7P35A87cvVb1v35e46vnFRHUyPvgqObhWMbxLFeNvJI9kj2WQL1Xw/Lhbti+YwFt2dqeYrXHEPFsNMTSB6Y/0elzJ1zX1GRVyKHaucyQfPyavEHed05XRBWGFbhwRv4PLGzRkeMj5eIl3fvY2Hk5vJJt3T15uF42NekKFgfzTo6Rzmoo3nNZhCpL3qhrRN+/qOWOn1r9od3XWluwkcP3b9OCzmeQtcizUATUZnZK9tkvYHsyiMJdJBRg7K//r9fkRFlcvfSp3wHsF+Vrxm7AP6YwgBmMYbQpCxQd5FDliqCQUG3IrMYoUYCePf3acgS7xNDqiffQZQ7qjBqCRBIO2D1EzKLV4ff8l9SJIC/Xyxffuxn5xWKo9MpTxHLCkyAjPgZI0CJNnqOQCRQKbMj7WZTXNCuGZtVz7wxhlBZEkBrGoi7vFAac/S95bylCloyhRPHLRyShK2Ka1YwNngBJZVZ4GaS2jjKoNzDkjVk7q9BBsAFqLdOqmJur5kOiiA8GMCLrPwpliMkbdQodzoWHwpqMDYqhTyTmrEpy5l3mdLoclDEiiPWRoZ+nLEEBxjxKCHhjytgsV2HhLEfmGTYQnOOV5YNUo3rRZCpiVloxYN9P5kCn9EmCqQYhKcUQkUPtEiFx3gGkqCfzIEKXGQ9Yk9VppHqCF6ITGIxSZJ/Vm3UYRb5ySobSlKXCMEagOmtbEHJGsRTQdwuvGHMZyptRrKOQxGZjM+9Da1FYQiFyn8u4pxD69mgFmmCWi58elUaUao1SRP5EZE6zj81loxVQIwqyFHDB/tIWlFiCMVnW/xIPI8JBE1GzpAgxth0PpxGXQo4+LhqCd2RWEBK18wbTjFnJp1Ea3Gg5BeMi/7T7uyZm62JcDI0tXQFvU0NQqqLFEnITqZv1t5C36JxvPSFiw3bdht4HVLg3YujO9t1467//sRMdRu3uoW6byUBjWnaP7LlkQmqsZ/68zradg/fgW3m9YCBn2gNwce8hGO3pwenwzE4RaUtBi0CGGkg1leoo4gL/9hSdPQeHRmeq8sbwcHsaEwy0nqfNly/UGx+PlZs70/XQny8c2VuQvmr51y6KLys19A0UrweXtca37V54s7e3uLJmxfwn5gJkxvp42sRj0DkY5IrW5wlvuJorvOL3hQJI5tpJZwHPXZGT+yJb1fSFH6lP55WfH46MjMyY7t9h7TgSR0r/EwAAAABJRU5ErkJggg==";
const InvoicesOverview = (props) => {
  const { bills, vendors, setSelectedBills, selectedBills } = useApp();
  const vendorsToShow = vendors.filter(
    (vendor) => bills.some(
      (bill) => bill.buyerCode === vendor.VendorNo && bill.status !== "Paid"
    )
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-[15px] flex w-[420px] flex-col items-stretch justify-end text-[20px] font-[700] text-[#36597D]", children: "Invoices overview" }),
    vendorsToShow.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: "No invoices to pay!" }),
    vendorsToShow.map((vendor) => {
      const vendorBills = bills.filter(
        (bill) => bill.buyerCode === vendor.VendorNo && bill.status !== "Paid"
      );
      const vendorIsSelected = vendorBills.every(
        (bill) => selectedBills.includes(bill)
      );
      const someBillsSelected = vendorBills.some(
        (bill) => selectedBills.includes(bill)
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ve, { children: ({ open }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { type: "dropdown", ...props, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ve.Button, { className: "w-[100%]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex" }, className: "items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                style: {
                  height: "24px",
                  width: "24px",
                  marginRight: "5px",
                  marginTop: "10px"
                },
                src: vendorIsSelected ? CheckboxActiveIcon : someBillsSelected ? CheckboxSemiactiveIcon : CheckboxInactiveIcon,
                alt: "checkbox not select",
                onClick: () => setSelectedBills(
                  vendorIsSelected ? selectedBills.filter(
                    (bill) => bill.buyerCode !== vendor.VendorNo
                  ) : bills.filter(
                    (bill) => bill.buyerCode === vendor.VendorNo
                  )
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                style: {
                  height: "50px",
                  width: "50px",
                  marginRight: ""
                },
                src: LogoIcon,
                alt: "Logo for " + vendor.Name
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "p",
              {
                style: {
                  color: "#36597D",
                  fontSize: "16px",
                  fontWeight: "600",
                  marginTop: "15px"
                },
                className: "text-left",
                children: vendor.Name
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                marginLeft: "auto",
                marginRight: "0"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "p",
                  {
                    style: {
                      color: "#36597D",
                      fontSize: "14px",
                      fontWeight: "600"
                    },
                    children: [
                      "$",
                      bills.filter(
                        (bill) => bill.buyerCode === vendor.VendorNo
                      ).reduce((acc, curr) => acc + curr.amount, 0).toFixed(2)
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: `${open ? "rotate-180 transform" : ""} h-5 w-5`,
                    style: { height: "24px", width: "24px" },
                    src: Arrow,
                    alt: "Arrow"
                  }
                )
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ve.Panel, { children: bills.filter((bill) => bill.buyerCode === vendor.VendorNo).map((bill) => {
          const isSelected = selectedBills.includes(bill);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", marginTop: "20px" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      style: {
                        height: "24px",
                        width: "24px",
                        marginRight: "20px",
                        marginTop: "10px"
                      },
                      className: "cursor-pointer",
                      src: isSelected ? CheckboxActiveIcon : CheckboxInactiveIcon,
                      alt: "checkbox not select",
                      onClick: () => setSelectedBills(
                        isSelected ? selectedBills.filter(
                          (sBill) => sBill !== bill
                        ) : [...selectedBills, bill]
                      )
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {}, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        style: {
                          color: "#36597D",
                          fontSize: "18px",
                          fontWeight: "600",
                          marginTop: ""
                        },
                        children: bill.invoiceNumber
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "p",
                      {
                        style: {
                          color: "#36597D",
                          fontSize: "14px",
                          fontWeight: "400"
                        },
                        children: [
                          "Issued date:",
                          " ",
                          new Date(
                            bill.invoiceDate
                          ).toLocaleDateString("en-US", {
                            month: "numeric",
                            day: "numeric",
                            year: "numeric"
                          })
                        ]
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      display: "flex",
                      marginLeft: "auto",
                      marginRight: "25px"
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "p",
                      {
                        style: {
                          color: "#36597D",
                          fontSize: "14px",
                          fontWeight: "600",
                          marginTop: "10px"
                        },
                        children: [
                          "$",
                          bill.amount
                        ]
                      }
                    )
                  }
                )
              ]
            },
            bill.invoiceNumber
          );
        }) })
      ] }) }, vendor.VendorNo);
    })
  ] }) });
};
const upiLogo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAUCAYAAAD2rd/BAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANuSURBVHgB7VZLT1NBFP5K4PJs5RWLykOFAGrCI64siUuXRFe6IDEx6i/ArcSt4QcgC1TYuBESXGgAiZqURBCBGiMloEUQWqS179IWWs+Z9rZI29vLwkQSv+R2emfO45vvnJlW4/IFozhCyMERw5EjnKu0aJwzwxcIwtDWiJKigrQ2VrsTJvN3nK3Rk02++K4G9WTPz/KaDV/paWmsRVVlaVY/RcK9j0fpU4MrhpaMNsPj0xiZmMa9W530FkXvwAuoORT1NVXo67mNvmdjWDCv4lHPHUQsM4g6N/DAYUW3oQu6gmL1hDmI1x9ER3sTlGAiO0ZrY51Qu6vzcmJNs89O3oRt24mxKROpeUy8r6xZUVVRKiq0++oJ9syTMJbWQzdbjO6OLhyKMMOgQJgJrlA5WS09EeCntakOShgcfZeImxClLZYjsvqBFN7EOX8A/S4b7l68lqJyRsKsHCvEyinZMFqbagX5caNJKKk5YCery/NjxoWYD8V9PvFezF1qbxatELEuirX7YRfGdgrQPzuSonJawl7/jti9rFwmLCwmqzA1t5RQLxvkuPKGG6gdIpY3iXVdNILz0TBeLk+pI7wgq0vKKYETaun24DYYipONHT5ldNCtI7cT+zL5sHFGrLk1ObiRXwlPWTWGr/ak+KYlPEXXGZdRqX/5sFjtLnEo5Yrw4VG6UfbDOG8WI19tDL4hZLI5Vc14ff2h+ltCLhWrNoT0sNJpB5KHh9GSpSJ/5NjXThErk9fg6YVO5HgdGM5ANi1hG6nGyjFkIkrgwzM4+jaevBlqMU+xS+LttLc4CenmAGrXP2O4wZCRLEOT7s+PLa6eGujp18lHLcFtoVfxS3Uwx2F8GCmEPb6AGPOlXNh/eSDRGArtipEbOxjexcnj5bD8sOEEjSIIkleXg3y0xYXII3tvPBa/M4IUJxQOixz5eXkiJs9xLraR1zlfRZkWEtkcREpLcLDNn3YqV6FIyIEkSaJ5vxiZmpzU8vGLIK8tLsIG+cgJtp3uBNFQKCzGb+tbsNP86VN6Ycfxgk4mm0fxcrGx5aBN5KLxTDU+LVkSYmRVeJMcy2l3rJrbG0BlmY6UdsPjj5FnKbUlMcU4Ma9JUlIJ3gzPs2oMrhIn98Q3H6R1L8XlSsVUDQvSsq+MilKdOsL/Ov7/gf/b+A1V8KiCz/ivegAAAABJRU5ErkJggg==";
function BsCalendarPlus(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M8 7a.5.5 0 0 1 .5.5V9H10a.5.5 0 0 1 0 1H8.5v1.5a.5.5 0 0 1-1 0V10H6a.5.5 0 0 1 0-1h1.5V7.5A.5.5 0 0 1 8 7z" } }, { "tag": "path", "attr": { "d": "M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z" } }] })(props);
}
const toggleSwitchOff = "" + new URL("toggleSwitchOff-063c9245.png", import.meta.url).href;
const AmountSummary = ({
  upiInput,
  // amount = 122.99,
  methodFee = 0.2,
  disabled,
  submit
}) => {
  const { selectedBills } = useApp();
  const amount = selectedBills.reduce((acc, bill) => acc += bill.amount, 0);
  const handleButtonClick = () => {
    submit();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-[30px]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[700] text-[#36597D]", children: "Summary" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-[10px] flex justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Payment amount" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: [
          "₹",
          amount.toFixed(2)
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-[10px] mt-[10px] flex justify-between border-b border-[#8B9EB0] border-opacity-20 pb-[20px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Payment method fee" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: [
          "$",
          methodFee.toFixed(2)
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-[10px] mt-[10px] flex justify-between border-b border-[#8B9EB0] border-opacity-20 pb-[10px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[16px] font-[400] text-[#36597D]", children: "Total amount" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "ml-[auto] text-[16px] font-[600] text-[#36597D]", children: [
          "₹",
          (amount + methodFee).toFixed(2)
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "my-[30px] flex flex-col items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          onClick: handleButtonClick,
          disabled,
          className: "h-[54px] w-[200px]",
          children: [
            "Pay now ₹",
            (amount + methodFee).toFixed(2)
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between pt-[15px]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "color-[#36597D] text-[14px] font-[600]", children: "Auto pay" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            className: "ml-[10px] w-[64px]",
            src: toggleSwitchOff,
            alt: "toggleSwitchOff"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(BsCalendarPlus, { className: "w-[24px]" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "color-[#36597D] ml-[10px] text-[14px] font-[600]", children: "Add a reminder to my calendar" })
      ] })
    ] })
  ] });
};
const UpiPayment = ({ upiInput, handleUpi }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-[20px]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-[10px] text-[14px] font-[600] text-[#8B9EB0]", children: "Enter UPI ID" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pt-[5px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextInput, { value: upiInput, onChange: handleUpi }) })
  ] }) });
};
const methods = [
  {
    method: "RTGS"
  },
  {
    method: "NEFT"
  },
  { method: "IMPS" },
  { method: "UPI", img: upiLogo }
];
const PaymentMethod = (props) => {
  const [upiInput, setUpiInput] = reactExports.useState("");
  const [selectedPay, setSelectedPay] = reactExports.useState();
  const handleUpi = (e2) => {
    setUpiInput(e2.target.value);
  };
  const inactiveStyle = {
    boxShadow: "-2px -2px 2px 0px #B8CCE0, -1px -1px 0px 0px #FFF, -2px -2px 2px 0px #B8CCE0 inset, -1px -1px 0px 0px #FFF inset"
  };
  const activeStyle = {
    boxShadow: "-8px -8px 16px 0px #FFF, 8px 8px 16px 0px #C9D9E8"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[767px] w-[690px]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { className: "w-[630px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "color-[#36597D] mb-[20px] text-[20px] font-[700]", children: "Payment Method" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      yt,
      {
        value: selectedPay,
        onChange: setSelectedPay,
        className: "flex gap-4",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(yt.Label, { className: "sr-only", children: "Choose Payment Type" }),
          methods.map(({ method, img }) => /* @__PURE__ */ jsxRuntimeExports.jsx(yt.Option, { value: method, as: reactExports.Fragment, children: ({ active, checked }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `"box-border flex h-[44px] cursor-pointer items-center justify-center rounded-[20px] bg-[#F1F5FC] px-[20px] py-[10px] ${checked && "border-[3px] border-blue-500 font-semibold text-blue-500"}`,
              style: checked ? activeStyle : inactiveStyle,
              children: img ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: img, alt: "upi" }) : method
            }
          ) }, method))
        ]
      }
    ),
    selectedPay === "upi" && /* @__PURE__ */ jsxRuntimeExports.jsx(UpiPayment, { upiInput, handleUpi }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AmountSummary,
      {
        upiInput,
        disabled: !selectedPay || selectedPay === "upi" && upiInput.length <= 3,
        submit: props.submit
      }
    )
  ] }) });
};
const PayPage = () => {
  const { selectedBills, setBills, setSelectedBills, bills } = useApp();
  const [loading, setLoading] = reactExports.useState(false);
  const [success, setSuccess] = reactExports.useState(false);
  const submit = async () => {
    setLoading(true);
    await sleep$1(5e3);
    const changedBills = selectedBills.map((bill) => ({
      ...bill,
      status: "Paid"
    }));
    setBills([
      ...bills.filter((bill) => !selectedBills.includes(bill)),
      ...changedBills
    ]);
    setSelectedBills([]);
    setSuccess(true);
    setLoading(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(InvoicesOverview, {}),
      selectedBills.length ? /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethod, { submit }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { className: "ml-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex h-full w-full items-center justify-center text-lg font-semibold", children: "Please select some bills." }) })
    ] }),
    loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed left-0 top-0 z-[999999] flex h-full w-full items-center justify-center bg-black/50", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 60, color: "white" }) }),
    success && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed left-0 top-0 flex h-full w-full items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "neu", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentSuccess, {}) }) })
  ] });
};
const DueSoon = ({
  invoiceId = "001623",
  amount = 620,
  invoiceDate = "2021-02-04",
  dueDate = "2021-03-04",
  account = {},
  status = "Unpaid",
  ...props
}) => {
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container,
    {
      className: "relative flex cursor-pointer flex-row items-center justify-between transition-all duration-300 hover:shadow-md",
      padding: "xs",
      type: "list",
      onClick: () => navigate(`invoice/${invoiceId}`),
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoIcon, className: "-ml-3" }),
        status === "Paid" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-0 top-1 z-50 flex h-[83px] w-[79px] items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(RiCheckboxCircleFill, { className: "text-green-500", size: 36 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-initial", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-1 flex items-center leading-5 text-[#8B9EB0]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium", children: "Invoice ID:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-1 text-[10px]", children: invoiceId })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-1.5 text-[18px] font-bold leading-5 text-[#36597D]", children: account?.biller?.organization?.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-[12px] font-normal leading-normal text-[#8B9EB0]", children: [
            "Invoice date:",
            " ",
            new Date(invoiceDate).toLocaleDateString("en-US", {
              month: "numeric",
              day: "numeric",
              year: "numeric"
            })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-[5px] text-right text-[24px] font-bold leading-normal text-[#36597D]", children: [
            "$",
            amount
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mb-[5px] text-right text-[12px] font-normal leading-normal text-[#36597D]", children: [
            "Due date: ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            new Date(dueDate).toLocaleDateString("en-US", {
              month: "numeric",
              day: "numeric",
              year: "numeric"
            })
          ] })
        ] })
      ]
    }
  );
};
const DueSoonWidget = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { className: "relative", padding: "sm", ...props, type: "neu", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mb-2 text-[18px]", children: "Invoices Due Soon" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/pay", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { intent: "primary", size: "small", className: "h-8", children: "Pay" }) })
    ] }),
    props.bills.map((bill) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[10px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DueSoon,
      {
        invoiceId: bill.invoiceNumber.toString(),
        amount: bill.amount,
        dueDate: bill.dueDate,
        invoiceDate: bill.invoiceDate,
        account: { biller: { organization: { name: bill.buyer } } },
        status: bill.status
      }
    ) }, bill.invoiceNumber))
  ] });
};
const colors = [
  "bg-green-500/20 text-green-500",
  "bg-blue-500/20 text-blue-500",
  "bg-violet-500/20 text-violet-500",
  "bg-cyan-500/20 text-cyan-500",
  "bg-orange-500/20 text-orange-500"
];
const industries = ["Retail", "Government", "Utility", "Industrial"];
const HomePage = () => {
  const navigate = useNavigate();
  const { vendors, bills, loading, payments } = useApp();
  console.log(loading);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid-cls-1 grid h-full grid-cols-2 grid-rows-2 children:p-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-1 col-start-1 row-span-2 row-start-1", children: !loading || vendors.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { type: "neu", padding: "sm", className: "overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "mb-2 text-[18px]", children: [
        "Vendors (",
        vendors.length,
        ")"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-m-4 mb-2 max-h-[calc(100vh_-_240px)] overflow-y-scroll p-4", children: vendors.map((vendor) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Container,
          {
            type: "list",
            className: "mb-1 cursor-pointer p-1 transition-all duration-150 hover:shadow-md",
            padding: "xs",
            onClick: () => navigate(`biller/${vendor.VendorNo}`),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center text-sm", children: [
                "Vendor No.",
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "code",
                  {
                    className: `rounded-md ${colors[vendor.VendorNo % colors.length]} p-1 text-xs`,
                    children: vendor.VendorNo
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "code",
                  {
                    className: `ml-2 rounded-md ${colors[vendor.VendorNo % colors.length]} px-1 py-[2px] text-[10px]`,
                    children: industries[vendor.VendorNo % industries.length]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-bold", children: vendor.Name })
            ]
          },
          vendor.VendorNo
        );
      }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(LoadingSkeleton, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2 flex items-end justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mr-4 text-[18px]", children: "Vendors" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 16 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "list", className: "mb-1", padding: "md" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "list", className: "mb-1", padding: "md" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "list", className: "mb-1", padding: "md" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(LoadingSkeleton, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2 flex items-end justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "mr-4 text-[18px]", children: "Invoices Due Soon" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, { size: 16 })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "list", className: "mb-1", padding: "lg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { type: "list", className: "mb-1", padding: "lg" })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DueSoonWidget, { bills }) })
  ] }) });
};
const createRouter = isE ? createHashRouter : createBrowserRouter;
const noAuthRouter = createRouter(
  [
    {
      Component: NoauthLayout,
      ErrorBoundary: NoauthLayout,
      children: [
        {
          index: true,
          loader: async () => {
            const { session } = await getSession();
            if (session)
              return redirect("/onboarding");
            return null;
          },
          Component: SplashPage$1
        },
        {
          path: "/onboarding",
          loader: async () => {
            const { session } = await getSession();
            if (!session)
              return redirect("/");
            return null;
          },
          Component: OnboardingPage
        }
      ]
    }
  ],
  {
    future: {
      v7_normalizeFormMethod: true
    }
  }
);
const authRouter = createRouter(
  [
    {
      Component: AuthLayout$1,
      ErrorBoundary: AuthLayout$1,
      children: [
        {
          index: true,
          Component: HomePage
        },
        {
          path: "/onboarding",
          loader: () => redirect("/"),
          Component: () => null
        },
        {
          path: "/biller/:billerId",
          Component: BillerPage
        },
        {
          path: "/invoice/:invoiceId",
          Component: InvoicePage
        },
        {
          path: "/billers",
          Component: AllBillersPage
        },
        {
          path: "/invoices",
          Component: AllInvoicesPage
        },
        {
          path: "/pay",
          Component: PayPage
        }
        //   {
        //     path: "/settings",
        //     Component: SettingsPage,
        //   },
        //   {
        //     path: "/profile",
        //   },
        //   {
        //     path: "*",
        //     Component: NotFoundPage,
        //   },
      ]
    }
  ],
  {
    future: {
      v7_normalizeFormMethod: true
    }
  }
);
const Router = () => {
  const root = useRootStore();
  const supabaseLoaded = root.auth.supabaseLoaded;
  const session = root.auth.session;
  const chooseRouter = () => {
    if (!supabaseLoaded && storedSession) {
      return storedSession.user ? authRouter : noAuthRouter;
    }
    if (session) {
      return session.user ? authRouter : noAuthRouter;
    }
    return noAuthRouter;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    RouterProvider,
    {
      router: chooseRouter(),
      future: { v7_startTransition: true },
      fallbackElement: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "fallback" })
    }
  ) });
};
const Router$1 = observer(Router);
const App = () => {
  const [root] = reactExports.useState(() => init());
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SessionProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootProvider, { value: root, children: /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalContextProvider$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ThemeProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Router$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Debug, {})
  ] }) }) }) });
};
const App$1 = observer(App);
const index = "";
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App$1, {}) })
);
export {
  commonjsGlobal as c,
  getAugmentedNamespace as g
};
